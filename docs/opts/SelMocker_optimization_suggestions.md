# SelMocker 优化建议文档

本文档记录了对 SelMocker.cpp 文件的代码审查过程中发现的可能优化点。这些建议旨在提高代码质量、性能和可维护性，但不会直接修改原始代码，仅作为未来改进的参考。

## 代码结构优化

1. **日志记录函数优化**
   - 当前 `log_signal`, `log_trade` 和 `log_close` 函数中直接使用字符串拼接构造 CSV 格式，可以考虑使用 fmt 库统一格式化
   - 在修复之前的 fmt 格式化版本后发现，这些函数使用的格式不统一，建议统一日志格式
   - 示例改进：
     ```cpp
     // 使用统一的 fmt 格式
     void SelMocker::log_signal(const char* stdCode, double target, double price, uint64_t gentime, const char* usertag)
     {
         _sig_logs << fmt::format("{},{},{},{},{},{}\n", gentime, stdCode, price, target, usertag, _strategy->id());
     }
     ```

2. **错误处理机制**
   - 许多函数在错误情况下（如参数无效、资源不存在等）直接返回或使用默认值，但没有记录详细的错误信息
   - 建议增强错误日志，便于调试和问题排查
   - 示例改进：
     ```cpp
     // 增加详细错误日志
     bool SelMocker::init_sel_factory(WTSVariant* cfg)
     {
         if (cfg == NULL)
         {
             log_error("Strategy configuration is NULL");
             return false;
         }
         // 其它代码...
     }
     ```

## 功能优化

1. **滑点模型优化**
   - 当前滑点模型相对简单，只支持固定滑点和比例滑点两种方式
   - 建议增加更复杂的滑点模型，如基于成交量的动态滑点、根据市场波动性的滑点等
   - 在真实市场中，高成交量和高波动性可能导致更大的滑点

2. **信号管理功能增强**
   - 当前的信号管理相对简单，可以考虑增加信号优先级、信号有效期、条件触发等高级功能
   - 建议增加信号过滤机制，避免频繁的小额交易

3. **策略参数动态调整**
   - 目前策略参数在初始化后不易修改，可以考虑增加动态调整参数的接口
   - 这对于需要进行参数敏感性分析的场景非常有用

## 性能优化

1. **数据结构优化**
   - 大量使用 `wt_hashmap` 和 `wt_hashset`，这些结构可能在高频操作时有性能瓶颈
   - 对于频繁查询的数据，可以考虑使用更高效的数据结构或缓存机制

2. **内存管理优化**
   - `dump_stradata` 函数中创建大量临时对象，可能导致内存碎片
   - 建议使用内存池或预分配策略减少内存分配/释放操作
   - 对于 `rapidjson` 的使用，可以考虑复用 `allocator` 以减少内存分配开销

3. **并行计算潜力**
   - 在处理多个合约的数据时，可以考虑利用并行计算提高性能
   - 特别是 `update_dyn_profit` 函数中的计算可以并行化

## 可维护性优化

1. **注释规范性**
   - 虽然已经添加了大量 Doxygen 风格的注释，但部分函数的参数描述不够准确或缺少
   - 建议统一规范化注释风格，确保所有参数和返回值都有清晰的说明

2. **代码模块化**
   - 一些功能如资金管理、持仓管理等可以进一步模块化，提高代码的组织性和可重用性
   - 建议将相关功能抽取为独立的类或模块

3. **单元测试覆盖**
   - 建议增加单元测试，提高代码的可测试性和稳定性
   - 特别是对关键算法如滑点计算、盈亏计算等应该有完整的测试覆盖

## 安全性优化

1. **输入验证**
   - 部分函数缺乏对输入参数的充分验证，可能导致意外行为
   - 建议增加参数校验，提高代码健壮性

2. **资源泄露防护**
   - 虽然使用了智能指针等机制，但仍有少量资源管理不完善的地方
   - 建议全面检查资源管理，确保所有资源都能正确释放

## 总结

SelMocker 类作为选股策略的回测模拟器，整体设计合理，代码质量较高。以上建议旨在进一步提升代码质量和性能，可根据实际情况选择性实施。
