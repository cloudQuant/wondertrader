<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WonderTrader: BoostFile类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WonderTrader<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">高性能量化交易平台</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classBoostFile.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="classBoostFile-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">BoostFile类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>boost库文件操作的封装类  
 <a href="classBoostFile.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a8d63921be188123d2ba9eb94a1f2516a" id="r_a8d63921be188123d2ba9eb94a1f2516a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a8d63921be188123d2ba9eb94a1f2516a">BoostFile</a> ()</td></tr>
<tr class="memdesc:a8d63921be188123d2ba9eb94a1f2516a"><td class="mdescLeft">&#160;</td><td class="mdescRight">默认构造函数  <br /></td></tr>
<tr class="separator:a8d63921be188123d2ba9eb94a1f2516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54af2e681e144ef60705e9b4356e129f" id="r_a54af2e681e144ef60705e9b4356e129f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a54af2e681e144ef60705e9b4356e129f">~BoostFile</a> ()</td></tr>
<tr class="memdesc:a54af2e681e144ef60705e9b4356e129f"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数  <br /></td></tr>
<tr class="separator:a54af2e681e144ef60705e9b4356e129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab32a7044d5e65fb18aca7fd90b864" id="r_a5eab32a7044d5e65fb18aca7fd90b864"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a5eab32a7044d5e65fb18aca7fd90b864">create_new_file</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name, boost::interprocess::mode_t mode=boost::interprocess::read_write, bool temporary=false)</td></tr>
<tr class="memdesc:a5eab32a7044d5e65fb18aca7fd90b864"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建新文件  <br /></td></tr>
<tr class="separator:a5eab32a7044d5e65fb18aca7fd90b864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a83c17ff9c66d7bbcb32896062c656a" id="r_a8a83c17ff9c66d7bbcb32896062c656a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a8a83c17ff9c66d7bbcb32896062c656a">create_or_open_file</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name, boost::interprocess::mode_t mode=boost::interprocess::read_write, bool temporary=false)</td></tr>
<tr class="memdesc:a8a83c17ff9c66d7bbcb32896062c656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建或打开文件  <br /></td></tr>
<tr class="separator:a8a83c17ff9c66d7bbcb32896062c656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a0728e2a2f9f95ede282966424a4a" id="r_a1c5a0728e2a2f9f95ede282966424a4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a1c5a0728e2a2f9f95ede282966424a4a">open_existing_file</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name, boost::interprocess::mode_t mode=boost::interprocess::read_write, bool temporary=false)</td></tr>
<tr class="memdesc:a1c5a0728e2a2f9f95ede282966424a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">打开现有文件  <br /></td></tr>
<tr class="separator:a1c5a0728e2a2f9f95ede282966424a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a95d92d05f738947b61d7a416c92654" id="r_a3a95d92d05f738947b61d7a416c92654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a3a95d92d05f738947b61d7a416c92654">is_invalid_file</a> ()</td></tr>
<tr class="memdesc:a3a95d92d05f738947b61d7a416c92654"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查文件句柄是否无效  <br /></td></tr>
<tr class="separator:a3a95d92d05f738947b61d7a416c92654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56152ae9b1cea225f9e65207f7906a8" id="r_ad56152ae9b1cea225f9e65207f7906a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#ad56152ae9b1cea225f9e65207f7906a8">valid</a> ()</td></tr>
<tr class="memdesc:ad56152ae9b1cea225f9e65207f7906a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查文件句柄是否有效  <br /></td></tr>
<tr class="separator:ad56152ae9b1cea225f9e65207f7906a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5481db505f5c5d99c9aa9ba36806bff0" id="r_a5481db505f5c5d99c9aa9ba36806bff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a5481db505f5c5d99c9aa9ba36806bff0">close_file</a> ()</td></tr>
<tr class="memdesc:a5481db505f5c5d99c9aa9ba36806bff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">关闭文件  <br /></td></tr>
<tr class="separator:a5481db505f5c5d99c9aa9ba36806bff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a2cd0d09d6ef067d3b600c8ce863d" id="r_a0f2a2cd0d09d6ef067d3b600c8ce863d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a0f2a2cd0d09d6ef067d3b600c8ce863d">truncate_file</a> (std::size_t size)</td></tr>
<tr class="memdesc:a0f2a2cd0d09d6ef067d3b600c8ce863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">截断文件到指定大小  <br /></td></tr>
<tr class="separator:a0f2a2cd0d09d6ef067d3b600c8ce863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c1d64ab4ca5bfa2b1ffbe9b3dde27e" id="r_a98c1d64ab4ca5bfa2b1ffbe9b3dde27e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a98c1d64ab4ca5bfa2b1ffbe9b3dde27e">get_file_size</a> (boost::interprocess::offset_t &amp;size)</td></tr>
<tr class="memdesc:a98c1d64ab4ca5bfa2b1ffbe9b3dde27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取文件大小  <br /></td></tr>
<tr class="separator:a98c1d64ab4ca5bfa2b1ffbe9b3dde27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7554f5f6e1f83ab4f1b4e113edca542" id="r_ac7554f5f6e1f83ab4f1b4e113edca542"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#ac7554f5f6e1f83ab4f1b4e113edca542">get_file_size</a> ()</td></tr>
<tr class="memdesc:ac7554f5f6e1f83ab4f1b4e113edca542"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取文件大小  <br /></td></tr>
<tr class="separator:ac7554f5f6e1f83ab4f1b4e113edca542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250a9eba00b03eb55dc3a76a4f0f0a23" id="r_a250a9eba00b03eb55dc3a76a4f0f0a23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a250a9eba00b03eb55dc3a76a4f0f0a23">set_file_pointer</a> (boost::interprocess::offset_t off, boost::interprocess::file_pos_t pos)</td></tr>
<tr class="memdesc:a250a9eba00b03eb55dc3a76a4f0f0a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置文件指针位置  <br /></td></tr>
<tr class="separator:a250a9eba00b03eb55dc3a76a4f0f0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dd971735a40b7008c18d0d9c686522" id="r_ae6dd971735a40b7008c18d0d9c686522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#ae6dd971735a40b7008c18d0d9c686522">seek_to_begin</a> (int offsize=0)</td></tr>
<tr class="memdesc:ae6dd971735a40b7008c18d0d9c686522"><td class="mdescLeft">&#160;</td><td class="mdescRight">将文件指针移动到文件开头  <br /></td></tr>
<tr class="separator:ae6dd971735a40b7008c18d0d9c686522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ff0290c6126f8dc31ac0b991ac5421" id="r_ae0ff0290c6126f8dc31ac0b991ac5421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#ae0ff0290c6126f8dc31ac0b991ac5421">seek_current</a> (int offsize=0)</td></tr>
<tr class="memdesc:ae0ff0290c6126f8dc31ac0b991ac5421"><td class="mdescLeft">&#160;</td><td class="mdescRight">将文件指针相对于当前位置移动  <br /></td></tr>
<tr class="separator:ae0ff0290c6126f8dc31ac0b991ac5421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d44b29939730066ab6d69f8477a24e" id="r_a35d44b29939730066ab6d69f8477a24e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a35d44b29939730066ab6d69f8477a24e">seek_to_end</a> (int offsize=0)</td></tr>
<tr class="memdesc:a35d44b29939730066ab6d69f8477a24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">将文件指针移动到文件结尾  <br /></td></tr>
<tr class="separator:a35d44b29939730066ab6d69f8477a24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186f0ea1321016ee613e18b1afbfd3f5" id="r_a186f0ea1321016ee613e18b1afbfd3f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a186f0ea1321016ee613e18b1afbfd3f5">get_file_pointer</a> (boost::interprocess::offset_t &amp;off)</td></tr>
<tr class="memdesc:a186f0ea1321016ee613e18b1afbfd3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前文件指针位置  <br /></td></tr>
<tr class="separator:a186f0ea1321016ee613e18b1afbfd3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc650dc2d5f9e4cbfa0d7a5472ea66bb" id="r_adc650dc2d5f9e4cbfa0d7a5472ea66bb"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#adc650dc2d5f9e4cbfa0d7a5472ea66bb">get_file_pointer</a> ()</td></tr>
<tr class="memdesc:adc650dc2d5f9e4cbfa0d7a5472ea66bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前文件指针位置  <br /></td></tr>
<tr class="separator:adc650dc2d5f9e4cbfa0d7a5472ea66bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29c4c4ed11acc16411e3fcc986f6e3" id="r_aca29c4c4ed11acc16411e3fcc986f6e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#aca29c4c4ed11acc16411e3fcc986f6e3">write_file</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *data, std::size_t numdata)</td></tr>
<tr class="memdesc:aca29c4c4ed11acc16411e3fcc986f6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">写入数据到文件  <br /></td></tr>
<tr class="separator:aca29c4c4ed11acc16411e3fcc986f6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1543235872c0d2c9b0df16335c1e356d" id="r_a1543235872c0d2c9b0df16335c1e356d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a1543235872c0d2c9b0df16335c1e356d">write_file</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;data)</td></tr>
<tr class="memdesc:a1543235872c0d2c9b0df16335c1e356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">写入字符串数据到文件  <br /></td></tr>
<tr class="separator:a1543235872c0d2c9b0df16335c1e356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8664402121aacfa3e8188031f950fb71" id="r_a8664402121aacfa3e8188031f950fb71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a8664402121aacfa3e8188031f950fb71">read_file</a> (void *data, std::size_t numdata)</td></tr>
<tr class="memdesc:a8664402121aacfa3e8188031f950fb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">从文件读取数据  <br /></td></tr>
<tr class="separator:a8664402121aacfa3e8188031f950fb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215f5139fb99cde5a5ba9bf699e000fc" id="r_a215f5139fb99cde5a5ba9bf699e000fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a215f5139fb99cde5a5ba9bf699e000fc">read_file_length</a> (void *data, std::size_t numdata)</td></tr>
<tr class="memdesc:a215f5139fb99cde5a5ba9bf699e000fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">从文件读取数据并返回实际读取到的字节数  <br /></td></tr>
<tr class="separator:a215f5139fb99cde5a5ba9bf699e000fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a5caeb46a200703d3464962962cd70abb" id="r_a5caeb46a200703d3464962962cd70abb"><td class="memItemLeft" align="right" valign="top">static unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a5caeb46a200703d3464962962cd70abb">get_file_size</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="memdesc:a5caeb46a200703d3464962962cd70abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定文件的大小（静态方法）  <br /></td></tr>
<tr class="separator:a5caeb46a200703d3464962962cd70abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b964d9b718fedfb3bad81fd66c8e46" id="r_ae0b964d9b718fedfb3bad81fd66c8e46"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#ae0b964d9b718fedfb3bad81fd66c8e46">delete_file</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="memdesc:ae0b964d9b718fedfb3bad81fd66c8e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除指定文件（静态方法）  <br /></td></tr>
<tr class="separator:ae0b964d9b718fedfb3bad81fd66c8e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc1e870483d6cb55dbcfdafaa62be9a" id="r_abdc1e870483d6cb55dbcfdafaa62be9a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#abdc1e870483d6cb55dbcfdafaa62be9a">read_file_contents</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename, std::string &amp;buffer)</td></tr>
<tr class="memdesc:abdc1e870483d6cb55dbcfdafaa62be9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">读取文件全部内容到字符串（静态方法）  <br /></td></tr>
<tr class="separator:abdc1e870483d6cb55dbcfdafaa62be9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e78b2445ae39b733883796bdde9225" id="r_ae9e78b2445ae39b733883796bdde9225"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#ae9e78b2445ae39b733883796bdde9225">write_file_contents</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *filename, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *pdata, uint32_t datalen)</td></tr>
<tr class="memdesc:ae9e78b2445ae39b733883796bdde9225"><td class="mdescLeft">&#160;</td><td class="mdescRight">写入数据到文件（静态方法）  <br /></td></tr>
<tr class="separator:ae9e78b2445ae39b733883796bdde9225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1224c49e2baa9ca660fa32a78985ad5a" id="r_a1224c49e2baa9ca660fa32a78985ad5a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a1224c49e2baa9ca660fa32a78985ad5a">create_directory</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="memdesc:a1224c49e2baa9ca660fa32a78985ad5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建目录（静态方法）  <br /></td></tr>
<tr class="separator:a1224c49e2baa9ca660fa32a78985ad5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81da0853e01b03e97dad08b846a1177d" id="r_a81da0853e01b03e97dad08b846a1177d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#a81da0853e01b03e97dad08b846a1177d">create_directories</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="memdesc:a81da0853e01b03e97dad08b846a1177d"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建多级目录（静态方法）  <br /></td></tr>
<tr class="separator:a81da0853e01b03e97dad08b846a1177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab642b9bcdfa02c81c2530110eb8a61e" id="r_aab642b9bcdfa02c81c2530110eb8a61e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#aab642b9bcdfa02c81c2530110eb8a61e">exists</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *name)</td></tr>
<tr class="memdesc:aab642b9bcdfa02c81c2530110eb8a61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查文件或目录是否存在（静态方法）  <br /></td></tr>
<tr class="separator:aab642b9bcdfa02c81c2530110eb8a61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:adc4459bbb8b27072ff1be0a4e8308f09" id="r_adc4459bbb8b27072ff1be0a4e8308f09"><td class="memItemLeft" align="right" valign="top">boost::interprocess::file_handle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBoostFile.html#adc4459bbb8b27072ff1be0a4e8308f09">_handle</a></td></tr>
<tr class="memdesc:adc4459bbb8b27072ff1be0a4e8308f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">文件句柄  <br /></td></tr>
<tr class="separator:adc4459bbb8b27072ff1be0a4e8308f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>boost库文件操作的封装类 </p>
<p>BoostFile类提供了一组基于boost::interprocess的文件操作方法， 包括创建、打开、关闭、读取、写入和操作文件指针等功能。 该类封装了底层的文件操作函数，设计为跨平台可用，支持Windows和Unix/Linux系统。 类中包含实例方法和静态方法，实例方法用于操作指定的文件，静态方法提供了便捷的文件操作工具。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00044">44</a> 行定义.</p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="a8d63921be188123d2ba9eb94a1f2516a" name="a8d63921be188123d2ba9eb94a1f2516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d63921be188123d2ba9eb94a1f2516a">&#9670;&#160;</a></span>BoostFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BoostFile::BoostFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>默认构造函数 </p>
<p>创建一个新的BoostFile实例，并将文件句柄初始化为无效值。 构造后的对象需要调用创建或打开文件的方法才能进行文件操作。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00053">53</a> 行定义.</p>

</div>
</div>
<a id="a54af2e681e144ef60705e9b4356e129f" name="a54af2e681e144ef60705e9b4356e129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af2e681e144ef60705e9b4356e129f">&#9670;&#160;</a></span>~BoostFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BoostFile::~BoostFile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>析构函数 </p>
<p>析构对象时自动关闭文件句柄，确保文件正确关闭。 调用close_file()方法来完成文件关闭操作，防止资源泄漏。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00063">63</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a5481db505f5c5d99c9aa9ba36806bff0" name="a5481db505f5c5d99c9aa9ba36806bff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5481db505f5c5d99c9aa9ba36806bff0">&#9670;&#160;</a></span>close_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BoostFile::close_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>关闭文件 </p>
<p>关闭当前打开的文件，并将文件句柄设置为无效值。 该方法首先检查文件句柄是否有效，如果有效，才会进行关闭操作， 这样可以避免尝试关闭已经关闭或从未打开的文件。 关闭文件后，将文件句柄重置为无效状态，这样可以防止对已关闭文件的误操作。 在析构函数中会自动调用此方法以确保文件在对象销毁时被正确关闭。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00162">162</a> 行定义.</p>

</div>
</div>
<a id="a81da0853e01b03e97dad08b846a1177d" name="a81da0853e01b03e97dad08b846a1177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81da0853e01b03e97dad08b846a1177d">&#9670;&#160;</a></span>create_directories()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BoostFile::create_directories </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建多级目录（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>要创建的目录路径（可以包含多级目录） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 创建成功或目录已存在返回true，失败返回false</dd></dl>
<p>该静态方法用于创建指定的目录，包括中间的所有父级目录。 首先使用exists方法检查目录是否已存在，如果已存在则直接返回true。 如果目录不存在，则使用boost::filesystem::create_directories函数创建目录。 与 create_directory 方法的区别是，该方法可以创建多级目录结构，如果路径中的父目录不存在，也会自动创建。 例如，可以创建如 "a/b/c" 这样的目录结构，即使 a 和 b 目录不存在。 如果目录无法创建（例如由于权限问题或路径错误），则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00527">527</a> 行定义.</p>

</div>
</div>
<a id="a1224c49e2baa9ca660fa32a78985ad5a" name="a1224c49e2baa9ca660fa32a78985ad5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1224c49e2baa9ca660fa32a78985ad5a">&#9670;&#160;</a></span>create_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BoostFile::create_directory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建目录（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>要创建的目录名称（包含路径） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 创建成功或目录已存在返回true，失败返回false</dd></dl>
<p>该静态方法用于创建指定的目录。 首先使用exists方法检查目录是否已存在，如果已存在则直接返回true。 如果目录不存在，则使用boost::filesystem::create_directory函数创建目录。 该方法只能创建一级目录，如果需要创建多级目录，应使用create_directories方法。 如果目录无法创建（例如由于权限问题或路径错误），则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00506">506</a> 行定义.</p>

</div>
</div>
<a id="a5eab32a7044d5e65fb18aca7fd90b864" name="a5eab32a7044d5e65fb18aca7fd90b864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eab32a7044d5e65fb18aca7fd90b864">&#9670;&#160;</a></span>create_new_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::create_new_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::interprocess::mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code>boost::interprocess::read_write</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>temporary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建新文件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>文件名称（包含路径） </td></tr>
    <tr><td class="paramname">mode</td><td>文件访问模式，默认为读写模式（read_write） </td></tr>
    <tr><td class="paramname">temporary</td><td>是否为临时文件，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 创建成功返回true，失败返回false</dd></dl>
<p>创建一个新文件并将其打开以进行操作。如果文件已存在，会将其截断为零长度， 相当于清空文件内容。如果成功创建文件，方法会调用truncate_file(0)将文件大小设置为0。 如果文件创建失败或截断失败，则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00080">80</a> 行定义.</p>

</div>
</div>
<a id="a8a83c17ff9c66d7bbcb32896062c656a" name="a8a83c17ff9c66d7bbcb32896062c656a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a83c17ff9c66d7bbcb32896062c656a">&#9670;&#160;</a></span>create_or_open_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::create_or_open_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::interprocess::mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code>boost::interprocess::read_write</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>temporary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建或打开文件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>文件名称（包含路径） </td></tr>
    <tr><td class="paramname">mode</td><td>文件访问模式，默认为读写模式（read_write） </td></tr>
    <tr><td class="paramname">temporary</td><td>是否为临时文件，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 创建或打开成功返回true，失败返回false</dd></dl>
<p>创建新文件或打开现有文件。如果文件不存在，则创建新文件；如果文件已存在，则直接打开现有文件。 与 create_new_file 不同的是，此方法不会截断或清空现有文件的内容。 返回值通过调用 <a class="el" href="classBoostFile.html#ad56152ae9b1cea225f9e65207f7906a8" title="检查文件句柄是否有效">valid()</a> 方法来确定文件是否成功打开。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00101">101</a> 行定义.</p>

</div>
</div>
<a id="ae0b964d9b718fedfb3bad81fd66c8e46" name="ae0b964d9b718fedfb3bad81fd66c8e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b964d9b718fedfb3bad81fd66c8e46">&#9670;&#160;</a></span>delete_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BoostFile::delete_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>删除指定文件（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>要删除的文件名称（包含路径） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 删除成功返回true，失败返回false</dd></dl>
<p>删除指定路径的文件。这是一个静态方法，可以直接通过类名调用，而不需要创建 <a class="el" href="classBoostFile.html" title="boost库文件操作的封装类">BoostFile</a> 对象。 该方法内部调用 boost::interprocess::ipcdetail::delete_file 函数来实现文件删除操作。 如果文件不存在，或者没有足够的权限删除文件，则返回false。 该方法提供了一个便捷的方式来删除文件，而无需手动管理 <a class="el" href="classBoostFile.html" title="boost库文件操作的封装类">BoostFile</a> 对象的创建和销毁。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00442">442</a> 行定义.</p>

</div>
</div>
<a id="aab642b9bcdfa02c81c2530110eb8a61e" name="aab642b9bcdfa02c81c2530110eb8a61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab642b9bcdfa02c81c2530110eb8a61e">&#9670;&#160;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BoostFile::exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查文件或目录是否存在（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>要检查的文件或目录路径 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 如果文件或目录存在返回true，不存在返回false</dd></dl>
<p>该静态方法用于检查指定路径的文件或目录是否存在。 内部调用boost::filesystem::exists函数来实现这一功能。 该方法可以检查普通文件、目录、符号链接等各种文件系统对象的存在性。 该方法在create_directory和create_directories方法中被调用，用于检查目标目录是否已存在。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00546">546</a> 行定义.</p>

</div>
</div>
<a id="adc650dc2d5f9e4cbfa0d7a5472ea66bb" name="adc650dc2d5f9e4cbfa0d7a5472ea66bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc650dc2d5f9e4cbfa0d7a5472ea66bb">&#9670;&#160;</a></span>get_file_pointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long BoostFile::get_file_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前文件指针位置 </p>
<dl class="section return"><dt>返回</dt><dd>unsigned long long 当前文件指针的位置，如果获取失败则返回0</dd></dl>
<p>获取当前文件的读写指针位置并返回。这是另一个get_file_pointer方法的简化版本， 其内部调用了带引用参数的get_file_pointer方法来获取指针位置。 如果获取文件指针位置失败（例如文件句柄无效），则返回0。 这个方法更方便使用，当不需要知道是否成功获取了文件指针位置时可以使用此方法。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00330">330</a> 行定义.</p>

</div>
</div>
<a id="a186f0ea1321016ee613e18b1afbfd3f5" name="a186f0ea1321016ee613e18b1afbfd3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186f0ea1321016ee613e18b1afbfd3f5">&#9670;&#160;</a></span>get_file_pointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::get_file_pointer </td>
          <td>(</td>
          <td class="paramtype">boost::interprocess::offset_t &amp;&#160;</td>
          <td class="paramname"><em>off</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前文件指针位置 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">off</td><td>输出参数，用于存储当前文件指针的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 获取成功返回true，失败返回false</dd></dl>
<p>获取当前文件的读写指针位置，并将结果存储在off参数中。 这个方法使用boost::interprocess::ipcdetail命名空间中的get_file_pointer函数来获取指针位置。 如果文件句柄无效或获取读写指针位置时发生错误，则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00315">315</a> 行定义.</p>

</div>
</div>
<a id="ac7554f5f6e1f83ab4f1b4e113edca542" name="ac7554f5f6e1f83ab4f1b4e113edca542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7554f5f6e1f83ab4f1b4e113edca542">&#9670;&#160;</a></span>get_file_size() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long BoostFile::get_file_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取文件大小 </p>
<dl class="section return"><dt>返回</dt><dd>unsigned long long 文件大小，单位为字节，如果获取失败则返回0</dd></dl>
<p>获取当前打开文件的大小并返回。这是另一个get_file_size方法的简化版本， 其内部调用了带引用参数的get_file_size方法来获取文件大小。 如果获取文件大小失败（例如文件句柄无效），则返回0。 这个方法更方便使用，当不需要知道是否成功获取了文件大小时可以使用此方法。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00211">211</a> 行定义.</p>

</div>
</div>
<a id="a98c1d64ab4ca5bfa2b1ffbe9b3dde27e" name="a98c1d64ab4ca5bfa2b1ffbe9b3dde27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c1d64ab4ca5bfa2b1ffbe9b3dde27e">&#9670;&#160;</a></span>get_file_size() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::get_file_size </td>
          <td>(</td>
          <td class="paramtype">boost::interprocess::offset_t &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取文件大小 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>输出参数，用于存储文件大小 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 获取成功返回true，失败返回false</dd></dl>
<p>获取当前打开文件的大小，并将结果存储在size参数中。 这个方法使用boost::interprocess::ipcdetail命名空间中的get_file_size函数来获取文件大小。 如果文件句柄无效或获取大小时发生错误，则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00196">196</a> 行定义.</p>

</div>
</div>
<a id="a5caeb46a200703d3464962962cd70abb" name="a5caeb46a200703d3464962962cd70abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caeb46a200703d3464962962cd70abb">&#9670;&#160;</a></span>get_file_size() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned long long BoostFile::get_file_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定文件的大小（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>文件名称（包含路径） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>unsigned long long 文件大小，单位为字节，如果文件不存在或无法打开则返回0</dd></dl>
<p>该静态方法用于获取指定文件的大小，无需首先创建 <a class="el" href="classBoostFile.html" title="boost库文件操作的封装类">BoostFile</a> 对象。 内部实现是创建一个临时的 <a class="el" href="classBoostFile.html" title="boost库文件操作的封装类">BoostFile</a> 对象，打开指定文件，获取其大小，然后关闭文件并返回结果。 如果文件不存在或无法打开，则返回0。 这个方法提供了一个便捷的方式来检查文件大小，而无需手动管理文件的打开和关闭。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00230">230</a> 行定义.</p>

</div>
</div>
<a id="a3a95d92d05f738947b61d7a416c92654" name="a3a95d92d05f738947b61d7a416c92654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a95d92d05f738947b61d7a416c92654">&#9670;&#160;</a></span>is_invalid_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::is_invalid_file </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查文件句柄是否无效 </p>
<dl class="section return"><dt>返回</dt><dd>bool 文件句柄无效返回true，有效返回false</dd></dl>
<p>检查当前文件句柄是否为无效值。这个方法可用于判断文件是否已经打开或创建成功。 内部实现是将当前文件句柄与Boost库中定义的无效文件句柄进行比较。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00134">134</a> 行定义.</p>

</div>
</div>
<a id="a1c5a0728e2a2f9f95ede282966424a4a" name="a1c5a0728e2a2f9f95ede282966424a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5a0728e2a2f9f95ede282966424a4a">&#9670;&#160;</a></span>open_existing_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::open_existing_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::interprocess::mode_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code>boost::interprocess::read_write</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>temporary</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>打开现有文件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>文件名称（包含路径） </td></tr>
    <tr><td class="paramname">mode</td><td>文件访问模式，默认为读写模式（read_write） </td></tr>
    <tr><td class="paramname">temporary</td><td>是否为临时文件，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 打开成功返回true，失败返回false</dd></dl>
<p>打开一个现有文件，如果文件不存在，则返回false。与 create_or_open_file 方法不同， 该方法只会打开现有文件，而不会创建不存在的文件。 返回值通过调用 <a class="el" href="classBoostFile.html#ad56152ae9b1cea225f9e65207f7906a8" title="检查文件句柄是否有效">valid()</a> 方法来确定文件是否成功打开。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00120">120</a> 行定义.</p>

</div>
</div>
<a id="a8664402121aacfa3e8188031f950fb71" name="a8664402121aacfa3e8188031f950fb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8664402121aacfa3e8188031f950fb71">&#9670;&#160;</a></span>read_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::read_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从文件读取数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>读取数据的目标缓冲区指针 </td></tr>
    <tr><td class="paramname">numdata</td><td>要读取的数据字节数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 如果成功读取了指定数量的字节返回true，否则返回false</dd></dl>
<p>从当前文件的当前指针位置读取指定数量的数据到目标缓冲区。 该方法在Windows和Linux/Unix平台上有不同的实现：Windows使用ReadFile API， 而Linux/Unix使用read系统调用。读取成功后，文件指针会自动前移读取的字节数。 这个方法只在完全读取了请求的字节数时才会返回true，如果实际读取的字节数少于请求的 字节数（例如达到文件结尾或发生错误），则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00384">384</a> 行定义.</p>

</div>
</div>
<a id="abdc1e870483d6cb55dbcfdafaa62be9a" name="abdc1e870483d6cb55dbcfdafaa62be9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc1e870483d6cb55dbcfdafaa62be9a">&#9670;&#160;</a></span>read_file_contents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BoostFile::read_file_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>读取文件全部内容到字符串（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">filename</td><td>要读取的文件名称（包含路径） </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>输出参数，用于存储读取到的文件内容 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 读取成功返回true，失败返回false</dd></dl>
<p>该静态方法用于将指定文件的全部内容读取到一个字符串中。 内部实现是创建一个临时的 <a class="el" href="classBoostFile.html" title="boost库文件操作的封装类">BoostFile</a> 对象，以只读模式打开指定文件，获取文件大小， 调整字符串缓冲区大小，然后读取文件内容到该缓冲区。 如果文件不存在、无法打开或文件大小为0，则返回false。 这个方法提供了一个便捷的方式来读取文件内容，而无需手动管理文件的打开、读取和关闭。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00460">460</a> 行定义.</p>

</div>
</div>
<a id="a215f5139fb99cde5a5ba9bf699e000fc" name="a215f5139fb99cde5a5ba9bf699e000fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215f5139fb99cde5a5ba9bf699e000fc">&#9670;&#160;</a></span>read_file_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int BoostFile::read_file_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>从文件读取数据并返回实际读取到的字节数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>读取数据的目标缓冲区指针 </td></tr>
    <tr><td class="paramname">numdata</td><td>要读取的最大数据字节数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>int 实际读取到的字节数，可能小于请求的字节数</dd></dl>
<p>从当前文件的当前指针位置读取数据到目标缓冲区，并返回实际读取到的字节数。 这个方法与 read_file 的主要区别是返回类型和行为：read_file 返回布尔值表示是否读取了全部请求的字节， 而 read_file_length 方法返回实际读取到的字节数。当需要知道实际读取到多少数据时， 例如读取可能不完整的数据块或者需要处理文件结尾情况时，这个方法很有用。 该方法同样在Windows和Linux/Unix平台上有不同的实现。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00408">408</a> 行定义.</p>

</div>
</div>
<a id="ae0ff0290c6126f8dc31ac0b991ac5421" name="ae0ff0290c6126f8dc31ac0b991ac5421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ff0290c6126f8dc31ac0b991ac5421">&#9670;&#160;</a></span>seek_current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::seek_current </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsize</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将文件指针相对于当前位置移动 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsize</td><td>相对于当前位置的偏移量，可正可负，默认为0（保持当前位置不变） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 移动成功返回true，失败返回false</dd></dl>
<p>将当前文件的读写指针相对于当前位置移动指定的偏移量。 这是set_file_pointer方法的一个封装，直接设置了位置参数为file_current（当前位置）。 当offsize为0时，指针位置保持不变；当offsize为正数时，指针向前移动（向文件结尾方向）； 当offsize为负数时，指针向后移动（向文件开头方向）。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00284">284</a> 行定义.</p>

</div>
</div>
<a id="ae6dd971735a40b7008c18d0d9c686522" name="ae6dd971735a40b7008c18d0d9c686522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dd971735a40b7008c18d0d9c686522">&#9670;&#160;</a></span>seek_to_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::seek_to_begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsize</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将文件指针移动到文件开头 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsize</td><td>相对于文件开头的偏移量，默认为0（即文件的第一个字节） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 移动成功返回true，失败返回false</dd></dl>
<p>将当前文件的读写指针移动到文件开头加上指定的偏移量。 这是set_file_pointer方法的一个封装，直接设置了位置参数为file_begin（文件开头）。 当offsize为0时，指针将移动到文件的第一个字节；当offsize为正数时，指针将移动到文件开头往后偏移指定字节数的位置。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00268">268</a> 行定义.</p>

</div>
</div>
<a id="a35d44b29939730066ab6d69f8477a24e" name="a35d44b29939730066ab6d69f8477a24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d44b29939730066ab6d69f8477a24e">&#9670;&#160;</a></span>seek_to_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::seek_to_end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsize</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将文件指针移动到文件结尾 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsize</td><td>相对于文件结尾的偏移量，默认为0（正好在文件结尾），通常为负数以定位到文件结尾之前的位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 移动成功返回true，失败返回false</dd></dl>
<p>将当前文件的读写指针移动到文件结尾加上指定的偏移量。 这是set_file_pointer方法的一个封装，直接设置了位置参数为file_end（文件结尾）。 当offsize为0时，指针将移动到文件的最后一个字节之后，这在追加写入文件时非常有用。 当offsize为负数时，指针将移动到文件结尾往前偏移指定字节数的位置。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00300">300</a> 行定义.</p>

</div>
</div>
<a id="a250a9eba00b03eb55dc3a76a4f0f0a23" name="a250a9eba00b03eb55dc3a76a4f0f0a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250a9eba00b03eb55dc3a76a4f0f0a23">&#9670;&#160;</a></span>set_file_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::set_file_pointer </td>
          <td>(</td>
          <td class="paramtype">boost::interprocess::offset_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::interprocess::file_pos_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置文件指针位置 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">off</td><td>偏移量，相对于pos参数指定的位置 </td></tr>
    <tr><td class="paramname">pos</td><td>文件位置基准，可以是文件开头（file_begin）、当前位置（file_current）或文件结尾（file_end） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 设置成功返回true，失败返回false</dd></dl>
<p>设置当前文件的读写指针位置。pos参数指定了基准位置（文件开头、当前位置或文件结尾）， off参数指定了相对于该基准位置的偏移量。此方法直接调用boost::interprocess::ipcdetail命名空间中的 set_file_pointer函数来实现文件指针的移动。 这个方法是低级别的文件指针操作函数，通常使用seek_to_begin、seek_current或seek_to_end这样的高级别函数更方便。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00253">253</a> 行定义.</p>

</div>
</div>
<a id="a0f2a2cd0d09d6ef067d3b600c8ce863d" name="a0f2a2cd0d09d6ef067d3b600c8ce863d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2a2cd0d09d6ef067d3b600c8ce863d">&#9670;&#160;</a></span>truncate_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::truncate_file </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>截断文件到指定大小 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>文件要截断到的大小（字节数） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 截断成功返回true，失败返回false</dd></dl>
<p>将当前打开的文件截断到指定的大小。如果指定大小小于当前文件大小， 则文件将被裁剪；如果指定大小大于当前文件大小，则文件将被扩展，新增的部分用零填充。 当size为0时，文件将被清空。这个方法在create_new_file中被调用，以确保新创建的文件是空的。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00181">181</a> 行定义.</p>

</div>
</div>
<a id="ad56152ae9b1cea225f9e65207f7906a8" name="ad56152ae9b1cea225f9e65207f7906a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56152ae9b1cea225f9e65207f7906a8">&#9670;&#160;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查文件句柄是否有效 </p>
<dl class="section return"><dt>返回</dt><dd>bool 文件句柄有效返回true，无效返回false</dd></dl>
<p>检查当前文件句柄是否有效。这个方法是 <a class="el" href="classBoostFile.html#a3a95d92d05f738947b61d7a416c92654" title="检查文件句柄是否无效">is_invalid_file()</a> 的反向方法， 用于判断文件是否已经打开或创建成功。当文件打开成功时返回true，否则返回false。 内部实现是将当前文件句柄与Boost库中定义的无效文件句柄进行比较。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00148">148</a> 行定义.</p>

</div>
</div>
<a id="a1543235872c0d2c9b0df16335c1e356d" name="a1543235872c0d2c9b0df16335c1e356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1543235872c0d2c9b0df16335c1e356d">&#9670;&#160;</a></span>write_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::write_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>写入字符串数据到文件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>要写入的字符串数据 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 写入成功返回true，失败返回false</dd></dl>
<p>将指定的字符串数据写入到当前文件中的当前文件指针位置。 这是一个重载write_file方法，提供了一个更便捷的方式来写入std::string类型的数据。 内部实现通过调用boost::interprocess::ipcdetail::write_file函数，传入字符串的内部数据指针和大小来实现。 如同基本版本的write_file方法，写入成功后文件指针会自动前移写入的字节数。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00366">366</a> 行定义.</p>

</div>
</div>
<a id="aca29c4c4ed11acc16411e3fcc986f6e3" name="aca29c4c4ed11acc16411e3fcc986f6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca29c4c4ed11acc16411e3fcc986f6e3">&#9670;&#160;</a></span>write_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BoostFile::write_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>numdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>写入数据到文件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>要写入的数据的指针 </td></tr>
    <tr><td class="paramname">numdata</td><td>要写入的数据字节数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 写入成功返回true，失败返回false</dd></dl>
<p>将指定的数据写入到当前文件中的当前文件指针位置。 写入成功后，文件指针会自动前移写入的字节数。 这个方法使用boost::interprocess::ipcdetail命名空间中的write_file函数来实现文件写入操作。 如果文件句柄无效或写入过程中发生错误，则返回false。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00350">350</a> 行定义.</p>

</div>
</div>
<a id="ae9e78b2445ae39b733883796bdde9225" name="ae9e78b2445ae39b733883796bdde9225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e78b2445ae39b733883796bdde9225">&#9670;&#160;</a></span>write_file_contents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool BoostFile::write_file_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> void *&#160;</td>
          <td class="paramname"><em>pdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>datalen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>写入数据到文件（静态方法） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>目标文件名称（包含路径） </td></tr>
    <tr><td class="paramname">pdata</td><td>要写入的数据的指针 </td></tr>
    <tr><td class="paramname">datalen</td><td>要写入的数据字节数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 写入成功返回true，失败返回false</dd></dl>
<p>该静态方法用于将指定数据写入到文件中。 内部实现是创建一个临时的 <a class="el" href="classBoostFile.html" title="boost库文件操作的封装类">BoostFile</a> 对象，创建一个新文件（如果文件已存在，则会被截断为空）， 然后将指定的数据写入到该文件中。 如果文件无法创建（例如由于权限问题或文件已被锁定）或写入操作失败，则返回false。 这个方法提供了一个便捷的方式来写入数据到文件，而无需手动管理文件的创建、写入和关闭。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00486">486</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="adc4459bbb8b27072ff1be0a4e8308f09" name="adc4459bbb8b27072ff1be0a4e8308f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4459bbb8b27072ff1be0a4e8308f09">&#9670;&#160;</a></span>_handle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::interprocess::file_handle_t BoostFile::_handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>文件句柄 </p>
<p>存储当前打开文件的文件句柄，这是一个由Boost.Interprocess库提供的平台无关的文件句柄类型。 在Windows上，它是一个HANDLE；在POSIX系统上，它是一个文件描述符（int）。 该句柄由各种文件操作方法使用，如读、写、定位等。 当文件关闭时，该句柄将被设置为无效值。 </p>

<p class="definition">在文件 <a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a> 第 <a class="el" href="BoostFile_8hpp_source.html#l00428">428</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/Share/<a class="el" href="BoostFile_8hpp_source.html">BoostFile.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classBoostFile.html">BoostFile</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
