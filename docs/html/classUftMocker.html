<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WonderTrader: UftMocker类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WonderTrader<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">高性能量化交易平台</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classUftMocker.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pri-types">Private 类型</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="classUftMocker-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">UftMocker类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>UFT策略回测模拟器类  
 <a href="classUftMocker.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="UftMocker_8h_source.html">UftMocker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUftMocker_1_1__DetailInfo.html">_DetailInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易明细信息结构体  <a href="structUftMocker_1_1__DetailInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUftMocker_1_1__OrderInfo.html">_OrderInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单信息结构体  <a href="structUftMocker_1_1__OrderInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUftMocker_1_1__PosInfo.html">_PosInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">合约持仓信息结构体  <a href="structUftMocker_1_1__PosInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUftMocker_1_1__PosItem.html">_PosItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓项目结构体  <a href="structUftMocker_1_1__PosItem.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUftMocker_1_1__StraFactInfo.html">_StraFactInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息结构体  <a href="structUftMocker_1_1__StraFactInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUftMocker_1_1__StraFundInfo.html">_StraFundInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息结构体  <a href="structUftMocker_1_1__StraFundInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a464b7eb82180d1aae010361fa925b579" id="r_a464b7eb82180d1aae010361fa925b579"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a464b7eb82180d1aae010361fa925b579">UftMocker</a> (<a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *replayer, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>)</td></tr>
<tr class="memdesc:a464b7eb82180d1aae010361fa925b579"><td class="mdescLeft">&#160;</td><td class="mdescRight">UFT策略回测模拟器构造函数  <br /></td></tr>
<tr class="separator:a464b7eb82180d1aae010361fa925b579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaad164f6540f0a98a69ed3e3a1d36a2" id="r_adaad164f6540f0a98a69ed3e3a1d36a2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#adaad164f6540f0a98a69ed3e3a1d36a2">~UftMocker</a> ()</td></tr>
<tr class="memdesc:adaad164f6540f0a98a69ed3e3a1d36a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UFT策略回测模拟器析构函数  <br /></td></tr>
<tr class="separator:adaad164f6540f0a98a69ed3e3a1d36a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69fde97b863030a99ba736f46dd64a1" id="r_ab69fde97b863030a99ba736f46dd64a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ab69fde97b863030a99ba736f46dd64a1">handle_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *curTick, uint32_t pxType) override</td></tr>
<tr class="memdesc:ab69fde97b863030a99ba736f46dd64a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理Tick数据  <br /></td></tr>
<tr class="separator:ab69fde97b863030a99ba736f46dd64a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44413fc9146e581a4ffafa1c6195613b" id="r_a44413fc9146e581a4ffafa1c6195613b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a44413fc9146e581a4ffafa1c6195613b">handle_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *curOrdQue) override</td></tr>
<tr class="memdesc:a44413fc9146e581a4ffafa1c6195613b"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理委托队列数据  <br /></td></tr>
<tr class="separator:a44413fc9146e581a4ffafa1c6195613b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e899a1ed9ac09ce26a11c90cbb5cb1" id="r_a72e899a1ed9ac09ce26a11c90cbb5cb1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a72e899a1ed9ac09ce26a11c90cbb5cb1">handle_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *curOrdDtl) override</td></tr>
<tr class="memdesc:a72e899a1ed9ac09ce26a11c90cbb5cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理委托明细数据  <br /></td></tr>
<tr class="separator:a72e899a1ed9ac09ce26a11c90cbb5cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae091f6c4053a526d76df2a9bac52b1b5" id="r_ae091f6c4053a526d76df2a9bac52b1b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae091f6c4053a526d76df2a9bac52b1b5">handle_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *curTrans) override</td></tr>
<tr class="memdesc:ae091f6c4053a526d76df2a9bac52b1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理逐笔成交数据  <br /></td></tr>
<tr class="separator:ae091f6c4053a526d76df2a9bac52b1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671e6ebc483bcead9afdc9ba5252ff61" id="r_a671e6ebc483bcead9afdc9ba5252ff61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a671e6ebc483bcead9afdc9ba5252ff61">handle_bar_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t times, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:a671e6ebc483bcead9afdc9ba5252ff61"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理K线闭合事件  <br /></td></tr>
<tr class="separator:a671e6ebc483bcead9afdc9ba5252ff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80404593eb7d4a14500cd4e3a13458c8" id="r_a80404593eb7d4a14500cd4e3a13458c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a80404593eb7d4a14500cd4e3a13458c8">handle_schedule</a> (uint32_t uDate, uint32_t uTime) override</td></tr>
<tr class="memdesc:a80404593eb7d4a14500cd4e3a13458c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理定时事件  <br /></td></tr>
<tr class="separator:a80404593eb7d4a14500cd4e3a13458c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb6c21fa2f765e719b0344b54833d15" id="r_a2eb6c21fa2f765e719b0344b54833d15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a2eb6c21fa2f765e719b0344b54833d15">handle_init</a> () override</td></tr>
<tr class="memdesc:a2eb6c21fa2f765e719b0344b54833d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理初始化事件  <br /></td></tr>
<tr class="separator:a2eb6c21fa2f765e719b0344b54833d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc7f2fe277c08e0f82a8f857430148d" id="r_abdc7f2fe277c08e0f82a8f857430148d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#abdc7f2fe277c08e0f82a8f857430148d">handle_session_begin</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:abdc7f2fe277c08e0f82a8f857430148d"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易日开始事件  <br /></td></tr>
<tr class="separator:abdc7f2fe277c08e0f82a8f857430148d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dae33dafe0108c778f8f0939dd22e5" id="r_aa4dae33dafe0108c778f8f0939dd22e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aa4dae33dafe0108c778f8f0939dd22e5">handle_session_end</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:aa4dae33dafe0108c778f8f0939dd22e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易日结束事件  <br /></td></tr>
<tr class="separator:aa4dae33dafe0108c778f8f0939dd22e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bcaf32225f45c8553d9a992caf3c82" id="r_a96bcaf32225f45c8553d9a992caf3c82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a96bcaf32225f45c8553d9a992caf3c82">handle_replay_done</a> () override</td></tr>
<tr class="memdesc:a96bcaf32225f45c8553d9a992caf3c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理回放完成事件  <br /></td></tr>
<tr class="separator:a96bcaf32225f45c8553d9a992caf3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3cc7b1b3141a71be1e197c6dfe7bc6" id="r_acc3cc7b1b3141a71be1e197c6dfe7bc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#acc3cc7b1b3141a71be1e197c6dfe7bc6">on_tick_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick) override</td></tr>
<tr class="memdesc:acc3cc7b1b3141a71be1e197c6dfe7bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">当Tick数据更新时的回调  <br /></td></tr>
<tr class="separator:acc3cc7b1b3141a71be1e197c6dfe7bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3921b1fe9e74af9aead5161065316e" id="r_a8b3921b1fe9e74af9aead5161065316e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a8b3921b1fe9e74af9aead5161065316e">on_ordque_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *newOrdQue) override</td></tr>
<tr class="memdesc:a8b3921b1fe9e74af9aead5161065316e"><td class="mdescLeft">&#160;</td><td class="mdescRight">当委托队列数据更新时的回调  <br /></td></tr>
<tr class="separator:a8b3921b1fe9e74af9aead5161065316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a11453469b65ee280d68d5f61ae3f37" id="r_a3a11453469b65ee280d68d5f61ae3f37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a3a11453469b65ee280d68d5f61ae3f37">on_orddtl_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *newOrdDtl) override</td></tr>
<tr class="memdesc:a3a11453469b65ee280d68d5f61ae3f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">当委托明细数据更新时的回调  <br /></td></tr>
<tr class="separator:a3a11453469b65ee280d68d5f61ae3f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c61fb0db4b2645df23b85025fada9a7" id="r_a5c61fb0db4b2645df23b85025fada9a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a5c61fb0db4b2645df23b85025fada9a7">on_trans_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *newTrans) override</td></tr>
<tr class="memdesc:a5c61fb0db4b2645df23b85025fada9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">当逐笔成交数据更新时的回调  <br /></td></tr>
<tr class="separator:a5c61fb0db4b2645df23b85025fada9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83dda60dfa0874931852c13362eec54" id="r_ac83dda60dfa0874931852c13362eec54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ac83dda60dfa0874931852c13362eec54">on_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick) override</td></tr>
<tr class="memdesc:ac83dda60dfa0874931852c13362eec54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick数据回调  <br /></td></tr>
<tr class="separator:ac83dda60dfa0874931852c13362eec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd43e347f7143ea260a63a2650c9884" id="r_a7bd43e347f7143ea260a63a2650c9884"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a7bd43e347f7143ea260a63a2650c9884">on_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *newOrdQue) override</td></tr>
<tr class="memdesc:a7bd43e347f7143ea260a63a2650c9884"><td class="mdescLeft">&#160;</td><td class="mdescRight">委托队列数据回调  <br /></td></tr>
<tr class="separator:a7bd43e347f7143ea260a63a2650c9884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55646aca3a8637d8cbb31087077af2f0" id="r_a55646aca3a8637d8cbb31087077af2f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a55646aca3a8637d8cbb31087077af2f0">on_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *newOrdDtl) override</td></tr>
<tr class="memdesc:a55646aca3a8637d8cbb31087077af2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">委托明细数据回调  <br /></td></tr>
<tr class="separator:a55646aca3a8637d8cbb31087077af2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86556731170989deaf8223afc3f59b0" id="r_ab86556731170989deaf8223afc3f59b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ab86556731170989deaf8223afc3f59b0">on_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *newTrans) override</td></tr>
<tr class="memdesc:ab86556731170989deaf8223afc3f59b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">逐笔成交数据回调  <br /></td></tr>
<tr class="separator:ab86556731170989deaf8223afc3f59b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3853101bf75b4cdd0f81b7d5a9608c" id="r_abb3853101bf75b4cdd0f81b7d5a9608c"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#abb3853101bf75b4cdd0f81b7d5a9608c">id</a> () override</td></tr>
<tr class="memdesc:abb3853101bf75b4cdd0f81b7d5a9608c"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取策略ID  <br /></td></tr>
<tr class="separator:abb3853101bf75b4cdd0f81b7d5a9608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab1bbb74eaf6ecf0e493517078e1a1" id="r_ae9ab1bbb74eaf6ecf0e493517078e1a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae9ab1bbb74eaf6ecf0e493517078e1a1">on_init</a> () override</td></tr>
<tr class="memdesc:ae9ab1bbb74eaf6ecf0e493517078e1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略初始化回调  <br /></td></tr>
<tr class="separator:ae9ab1bbb74eaf6ecf0e493517078e1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6db7dabeb1297eae8787929c05b60a" id="r_a1c6db7dabeb1297eae8787929c05b60a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a1c6db7dabeb1297eae8787929c05b60a">on_bar</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t times, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:a1c6db7dabeb1297eae8787929c05b60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线数据回调  <br /></td></tr>
<tr class="separator:a1c6db7dabeb1297eae8787929c05b60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9576a3a77dd3cefde8ddcba3e941f4a6" id="r_a9576a3a77dd3cefde8ddcba3e941f4a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a9576a3a77dd3cefde8ddcba3e941f4a6">on_session_begin</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:a9576a3a77dd3cefde8ddcba3e941f4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日开始回调  <br /></td></tr>
<tr class="separator:a9576a3a77dd3cefde8ddcba3e941f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3147ad051ffc059fc356c2c8221ae30" id="r_ad3147ad051ffc059fc356c2c8221ae30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ad3147ad051ffc059fc356c2c8221ae30">on_session_end</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:ad3147ad051ffc059fc356c2c8221ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日结束回调  <br /></td></tr>
<tr class="separator:ad3147ad051ffc059fc356c2c8221ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b14656f5386b6213a6661cdfeba631a" id="r_a0b14656f5386b6213a6661cdfeba631a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a0b14656f5386b6213a6661cdfeba631a">stra_cancel</a> (uint32_t localid) override</td></tr>
<tr class="memdesc:a0b14656f5386b6213a6661cdfeba631a"><td class="mdescLeft">&#160;</td><td class="mdescRight">撤销订单  <br /></td></tr>
<tr class="separator:a0b14656f5386b6213a6661cdfeba631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15f8fa21f867d8ad1e8af76ca9e81a3" id="r_aa15f8fa21f867d8ad1e8af76ca9e81a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aa15f8fa21f867d8ad1e8af76ca9e81a3">stra_cancel_all</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:aa15f8fa21f867d8ad1e8af76ca9e81a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">撤销指定合约的所有活跃订单  <br /></td></tr>
<tr class="separator:aa15f8fa21f867d8ad1e8af76ca9e81a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1509a8885e226a573b53a9d59cd3f1" id="r_a9e1509a8885e226a573b53a9d59cd3f1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a9e1509a8885e226a573b53a9d59cd3f1">stra_buy</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, int flag=0) override</td></tr>
<tr class="memdesc:a9e1509a8885e226a573b53a9d59cd3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">买入交易  <br /></td></tr>
<tr class="separator:a9e1509a8885e226a573b53a9d59cd3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed7220165228852ce704691a3fca182" id="r_afed7220165228852ce704691a3fca182"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#afed7220165228852ce704691a3fca182">stra_sell</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, int flag=0) override</td></tr>
<tr class="memdesc:afed7220165228852ce704691a3fca182"><td class="mdescLeft">&#160;</td><td class="mdescRight">卖出交易  <br /></td></tr>
<tr class="separator:afed7220165228852ce704691a3fca182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8002fb17cc11e7bb3ec4cb467a34f150" id="r_a8002fb17cc11e7bb3ec4cb467a34f150"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a8002fb17cc11e7bb3ec4cb467a34f150">stra_enter_long</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, int flag=0) override</td></tr>
<tr class="memdesc:a8002fb17cc11e7bb3ec4cb467a34f150"><td class="mdescLeft">&#160;</td><td class="mdescRight">开多仓交易  <br /></td></tr>
<tr class="separator:a8002fb17cc11e7bb3ec4cb467a34f150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755aba192acae21e4ec196fcdd2c4b4" id="r_af755aba192acae21e4ec196fcdd2c4b4"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#af755aba192acae21e4ec196fcdd2c4b4">stra_enter_short</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, int flag=0) override</td></tr>
<tr class="memdesc:af755aba192acae21e4ec196fcdd2c4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">开空仓交易  <br /></td></tr>
<tr class="separator:af755aba192acae21e4ec196fcdd2c4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dfc265a143669b643a83132aeb329b" id="r_a03dfc265a143669b643a83132aeb329b"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a03dfc265a143669b643a83132aeb329b">stra_exit_long</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, bool isToday=false, int flag=0) override</td></tr>
<tr class="memdesc:a03dfc265a143669b643a83132aeb329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">平多仓交易  <br /></td></tr>
<tr class="separator:a03dfc265a143669b643a83132aeb329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371afcdbcc32aa313051398f10069ae1" id="r_a371afcdbcc32aa313051398f10069ae1"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a371afcdbcc32aa313051398f10069ae1">stra_exit_short</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, bool isToday=false, int flag=0) override</td></tr>
<tr class="memdesc:a371afcdbcc32aa313051398f10069ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">平空仓交易  <br /></td></tr>
<tr class="separator:a371afcdbcc32aa313051398f10069ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e1c75a11fa4ccba9640d7d4b350f80" id="r_a05e1c75a11fa4ccba9640d7d4b350f80"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSCommodityInfo.html">WTSCommodityInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a05e1c75a11fa4ccba9640d7d4b350f80">stra_get_comminfo</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a05e1c75a11fa4ccba9640d7d4b350f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约基础信息  <br /></td></tr>
<tr class="separator:a05e1c75a11fa4ccba9640d7d4b350f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa8d6e9b8f35c00cfdec015c8326802" id="r_a2aa8d6e9b8f35c00cfdec015c8326802"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSKlineSlice.html">WTSKlineSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a2aa8d6e9b8f35c00cfdec015c8326802">stra_get_bars</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t count) override</td></tr>
<tr class="memdesc:a2aa8d6e9b8f35c00cfdec015c8326802"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取K线切片数据  <br /></td></tr>
<tr class="separator:a2aa8d6e9b8f35c00cfdec015c8326802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406c47b169ea834f36f18edaa4171270" id="r_a406c47b169ea834f36f18edaa4171270"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTickSlice.html">WTSTickSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a406c47b169ea834f36f18edaa4171270">stra_get_ticks</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:a406c47b169ea834f36f18edaa4171270"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取Tick切片数据  <br /></td></tr>
<tr class="separator:a406c47b169ea834f36f18edaa4171270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a8a2153ca7534ca8a8d39c87c9045" id="r_a7c3a8a2153ca7534ca8a8d39c87c9045"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSOrdDtlSlice.html">WTSOrdDtlSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a7c3a8a2153ca7534ca8a8d39c87c9045">stra_get_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:a7c3a8a2153ca7534ca8a8d39c87c9045"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取委托明细切片数据  <br /></td></tr>
<tr class="separator:a7c3a8a2153ca7534ca8a8d39c87c9045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27db324d73c9177e7f5df2b5e8e63b82" id="r_a27db324d73c9177e7f5df2b5e8e63b82"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSOrdQueSlice.html">WTSOrdQueSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a27db324d73c9177e7f5df2b5e8e63b82">stra_get_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:a27db324d73c9177e7f5df2b5e8e63b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取委托队列切片数据  <br /></td></tr>
<tr class="separator:a27db324d73c9177e7f5df2b5e8e63b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696f7b3357c99ad6fed6cbb2711e6d8d" id="r_a696f7b3357c99ad6fed6cbb2711e6d8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTransSlice.html">WTSTransSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a696f7b3357c99ad6fed6cbb2711e6d8d">stra_get_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:a696f7b3357c99ad6fed6cbb2711e6d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取逐笔成交切片数据  <br /></td></tr>
<tr class="separator:a696f7b3357c99ad6fed6cbb2711e6d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c7e021d7fac27b4cd076dcaa9a1dc3" id="r_ae6c7e021d7fac27b4cd076dcaa9a1dc3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae6c7e021d7fac27b4cd076dcaa9a1dc3">stra_get_last_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:ae6c7e021d7fac27b4cd076dcaa9a1dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最新Tick数据  <br /></td></tr>
<tr class="separator:ae6c7e021d7fac27b4cd076dcaa9a1dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14be14492ee692c7c7fbcdc91c17e98" id="r_af14be14492ee692c7c7fbcdc91c17e98"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#af14be14492ee692c7c7fbcdc91c17e98">stra_get_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool bOnlyValid=false, int32_t iFlag=3) override</td></tr>
<tr class="memdesc:af14be14492ee692c7c7fbcdc91c17e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取指定合约的持仓量  <br /></td></tr>
<tr class="separator:af14be14492ee692c7c7fbcdc91c17e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d68634eec841482af2b7cfa657f57" id="r_a567d68634eec841482af2b7cfa657f57"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a567d68634eec841482af2b7cfa657f57">stra_get_local_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a567d68634eec841482af2b7cfa657f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取本地持仓量  <br /></td></tr>
<tr class="separator:a567d68634eec841482af2b7cfa657f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ef443692088bb95f18b53fd1ae3016" id="r_a57ef443692088bb95f18b53fd1ae3016"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a57ef443692088bb95f18b53fd1ae3016">stra_enum_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a57ef443692088bb95f18b53fd1ae3016"><td class="mdescLeft">&#160;</td><td class="mdescRight">枚举指定合约的持仓  <br /></td></tr>
<tr class="separator:a57ef443692088bb95f18b53fd1ae3016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cc5f82941a13e61dbdd8cd10ae157b" id="r_ae8cc5f82941a13e61dbdd8cd10ae157b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae8cc5f82941a13e61dbdd8cd10ae157b">stra_get_undone</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:ae8cc5f82941a13e61dbdd8cd10ae157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取未完成委托数量  <br /></td></tr>
<tr class="separator:ae8cc5f82941a13e61dbdd8cd10ae157b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e737ba6a3d46a5bb42cf911c0ebfadf" id="r_a2e737ba6a3d46a5bb42cf911c0ebfadf"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a2e737ba6a3d46a5bb42cf911c0ebfadf">stra_get_price</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a2e737ba6a3d46a5bb42cf911c0ebfadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约当前价格  <br /></td></tr>
<tr class="separator:a2e737ba6a3d46a5bb42cf911c0ebfadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10b6149214e4a56619655a636c3bc7b" id="r_ae10b6149214e4a56619655a636c3bc7b"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae10b6149214e4a56619655a636c3bc7b">stra_get_date</a> () override</td></tr>
<tr class="memdesc:ae10b6149214e4a56619655a636c3bc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前交易日期  <br /></td></tr>
<tr class="separator:ae10b6149214e4a56619655a636c3bc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0ee20334abc39f251cbccbfd2b6aac" id="r_add0ee20334abc39f251cbccbfd2b6aac"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#add0ee20334abc39f251cbccbfd2b6aac">stra_get_time</a> () override</td></tr>
<tr class="memdesc:add0ee20334abc39f251cbccbfd2b6aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前交易时间  <br /></td></tr>
<tr class="separator:add0ee20334abc39f251cbccbfd2b6aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d10bb6a3cc8a5da4c00a973e2161c2" id="r_a96d10bb6a3cc8a5da4c00a973e2161c2"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a96d10bb6a3cc8a5da4c00a973e2161c2">stra_get_secs</a> () override</td></tr>
<tr class="memdesc:a96d10bb6a3cc8a5da4c00a973e2161c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前时间秒数  <br /></td></tr>
<tr class="separator:a96d10bb6a3cc8a5da4c00a973e2161c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83b6c6a8b142b7cb254da2e56c627c0" id="r_aa83b6c6a8b142b7cb254da2e56c627c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aa83b6c6a8b142b7cb254da2e56c627c0">stra_sub_ticks</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:aa83b6c6a8b142b7cb254da2e56c627c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅Tick数据  <br /></td></tr>
<tr class="separator:aa83b6c6a8b142b7cb254da2e56c627c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47540e87d498b01a28fb0e880eaf53b6" id="r_a47540e87d498b01a28fb0e880eaf53b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a47540e87d498b01a28fb0e880eaf53b6">stra_sub_order_queues</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a47540e87d498b01a28fb0e880eaf53b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅委托队列数据  <br /></td></tr>
<tr class="separator:a47540e87d498b01a28fb0e880eaf53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b3c998cb22f277ef18d08f3f3d0e4" id="r_a5c0b3c998cb22f277ef18d08f3f3d0e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a5c0b3c998cb22f277ef18d08f3f3d0e4">stra_sub_order_details</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a5c0b3c998cb22f277ef18d08f3f3d0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅委托明细数据  <br /></td></tr>
<tr class="separator:a5c0b3c998cb22f277ef18d08f3f3d0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b33e622a3294496f2224542f172b3b" id="r_aa1b33e622a3294496f2224542f172b3b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aa1b33e622a3294496f2224542f172b3b">stra_sub_transactions</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:aa1b33e622a3294496f2224542f172b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅逐笔成交数据  <br /></td></tr>
<tr class="separator:aa1b33e622a3294496f2224542f172b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b1dd38e16c329f753ef7e8ba0f42ba" id="r_a25b1dd38e16c329f753ef7e8ba0f42ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a25b1dd38e16c329f753ef7e8ba0f42ba">stra_log_info</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:a25b1dd38e16c329f753ef7e8ba0f42ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出信息级别日志  <br /></td></tr>
<tr class="separator:a25b1dd38e16c329f753ef7e8ba0f42ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd9fd8db52f99fb492ddc437af5e447" id="r_a9cd9fd8db52f99fb492ddc437af5e447"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a9cd9fd8db52f99fb492ddc437af5e447">stra_log_debug</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:a9cd9fd8db52f99fb492ddc437af5e447"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出调试级别日志  <br /></td></tr>
<tr class="separator:a9cd9fd8db52f99fb492ddc437af5e447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5925a1b644093bb852704ee1cec5a5" id="r_aae5925a1b644093bb852704ee1cec5a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aae5925a1b644093bb852704ee1cec5a5">stra_log_error</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:aae5925a1b644093bb852704ee1cec5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出错误级别日志  <br /></td></tr>
<tr class="separator:aae5925a1b644093bb852704ee1cec5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95fedcd2a528aa0e54b4865220553f" id="r_adf95fedcd2a528aa0e54b4865220553f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#adf95fedcd2a528aa0e54b4865220553f">on_trade</a> (uint32_t localid, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint32_t offset, double vol, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>)</td></tr>
<tr class="memdesc:adf95fedcd2a528aa0e54b4865220553f"><td class="mdescLeft">&#160;</td><td class="mdescRight">成交回调  <br /></td></tr>
<tr class="separator:adf95fedcd2a528aa0e54b4865220553f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305c7de64825fb5f5644709931768025" id="r_a305c7de64825fb5f5644709931768025"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a305c7de64825fb5f5644709931768025">on_order</a> (uint32_t localid, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint32_t offset, double totalQty, double leftQty, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, bool isCanceled)</td></tr>
<tr class="memdesc:a305c7de64825fb5f5644709931768025"><td class="mdescLeft">&#160;</td><td class="mdescRight">委托状态回调  <br /></td></tr>
<tr class="separator:a305c7de64825fb5f5644709931768025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab672033c90dc3bc142c2037b5ab7c4" id="r_aaab672033c90dc3bc142c2037b5ab7c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aaab672033c90dc3bc142c2037b5ab7c4">on_channel_ready</a> ()</td></tr>
<tr class="memdesc:aaab672033c90dc3bc142c2037b5ab7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">通道就绪回调  <br /></td></tr>
<tr class="separator:aaab672033c90dc3bc142c2037b5ab7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af674be55e62dc791cfb68ba36335d6de" id="r_af674be55e62dc791cfb68ba36335d6de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#af674be55e62dc791cfb68ba36335d6de">on_entrust</a> (uint32_t localid, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool bSuccess, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message)</td></tr>
<tr class="memdesc:af674be55e62dc791cfb68ba36335d6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">委托结果回调  <br /></td></tr>
<tr class="separator:af674be55e62dc791cfb68ba36335d6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad988622a5baae466097e196432f2d7f6" id="r_ad988622a5baae466097e196432f2d7f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ad988622a5baae466097e196432f2d7f6">init_uft_factory</a> (<a class="el" href="classWTSVariant.html">WTSVariant</a> *cfg)</td></tr>
<tr class="memdesc:ad988622a5baae466097e196432f2d7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化UFT策略工厂  <br /></td></tr>
<tr class="separator:ad988622a5baae466097e196432f2d7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIDataSink"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIDataSink')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classIDataSink.html">IDataSink</a></td></tr>
<tr class="memitem:a484f5ab1b9ea855ddbc56cfedf324312 inherit pub_methods_classIDataSink" id="r_a484f5ab1b9ea855ddbc56cfedf324312"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDataSink.html#a484f5ab1b9ea855ddbc56cfedf324312">handle_section_end</a> (uint32_t curTDate, uint32_t curTime)</td></tr>
<tr class="memdesc:a484f5ab1b9ea855ddbc56cfedf324312 inherit pub_methods_classIDataSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易时段结束事件  <br /></td></tr>
<tr class="separator:a484f5ab1b9ea855ddbc56cfedf324312 inherit pub_methods_classIDataSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIUftStraCtx"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIUftStraCtx')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classIUftStraCtx.html">IUftStraCtx</a></td></tr>
<tr class="memitem:a4fc0f6ffe5619afc7c25e2ee002d0701 inherit pub_methods_classIUftStraCtx" id="r_a4fc0f6ffe5619afc7c25e2ee002d0701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a4fc0f6ffe5619afc7c25e2ee002d0701">IUftStraCtx</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>)</td></tr>
<tr class="separator:a4fc0f6ffe5619afc7c25e2ee002d0701 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebeb59e5bd737ce6bbbd34a61669ff1 inherit pub_methods_classIUftStraCtx" id="r_a0ebeb59e5bd737ce6bbbd34a61669ff1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a0ebeb59e5bd737ce6bbbd34a61669ff1">~IUftStraCtx</a> ()</td></tr>
<tr class="separator:a0ebeb59e5bd737ce6bbbd34a61669ff1 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9da9551f1b0554d370e943714f2f275 inherit pub_methods_classIUftStraCtx" id="r_ad9da9551f1b0554d370e943714f2f275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a> () <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a></td></tr>
<tr class="separator:ad9da9551f1b0554d370e943714f2f275 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e56dab511dd1244b65a027fa5d1bbc inherit pub_methods_classIUftStraCtx" id="r_ad2e56dab511dd1244b65a027fa5d1bbc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#ad2e56dab511dd1244b65a027fa5d1bbc">on_params_updated</a> ()</td></tr>
<tr class="separator:ad2e56dab511dd1244b65a027fa5d1bbc inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab470dc72c32d6717788cf853eb70f6c3 inherit pub_methods_classIUftStraCtx" id="r_ab470dc72c32d6717788cf853eb70f6c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#ab470dc72c32d6717788cf853eb70f6c3">on_bactest_end</a> ()</td></tr>
<tr class="separator:ab470dc72c32d6717788cf853eb70f6c3 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca8c44c1f17ed0f9a6e4eda51804d2 inherit pub_methods_classIUftStraCtx" id="r_af0ca8c44c1f17ed0f9a6e4eda51804d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#af0ca8c44c1f17ed0f9a6e4eda51804d2">watch_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *initVal=&quot;&quot;)</td></tr>
<tr class="separator:af0ca8c44c1f17ed0f9a6e4eda51804d2 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ade663de08b6900d0a1770b7340bd5 inherit pub_methods_classIUftStraCtx" id="r_aa5ade663de08b6900d0a1770b7340bd5"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#aa5ade663de08b6900d0a1770b7340bd5">watch_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, double initVal=0)</td></tr>
<tr class="separator:aa5ade663de08b6900d0a1770b7340bd5 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbb545b1d4f49d4d67c0529c1580afd inherit pub_methods_classIUftStraCtx" id="r_a2dbb545b1d4f49d4d67c0529c1580afd"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a2dbb545b1d4f49d4d67c0529c1580afd">watch_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, uint32_t initVal=0)</td></tr>
<tr class="separator:a2dbb545b1d4f49d4d67c0529c1580afd inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dc585f9235a5a11e71657fc2afaa7f inherit pub_methods_classIUftStraCtx" id="r_af7dc585f9235a5a11e71657fc2afaa7f"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#af7dc585f9235a5a11e71657fc2afaa7f">watch_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, uint64_t initVal=0)</td></tr>
<tr class="separator:af7dc585f9235a5a11e71657fc2afaa7f inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3e65da1cb8e55270595e9fc6a39ab5 inherit pub_methods_classIUftStraCtx" id="r_afb3e65da1cb8e55270595e9fc6a39ab5"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#afb3e65da1cb8e55270595e9fc6a39ab5">watch_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, int32_t initVal=0)</td></tr>
<tr class="separator:afb3e65da1cb8e55270595e9fc6a39ab5 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcef4be1f74c9f78c59510041f5cc910 inherit pub_methods_classIUftStraCtx" id="r_afcef4be1f74c9f78c59510041f5cc910"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#afcef4be1f74c9f78c59510041f5cc910">watch_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, int64_t initVal=0)</td></tr>
<tr class="separator:afcef4be1f74c9f78c59510041f5cc910 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2843cbe19d9db2da529c25cd666790d2 inherit pub_methods_classIUftStraCtx" id="r_a2843cbe19d9db2da529c25cd666790d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a2843cbe19d9db2da529c25cd666790d2">commit_param_watcher</a> ()</td></tr>
<tr class="separator:a2843cbe19d9db2da529c25cd666790d2 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b0c46274956eaf072eb8ab6e5d1e7a inherit pub_methods_classIUftStraCtx" id="r_a50b0c46274956eaf072eb8ab6e5d1e7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a50b0c46274956eaf072eb8ab6e5d1e7a">read_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *defVal=&quot;&quot;)</td></tr>
<tr class="separator:a50b0c46274956eaf072eb8ab6e5d1e7a inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7465752fa6a553808f5de5f3e727ae inherit pub_methods_classIUftStraCtx" id="r_a3e7465752fa6a553808f5de5f3e727ae"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a3e7465752fa6a553808f5de5f3e727ae">read_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, double defVal=0)</td></tr>
<tr class="separator:a3e7465752fa6a553808f5de5f3e727ae inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6754be7a7f0a465b545f1645ebd488 inherit pub_methods_classIUftStraCtx" id="r_a7a6754be7a7f0a465b545f1645ebd488"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a7a6754be7a7f0a465b545f1645ebd488">read_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, uint32_t defVal=0)</td></tr>
<tr class="separator:a7a6754be7a7f0a465b545f1645ebd488 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef2e4589a86f542f3d34f7bb64556e9 inherit pub_methods_classIUftStraCtx" id="r_a6ef2e4589a86f542f3d34f7bb64556e9"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a6ef2e4589a86f542f3d34f7bb64556e9">read_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, uint64_t defVal=0)</td></tr>
<tr class="separator:a6ef2e4589a86f542f3d34f7bb64556e9 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517118455640001420c02dd9c66c1f81 inherit pub_methods_classIUftStraCtx" id="r_a517118455640001420c02dd9c66c1f81"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a517118455640001420c02dd9c66c1f81">read_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, int32_t defVal=0)</td></tr>
<tr class="separator:a517118455640001420c02dd9c66c1f81 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcceca40447c9d8388ed29cf577160a inherit pub_methods_classIUftStraCtx" id="r_abbcceca40447c9d8388ed29cf577160a"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#abbcceca40447c9d8388ed29cf577160a">read_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, int64_t defVal=0)</td></tr>
<tr class="separator:abbcceca40447c9d8388ed29cf577160a inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289d2daab9209c3d62d3c6414ce68bd3 inherit pub_methods_classIUftStraCtx" id="r_a289d2daab9209c3d62d3c6414ce68bd3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a289d2daab9209c3d62d3c6414ce68bd3">sync_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *initVal=&quot;&quot;, bool bForceWrite=false)</td></tr>
<tr class="separator:a289d2daab9209c3d62d3c6414ce68bd3 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04082e69097cf0f3c5940ced0fc9920a inherit pub_methods_classIUftStraCtx" id="r_a04082e69097cf0f3c5940ced0fc9920a"><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a04082e69097cf0f3c5940ced0fc9920a">sync_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, double initVal=0, bool bForceWrite=false)</td></tr>
<tr class="separator:a04082e69097cf0f3c5940ced0fc9920a inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3897f5db8d68aeb8a221bf3873192059 inherit pub_methods_classIUftStraCtx" id="r_a3897f5db8d68aeb8a221bf3873192059"><td class="memItemLeft" align="right" valign="top">virtual uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a3897f5db8d68aeb8a221bf3873192059">sync_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, uint32_t initVal=0, bool bForceWrite=false)</td></tr>
<tr class="separator:a3897f5db8d68aeb8a221bf3873192059 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa174206ec867a06e60671578bf031d61 inherit pub_methods_classIUftStraCtx" id="r_aa174206ec867a06e60671578bf031d61"><td class="memItemLeft" align="right" valign="top">virtual uint64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#aa174206ec867a06e60671578bf031d61">sync_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, uint64_t initVal=0, bool bForceWrite=false)</td></tr>
<tr class="separator:aa174206ec867a06e60671578bf031d61 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108164b78ac737595d747b967d54e6af inherit pub_methods_classIUftStraCtx" id="r_a108164b78ac737595d747b967d54e6af"><td class="memItemLeft" align="right" valign="top">virtual int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a108164b78ac737595d747b967d54e6af">sync_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, int32_t initVal=0, bool bForceWrite=false)</td></tr>
<tr class="separator:a108164b78ac737595d747b967d54e6af inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9713af77de3d7b7f8594527da4532c73 inherit pub_methods_classIUftStraCtx" id="r_a9713af77de3d7b7f8594527da4532c73"><td class="memItemLeft" align="right" valign="top">virtual int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a9713af77de3d7b7f8594527da4532c73">sync_param</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIUftStraCtx.html#ad9da9551f1b0554d370e943714f2f275">name</a>, int64_t initVal=0, bool bForceWrite=false)</td></tr>
<tr class="separator:a9713af77de3d7b7f8594527da4532c73 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace88caf55181f2a51ae2f4ca14f4bbd0 inherit pub_methods_classIUftStraCtx" id="r_ace88caf55181f2a51ae2f4ca14f4bbd0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#ace88caf55181f2a51ae2f4ca14f4bbd0">stra_get_local_posprofit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode)</td></tr>
<tr class="separator:ace88caf55181f2a51ae2f4ca14f4bbd0 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaeab46362b3cc94bb7ce571efcfaf38 inherit pub_methods_classIUftStraCtx" id="r_adaeab46362b3cc94bb7ce571efcfaf38"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#adaeab46362b3cc94bb7ce571efcfaf38">stra_get_local_closeprofit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode)</td></tr>
<tr class="separator:adaeab46362b3cc94bb7ce571efcfaf38 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150034e1c10963b030cbecaefd55b70 inherit pub_methods_classIUftStraCtx" id="r_a1150034e1c10963b030cbecaefd55b70"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a1150034e1c10963b030cbecaefd55b70">stra_get_infos</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode)</td></tr>
<tr class="separator:a1150034e1c10963b030cbecaefd55b70 inherit pub_methods_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:a7509f9633ab5f7e986ec7ffba3ccebc3" id="r_a7509f9633ab5f7e986ec7ffba3ccebc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a7509f9633ab5f7e986ec7ffba3ccebc3">_context_id</a></td></tr>
<tr class="separator:a7509f9633ab5f7e986ec7ffba3ccebc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2392a6d5b1ce2fe3b14f9c8f10668c87" id="r_a2392a6d5b1ce2fe3b14f9c8f10668c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwt__hashset.html">wt_hashset</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a2392a6d5b1ce2fe3b14f9c8f10668c87">_tick_subs</a></td></tr>
<tr class="separator:a2392a6d5b1ce2fe3b14f9c8f10668c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classIUftStraCtx"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classIUftStraCtx')"><img src="closed.png" alt="-"/>&#160;Protected 属性 继承自 <a class="el" href="classIUftStraCtx.html">IUftStraCtx</a></td></tr>
<tr class="memitem:a3d6d72eef9a27c5324d6339491cdb664 inherit pro_attribs_classIUftStraCtx" id="r_a3d6d72eef9a27c5324d6339491cdb664"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIUftStraCtx.html#a3d6d72eef9a27c5324d6339491cdb664">_name</a></td></tr>
<tr class="separator:a3d6d72eef9a27c5324d6339491cdb664 inherit pro_attribs_classIUftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private 类型</h2></td></tr>
<tr class="memitem:a69c54d030844fd05177700555ba7194c" id="r_a69c54d030844fd05177700555ba7194c"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a69c54d030844fd05177700555ba7194c">Task</a></td></tr>
<tr class="memdesc:a69c54d030844fd05177700555ba7194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">任务类型定义  <br /></td></tr>
<tr class="separator:a69c54d030844fd05177700555ba7194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4e5ac5169311b387d1142ab051b576" id="r_aaf4e5ac5169311b387d1142ab051b576"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aaf4e5ac5169311b387d1142ab051b576">PriceMap</a></td></tr>
<tr class="memdesc:aaf4e5ac5169311b387d1142ab051b576"><td class="mdescLeft">&#160;</td><td class="mdescRight">价格映射类型定义  <br /></td></tr>
<tr class="separator:aaf4e5ac5169311b387d1142ab051b576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653f4c1567920315b47b7fb79b0b54bc" id="r_a653f4c1567920315b47b7fb79b0b54bc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUftMocker_1_1__StraFactInfo.html">UftMocker::_StraFactInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a653f4c1567920315b47b7fb79b0b54bc">StraFactInfo</a></td></tr>
<tr class="memdesc:a653f4c1567920315b47b7fb79b0b54bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息结构体  <br /></td></tr>
<tr class="separator:a653f4c1567920315b47b7fb79b0b54bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48a4953e4031dde0375b856f7ee4d85" id="r_ac48a4953e4031dde0375b856f7ee4d85"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUftMocker_1_1__OrderInfo.html">UftMocker::_OrderInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ac48a4953e4031dde0375b856f7ee4d85">OrderInfo</a></td></tr>
<tr class="memdesc:ac48a4953e4031dde0375b856f7ee4d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单信息结构体  <br /></td></tr>
<tr class="separator:ac48a4953e4031dde0375b856f7ee4d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29ae03c9acd16d9f523690c2a26ab9" id="r_aca29ae03c9acd16d9f523690c2a26ab9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; uint32_t, <a class="el" href="classUftMocker.html#ac48a4953e4031dde0375b856f7ee4d85">OrderInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aca29ae03c9acd16d9f523690c2a26ab9">Orders</a></td></tr>
<tr class="memdesc:aca29ae03c9acd16d9f523690c2a26ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单映射类型定义  <br /></td></tr>
<tr class="separator:aca29ae03c9acd16d9f523690c2a26ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47f6559cc48ef3cffa711f0584f79bb" id="r_ad47f6559cc48ef3cffa711f0584f79bb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ad47f6559cc48ef3cffa711f0584f79bb">StringHashMap</a></td></tr>
<tr class="memdesc:ad47f6559cc48ef3cffa711f0584f79bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">字符串映射类型定义  <br /></td></tr>
<tr class="separator:ad47f6559cc48ef3cffa711f0584f79bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619dd073519ac958c306ab9c08e71fbc" id="r_a619dd073519ac958c306ab9c08e71fbc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUftMocker_1_1__DetailInfo.html">UftMocker::_DetailInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a619dd073519ac958c306ab9c08e71fbc">DetailInfo</a></td></tr>
<tr class="memdesc:a619dd073519ac958c306ab9c08e71fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易明细信息结构体  <br /></td></tr>
<tr class="separator:a619dd073519ac958c306ab9c08e71fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb957c528f6b3cc8ee492dfd9b34e055" id="r_abb957c528f6b3cc8ee492dfd9b34e055"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUftMocker_1_1__PosItem.html">UftMocker::_PosItem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#abb957c528f6b3cc8ee492dfd9b34e055">PosItem</a></td></tr>
<tr class="memdesc:abb957c528f6b3cc8ee492dfd9b34e055"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓项目结构体  <br /></td></tr>
<tr class="separator:abb957c528f6b3cc8ee492dfd9b34e055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4742f29ef04f5fdcfc08fbdfad89f182" id="r_a4742f29ef04f5fdcfc08fbdfad89f182"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUftMocker_1_1__PosInfo.html">UftMocker::_PosInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a4742f29ef04f5fdcfc08fbdfad89f182">PosInfo</a></td></tr>
<tr class="memdesc:a4742f29ef04f5fdcfc08fbdfad89f182"><td class="mdescLeft">&#160;</td><td class="mdescRight">合约持仓信息结构体  <br /></td></tr>
<tr class="separator:a4742f29ef04f5fdcfc08fbdfad89f182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fdc0434f73839c8aaf157af4c10bd0" id="r_a74fdc0434f73839c8aaf157af4c10bd0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, <a class="el" href="classUftMocker.html#a4742f29ef04f5fdcfc08fbdfad89f182">PosInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a74fdc0434f73839c8aaf157af4c10bd0">PositionMap</a></td></tr>
<tr class="memdesc:a74fdc0434f73839c8aaf157af4c10bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓映射类型定义  <br /></td></tr>
<tr class="separator:a74fdc0434f73839c8aaf157af4c10bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45464aae4e1ace2f9f466e15ca366405" id="r_a45464aae4e1ace2f9f466e15ca366405"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUftMocker_1_1__StraFundInfo.html">UftMocker::_StraFundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a45464aae4e1ace2f9f466e15ca366405">StraFundInfo</a></td></tr>
<tr class="memdesc:a45464aae4e1ace2f9f466e15ca366405"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息结构体  <br /></td></tr>
<tr class="separator:a45464aae4e1ace2f9f466e15ca366405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:ae73cb018d802faf69acc6af1ac92cc6c" id="r_ae73cb018d802faf69acc6af1ac92cc6c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae73cb018d802faf69acc6af1ac92cc6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae73cb018d802faf69acc6af1ac92cc6c">log_debug</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:ae73cb018d802faf69acc6af1ac92cc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录调试级别的日志  <br /></td></tr>
<tr class="separator:ae73cb018d802faf69acc6af1ac92cc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add808e8aa139bb00ce608772ff674d" id="r_a7add808e8aa139bb00ce608772ff674d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7add808e8aa139bb00ce608772ff674d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a7add808e8aa139bb00ce608772ff674d">log_info</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:a7add808e8aa139bb00ce608772ff674d"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录信息级别的日志  <br /></td></tr>
<tr class="separator:a7add808e8aa139bb00ce608772ff674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ca81ea36d702d2b7c6871ac2c760d2" id="r_ac2ca81ea36d702d2b7c6871ac2c760d2"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac2ca81ea36d702d2b7c6871ac2c760d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ac2ca81ea36d702d2b7c6871ac2c760d2">log_error</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:ac2ca81ea36d702d2b7c6871ac2c760d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录错误级别的日志  <br /></td></tr>
<tr class="separator:ac2ca81ea36d702d2b7c6871ac2c760d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4968f9ed367c595ce2cfe4ce9f8b985" id="r_ae4968f9ed367c595ce2cfe4ce9f8b985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ae4968f9ed367c595ce2cfe4ce9f8b985">postTask</a> (<a class="el" href="classUftMocker.html#a69c54d030844fd05177700555ba7194c">Task</a> task)</td></tr>
<tr class="memdesc:ae4968f9ed367c595ce2cfe4ce9f8b985"><td class="mdescLeft">&#160;</td><td class="mdescRight">提交任务到任务队列  <br /></td></tr>
<tr class="separator:ae4968f9ed367c595ce2cfe4ce9f8b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10286c31e65f9cfa510b9ccb1f79c31e" id="r_a10286c31e65f9cfa510b9ccb1f79c31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a10286c31e65f9cfa510b9ccb1f79c31e">procTask</a> ()</td></tr>
<tr class="memdesc:a10286c31e65f9cfa510b9ccb1f79c31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理任务队列中的任务  <br /></td></tr>
<tr class="separator:a10286c31e65f9cfa510b9ccb1f79c31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43d8223a63e34c1a43b1ade2e861c3a" id="r_ad43d8223a63e34c1a43b1ade2e861c3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ad43d8223a63e34c1a43b1ade2e861c3a">procOrder</a> (uint32_t localid)</td></tr>
<tr class="memdesc:ad43d8223a63e34c1a43b1ade2e861c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理指定订单  <br /></td></tr>
<tr class="separator:ad43d8223a63e34c1a43b1ade2e861c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af040581dfbad9adea966486ee63748cd" id="r_af040581dfbad9adea966486ee63748cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#af040581dfbad9adea966486ee63748cd">update_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint32_t offset, double qty, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>=0.0)</td></tr>
<tr class="memdesc:af040581dfbad9adea966486ee63748cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新持仓信息  <br /></td></tr>
<tr class="separator:af040581dfbad9adea966486ee63748cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0403941dd029f7e26c45f5faffda21" id="r_a1d0403941dd029f7e26c45f5faffda21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a1d0403941dd029f7e26c45f5faffda21">update_dyn_profit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick)</td></tr>
<tr class="memdesc:a1d0403941dd029f7e26c45f5faffda21"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新动态收益  <br /></td></tr>
<tr class="separator:a1d0403941dd029f7e26c45f5faffda21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4285e507d7c8ff86b75e4cfdae7e76a" id="r_ad4285e507d7c8ff86b75e4cfdae7e76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ad4285e507d7c8ff86b75e4cfdae7e76a">dump_outputs</a> ()</td></tr>
<tr class="memdesc:ad4285e507d7c8ff86b75e4cfdae7e76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出回测结果  <br /></td></tr>
<tr class="separator:ad4285e507d7c8ff86b75e4cfdae7e76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59afdde809ae55c213d95ab34dd37b9" id="r_aa59afdde809ae55c213d95ab34dd37b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aa59afdde809ae55c213d95ab34dd37b9">log_trade</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint32_t offset, uint64_t curTime, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, double fee)</td></tr>
<tr class="memdesc:aa59afdde809ae55c213d95ab34dd37b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录交易日志  <br /></td></tr>
<tr class="separator:aa59afdde809ae55c213d95ab34dd37b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a329c44fadd6fd2ad1db1039899b7a" id="r_a57a329c44fadd6fd2ad1db1039899b7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a57a329c44fadd6fd2ad1db1039899b7a">log_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint64_t openTime, double openpx, uint64_t closeTime, double closepx, double qty, double profit, double maxprofit, double maxloss, double totalprofit)</td></tr>
<tr class="memdesc:a57a329c44fadd6fd2ad1db1039899b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录平仓日志  <br /></td></tr>
<tr class="separator:a57a329c44fadd6fd2ad1db1039899b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:af09507d16b2ea6210c653cee490ed865" id="r_af09507d16b2ea6210c653cee490ed865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#af09507d16b2ea6210c653cee490ed865">_replayer</a></td></tr>
<tr class="memdesc:af09507d16b2ea6210c653cee490ed865"><td class="mdescLeft">&#160;</td><td class="mdescRight">历史数据回放器指针  <br /></td></tr>
<tr class="separator:af09507d16b2ea6210c653cee490ed865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d59cab79c09ef3ad3831fcb68b1d8e1" id="r_a1d59cab79c09ef3ad3831fcb68b1d8e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a1d59cab79c09ef3ad3831fcb68b1d8e1">_use_newpx</a></td></tr>
<tr class="memdesc:a1d59cab79c09ef3ad3831fcb68b1d8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否使用最新价格标志  <br /></td></tr>
<tr class="separator:a1d59cab79c09ef3ad3831fcb68b1d8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e277763d6fab9e14a2fd72b10b543af" id="r_a2e277763d6fab9e14a2fd72b10b543af"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a2e277763d6fab9e14a2fd72b10b543af">_error_rate</a></td></tr>
<tr class="memdesc:a2e277763d6fab9e14a2fd72b10b543af"><td class="mdescLeft">&#160;</td><td class="mdescRight">错误率设置  <br /></td></tr>
<tr class="separator:a2e277763d6fab9e14a2fd72b10b543af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991d3586964063f36305956b95fd9b92" id="r_a991d3586964063f36305956b95fd9b92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a991d3586964063f36305956b95fd9b92">_match_this_tick</a></td></tr>
<tr class="memdesc:a991d3586964063f36305956b95fd9b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前tick撮合标志  <br /></td></tr>
<tr class="separator:a991d3586964063f36305956b95fd9b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3d44e1f3370b3bb655d5a7d25ae46b" id="r_a3d3d44e1f3370b3bb655d5a7d25ae46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftMocker.html#aaf4e5ac5169311b387d1142ab051b576">PriceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a3d3d44e1f3370b3bb655d5a7d25ae46b">_price_map</a></td></tr>
<tr class="memdesc:a3d3d44e1f3370b3bb655d5a7d25ae46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">价格映射表  <br /></td></tr>
<tr class="separator:a3d3d44e1f3370b3bb655d5a7d25ae46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02de1e268e424e0ddd354c9c321f5d44" id="r_a02de1e268e424e0ddd354c9c321f5d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftMocker.html#a653f4c1567920315b47b7fb79b0b54bc">StraFactInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a02de1e268e424e0ddd354c9c321f5d44">_factory</a></td></tr>
<tr class="memdesc:a02de1e268e424e0ddd354c9c321f5d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">UFT策略工厂实例  <br /></td></tr>
<tr class="separator:a02de1e268e424e0ddd354c9c321f5d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4828872447a8ca8c3566c7a52e16fe" id="r_aab4828872447a8ca8c3566c7a52e16fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftStrategy.html">UftStrategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aab4828872447a8ca8c3566c7a52e16fe">_strategy</a></td></tr>
<tr class="memdesc:aab4828872447a8ca8c3566c7a52e16fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">UFT策略实例指针  <br /></td></tr>
<tr class="separator:aab4828872447a8ca8c3566c7a52e16fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8af1a927e4e93da6da8ec435c5fdd6" id="r_aee8af1a927e4e93da6da8ec435c5fdd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#aee8af1a927e4e93da6da8ec435c5fdd6">_mtx</a></td></tr>
<tr class="memdesc:aee8af1a927e4e93da6da8ec435c5fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">线程互斥锁  <br /></td></tr>
<tr class="separator:aee8af1a927e4e93da6da8ec435c5fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af554869084300d5227dac1639c165196" id="r_af554869084300d5227dac1639c165196"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="classUftMocker.html#a69c54d030844fd05177700555ba7194c">Task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#af554869084300d5227dac1639c165196">_tasks</a></td></tr>
<tr class="memdesc:af554869084300d5227dac1639c165196"><td class="mdescLeft">&#160;</td><td class="mdescRight">任务队列  <br /></td></tr>
<tr class="separator:af554869084300d5227dac1639c165196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b2fcfd0004a1f071b3b1325e3945e8" id="r_a93b2fcfd0004a1f071b3b1325e3945e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a93b2fcfd0004a1f071b3b1325e3945e8">_mtx_control</a></td></tr>
<tr class="memdesc:a93b2fcfd0004a1f071b3b1325e3945e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">递归互斥锁  <br /></td></tr>
<tr class="separator:a93b2fcfd0004a1f071b3b1325e3945e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8f668d850021c131649a040b87850c" id="r_a7e8f668d850021c131649a040b87850c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a7e8f668d850021c131649a040b87850c">_mtx_ords</a></td></tr>
<tr class="memdesc:a7e8f668d850021c131649a040b87850c"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单管理的互斥锁  <br /></td></tr>
<tr class="separator:a7e8f668d850021c131649a040b87850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d76b0afa2e03f0ac63eefe551d5d63" id="r_a88d76b0afa2e03f0ac63eefe551d5d63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftMocker.html#aca29ae03c9acd16d9f523690c2a26ab9">Orders</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a88d76b0afa2e03f0ac63eefe551d5d63">_orders</a></td></tr>
<tr class="memdesc:a88d76b0afa2e03f0ac63eefe551d5d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单容器  <br /></td></tr>
<tr class="separator:a88d76b0afa2e03f0ac63eefe551d5d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8623451cd87ba2fea88ba57508e01c7" id="r_ac8623451cd87ba2fea88ba57508e01c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftMocker.html#ad47f6559cc48ef3cffa711f0584f79bb">StringHashMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ac8623451cd87ba2fea88ba57508e01c7">_user_datas</a></td></tr>
<tr class="memdesc:ac8623451cd87ba2fea88ba57508e01c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户数据容器  <br /></td></tr>
<tr class="separator:ac8623451cd87ba2fea88ba57508e01c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197d52ee213e45a824690bc56bc6f4e6" id="r_a197d52ee213e45a824690bc56bc6f4e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a197d52ee213e45a824690bc56bc6f4e6">_ud_modified</a></td></tr>
<tr class="memdesc:a197d52ee213e45a824690bc56bc6f4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户数据修改标记  <br /></td></tr>
<tr class="separator:a197d52ee213e45a824690bc56bc6f4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a2a1ec1fb7922a4ba4ae4a2a2a74c1" id="r_a27a2a1ec1fb7922a4ba4ae4a2a2a74c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftMocker.html#a74fdc0434f73839c8aaf157af4c10bd0">PositionMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a27a2a1ec1fb7922a4ba4ae4a2a2a74c1">_pos_map</a></td></tr>
<tr class="memdesc:a27a2a1ec1fb7922a4ba4ae4a2a2a74c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓映射容器  <br /></td></tr>
<tr class="separator:a27a2a1ec1fb7922a4ba4ae4a2a2a74c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f56e451de15b544e8e6f3a4e95a6720" id="r_a1f56e451de15b544e8e6f3a4e95a6720"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a1f56e451de15b544e8e6f3a4e95a6720">_trade_logs</a></td></tr>
<tr class="memdesc:a1f56e451de15b544e8e6f3a4e95a6720"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日志流  <br /></td></tr>
<tr class="separator:a1f56e451de15b544e8e6f3a4e95a6720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fe80527477d3615665768afe88986c" id="r_ab5fe80527477d3615665768afe88986c"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ab5fe80527477d3615665768afe88986c">_close_logs</a></td></tr>
<tr class="memdesc:ab5fe80527477d3615665768afe88986c"><td class="mdescLeft">&#160;</td><td class="mdescRight">平仓日志流  <br /></td></tr>
<tr class="separator:ab5fe80527477d3615665768afe88986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e63abbbd43a222d3f5dbff64cfad3c0" id="r_a8e63abbbd43a222d3f5dbff64cfad3c0"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a8e63abbbd43a222d3f5dbff64cfad3c0">_fund_logs</a></td></tr>
<tr class="memdesc:a8e63abbbd43a222d3f5dbff64cfad3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">资金日志流  <br /></td></tr>
<tr class="separator:a8e63abbbd43a222d3f5dbff64cfad3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074d811c5a8ecaf5dbba6e2f6ec4e282" id="r_a074d811c5a8ecaf5dbba6e2f6ec4e282"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#a074d811c5a8ecaf5dbba6e2f6ec4e282">_pos_logs</a></td></tr>
<tr class="memdesc:a074d811c5a8ecaf5dbba6e2f6ec4e282"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓日志流  <br /></td></tr>
<tr class="separator:a074d811c5a8ecaf5dbba6e2f6ec4e282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12cdaf6e524e508e8040b46ca967879" id="r_ab12cdaf6e524e508e8040b46ca967879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classUftMocker.html#a45464aae4e1ace2f9f466e15ca366405">StraFundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUftMocker.html#ab12cdaf6e524e508e8040b46ca967879">_fund_info</a></td></tr>
<tr class="memdesc:ab12cdaf6e524e508e8040b46ca967879"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息  <br /></td></tr>
<tr class="separator:ab12cdaf6e524e508e8040b46ca967879"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>UFT策略回测模拟器类 </p>
<p>该类实现了两个接口：</p><ol type="1">
<li>IDataSink接口：用于接收回放的历史数据</li>
<li>IUftStraCtx接口：用于为策略提供执行环境</li>
</ol>
<p>模拟器核心功能包括：</p><ul>
<li>加载并初始化UFT策略</li>
<li>接收历史数据并传递给策略</li>
<li>模拟策略交易并维护仓位、资金等信息</li>
<li>计算策略绩效并生成回测日志 </li>
</ul>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00040">40</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a619dd073519ac958c306ab9c08e71fbc" name="a619dd073519ac958c306ab9c08e71fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619dd073519ac958c306ab9c08e71fbc">&#9670;&#160;</a></span>DetailInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUftMocker_1_1__DetailInfo.html">UftMocker::_DetailInfo</a> <a class="el" href="classUftMocker.html#a619dd073519ac958c306ab9c08e71fbc">UftMocker::DetailInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易明细信息结构体 </p>
<p>存储交易明细的详细信息，包括价格、数量、时间、盈亏等 </p>

</div>
</div>
<a id="ac48a4953e4031dde0375b856f7ee4d85" name="ac48a4953e4031dde0375b856f7ee4d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48a4953e4031dde0375b856f7ee4d85">&#9670;&#160;</a></span>OrderInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUftMocker_1_1__OrderInfo.html">UftMocker::_OrderInfo</a> <a class="el" href="classUftMocker.html#ac48a4953e4031dde0375b856f7ee4d85">UftMocker::OrderInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单信息结构体 </p>
<p>存储订单的基本信息，包括方向、合约代码、数量等 </p>

</div>
</div>
<a id="aca29ae03c9acd16d9f523690c2a26ab9" name="aca29ae03c9acd16d9f523690c2a26ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca29ae03c9acd16d9f523690c2a26ab9">&#9670;&#160;</a></span>Orders</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;uint32_t, <a class="el" href="classUftMocker.html#ac48a4953e4031dde0375b856f7ee4d85">OrderInfo</a>&gt; <a class="el" href="classUftMocker.html#aca29ae03c9acd16d9f523690c2a26ab9">UftMocker::Orders</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单映射类型定义 </p>
<p>定义订单ID到订单信息的映射关系，用于快速查找和维护订单 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00866">866</a> 行定义.</p>

</div>
</div>
<a id="a4742f29ef04f5fdcfc08fbdfad89f182" name="a4742f29ef04f5fdcfc08fbdfad89f182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4742f29ef04f5fdcfc08fbdfad89f182">&#9670;&#160;</a></span>PosInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUftMocker_1_1__PosInfo.html">UftMocker::_PosInfo</a> <a class="el" href="classUftMocker.html#a4742f29ef04f5fdcfc08fbdfad89f182">UftMocker::PosInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>合约持仓信息结构体 </p>
<p>存储单个合约的多空两个方向的完整持仓信息 </p>

</div>
</div>
<a id="abb957c528f6b3cc8ee492dfd9b34e055" name="abb957c528f6b3cc8ee492dfd9b34e055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb957c528f6b3cc8ee492dfd9b34e055">&#9670;&#160;</a></span>PosItem</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUftMocker_1_1__PosItem.html">UftMocker::_PosItem</a> <a class="el" href="classUftMocker.html#abb957c528f6b3cc8ee492dfd9b34e055">UftMocker::PosItem</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓项目结构体 </p>
<p>存储持仓的详细信息，包括方向、数量、可用数量、盈亏等 </p>

</div>
</div>
<a id="a74fdc0434f73839c8aaf157af4c10bd0" name="a74fdc0434f73839c8aaf157af4c10bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fdc0434f73839c8aaf157af4c10bd0">&#9670;&#160;</a></span>PositionMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, <a class="el" href="classUftMocker.html#a4742f29ef04f5fdcfc08fbdfad89f182">PosInfo</a>&gt; <a class="el" href="classUftMocker.html#a74fdc0434f73839c8aaf157af4c10bd0">UftMocker::PositionMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓映射类型定义 </p>
<p>定义合约代码到持仓信息的映射关系，用于快速查找和维护各合约的持仓 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01084">1084</a> 行定义.</p>

</div>
</div>
<a id="aaf4e5ac5169311b387d1142ab051b576" name="aaf4e5ac5169311b387d1142ab051b576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4e5ac5169311b387d1142ab051b576">&#9670;&#160;</a></span>PriceMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, double&gt; <a class="el" href="classUftMocker.html#aaf4e5ac5169311b387d1142ab051b576">UftMocker::PriceMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>价格映射类型定义 </p>
<p>合约代码到价格的映射，用于快速查找特定合约的价格 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00706">706</a> 行定义.</p>

</div>
</div>
<a id="a653f4c1567920315b47b7fb79b0b54bc" name="a653f4c1567920315b47b7fb79b0b54bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653f4c1567920315b47b7fb79b0b54bc">&#9670;&#160;</a></span>StraFactInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUftMocker_1_1__StraFactInfo.html">UftMocker::_StraFactInfo</a> <a class="el" href="classUftMocker.html#a653f4c1567920315b47b7fb79b0b54bc">UftMocker::StraFactInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略工厂信息结构体 </p>
<p>用于存储UFT策略工厂的相关信息，包括模块路径、DLL句柄、工厂实例和创建/删除函数 </p>

</div>
</div>
<a id="a45464aae4e1ace2f9f466e15ca366405" name="a45464aae4e1ace2f9f466e15ca366405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45464aae4e1ace2f9f466e15ca366405">&#9670;&#160;</a></span>StraFundInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUftMocker_1_1__StraFundInfo.html">UftMocker::_StraFundInfo</a> <a class="el" href="classUftMocker.html#a45464aae4e1ace2f9f466e15ca366405">UftMocker::StraFundInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略资金信息结构体 </p>
<p>存储策略资金的详细信息，包括总盈亏、浮动盈亏、手续费等 </p>

</div>
</div>
<a id="ad47f6559cc48ef3cffa711f0584f79bb" name="ad47f6559cc48ef3cffa711f0584f79bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47f6559cc48ef3cffa711f0584f79bb">&#9670;&#160;</a></span>StringHashMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, std::string&gt; <a class="el" href="classUftMocker.html#ad47f6559cc48ef3cffa711f0584f79bb">UftMocker::StringHashMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>字符串映射类型定义 </p>
<p>定义键值对映射关系，用于存储用户自定义数据 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00885">885</a> 行定义.</p>

</div>
</div>
<a id="a69c54d030844fd05177700555ba7194c" name="a69c54d030844fd05177700555ba7194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c54d030844fd05177700555ba7194c">&#9670;&#160;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void()&gt; <a class="el" href="classUftMocker.html#a69c54d030844fd05177700555ba7194c">UftMocker::Task</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>任务类型定义 </p>
<p>定义一个可执行的任务对象，用于异步任务队列 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00599">599</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a464b7eb82180d1aae010361fa925b579" name="a464b7eb82180d1aae010361fa925b579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464b7eb82180d1aae010361fa925b579">&#9670;&#160;</a></span>UftMocker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UftMocker::UftMocker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *&#160;</td>
          <td class="paramname"><em>replayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UFT策略回测模拟器构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">replayer</td><td>历史数据回放器指针 </td></tr>
    <tr><td class="paramname">name</td><td>策略名称</td></tr>
  </table>
  </dd>
</dl>
<p>构造一个新的UFT策略回测模拟器实例，用于执行回测</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">replayer</td><td>历史数据回放器指针 </td></tr>
    <tr><td class="paramname">name</td><td>策略名称</td></tr>
  </table>
  </dd>
</dl>
<p>初始化UFT策略回测模拟器，设置基本参数并生成唯一的上下文ID </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00085">85</a> 行定义.</p>

</div>
</div>
<a id="adaad164f6540f0a98a69ed3e3a1d36a2" name="adaad164f6540f0a98a69ed3e3a1d36a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaad164f6540f0a98a69ed3e3a1d36a2">&#9670;&#160;</a></span>~UftMocker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UftMocker::~UftMocker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UFT策略回测模拟器析构函数 </p>
<p>释放模拟器占用的资源，包括策略对象、订单缓存等</p>
<p>清理模拟器资源，释放策略实例 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00101">101</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="ad4285e507d7c8ff86b75e4cfdae7e76a" name="ad4285e507d7c8ff86b75e4cfdae7e76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4285e507d7c8ff86b75e4cfdae7e76a">&#9670;&#160;</a></span>dump_outputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::dump_outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>输出回测结果 </p>
<p>输出回测结果到CSV文件</p>
<p>将回测结果输出到指定的文件或控制台</p>
<p>将回测过程中收集的交易、平仓、资金和持仓日志导出到CSV文件 创建以策略名命名的文件夹，并将以下文件写入该文件夹：</p><ol type="1">
<li>trades.csv - 交易记录，包含合约、时间、方向、动作、价格、数量、手续费等</li>
<li>closes.csv - 平仓记录，包含合约、方向、开仓时间、开仓价格、平仓时间、平仓价格、数量、利润等</li>
<li>funds.csv - 资金记录，包含日期、平仓盈亏、持仓盈亏、动态余额和手续费</li>
<li>positions.csv - 持仓记录，包含日期、合约、方向、数量、平仓盈亏和动态盈亏 这些文件可用于后续的策略分析和绩效评估 </li>
</ol>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01638">1638</a> 行定义.</p>

</div>
</div>
<a id="a671e6ebc483bcead9afdc9ba5252ff61" name="a671e6ebc483bcead9afdc9ba5252ff61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671e6ebc483bcead9afdc9ba5252ff61">&#9670;&#160;</a></span>handle_bar_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_bar_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理K线闭合事件 </p>
<p>处理K线周期结束事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识符 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>当K线周期结束时触发，将新的K线数据传递给策略的on_bar回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识符 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新生成的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，当K线周期结束时被调用，将最新的K线数据传递给策略 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a7b32410de4629a8ea22ff8f9547f9f4d">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00283">283</a> 行定义.</p>

</div>
</div>
<a id="a2eb6c21fa2f765e719b0344b54833d15" name="a2eb6c21fa2f765e719b0344b54833d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb6c21fa2f765e719b0344b54833d15">&#9670;&#160;</a></span>handle_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理初始化事件 </p>
<p>回测引擎初始化时触发，用于执行策略的初始化操作</p>
<p>实现IDataSink接口的方法，在回测开始时调用，初始化策略并通知交易通道就绪 依次触发策略的on_init和on_channel_ready回调 </p>

<p>实现了 <a class="el" href="classIDataSink.html#aad99745d3af1e228d167db17730e755c">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00293">293</a> 行定义.</p>

</div>
</div>
<a id="a72e899a1ed9ac09ce26a11c90cbb5cb1" name="a72e899a1ed9ac09ce26a11c90cbb5cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e899a1ed9ac09ce26a11c90cbb5cb1">&#9670;&#160;</a></span>handle_order_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_order_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *&#160;</td>
          <td class="paramname"><em>curOrdDtl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理委托明细数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curOrdDtl</td><td>当前委托明细数据</td></tr>
  </table>
  </dd>
</dl>
<p>接收并处理回放器推送的委托明细数据，触发策略的on_order_detail回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curOrdDtl</td><td>当前的委托明细数据</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，用于接收并处理行情数据源发送的委托明细数据 </p>

<p>重载 <a class="el" href="classIDataSink.html#ab181668bb73591a42e322dbc4a32ff8a">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00248">248</a> 行定义.</p>

</div>
</div>
<a id="a44413fc9146e581a4ffafa1c6195613b" name="a44413fc9146e581a4ffafa1c6195613b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44413fc9146e581a4ffafa1c6195613b">&#9670;&#160;</a></span>handle_order_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_order_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *&#160;</td>
          <td class="paramname"><em>curOrdQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理委托队列数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curOrdQue</td><td>当前委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>接收并处理回放器推送的委托队列数据，触发策略的on_order_queue回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curOrdQue</td><td>当前的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，用于接收并处理行情数据源发送的委托队列数据 </p>

<p>重载 <a class="el" href="classIDataSink.html#ac0ac665e5f5e9330b4847393a8d5a253">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00259">259</a> 行定义.</p>

</div>
</div>
<a id="a96bcaf32225f45c8553d9a992caf3c82" name="a96bcaf32225f45c8553d9a992caf3c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bcaf32225f45c8553d9a992caf3c82">&#9670;&#160;</a></span>handle_replay_done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_replay_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理回放完成事件 </p>
<p>当历史数据回放完成时触发，用于执行回测结束操作（如生成结果分析）</p>
<p>实现IDataSink接口的方法，在历史数据回放完成时被调用 首先调用dump_outputs()输出回测结果，然后触发on_bactest_end()回调通知策略回测结束 </p>

<p>重载 <a class="el" href="classIDataSink.html#a449d6fee677ebdce5747ec8db2cb1afc">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00335">335</a> 行定义.</p>

</div>
</div>
<a id="a80404593eb7d4a14500cd4e3a13458c8" name="a80404593eb7d4a14500cd4e3a13458c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80404593eb7d4a14500cd4e3a13458c8">&#9670;&#160;</a></span>handle_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_schedule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uDate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理定时事件 </p>
<p>处理定时任务事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uDate</td><td>交易日期（YYYYMMDD） </td></tr>
    <tr><td class="paramname">uTime</td><td>交易时间（HHMMSS）</td></tr>
  </table>
  </dd>
</dl>
<p>根据回测时间定时触发策略的相关操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uDate</td><td>当前交易日期，格式YYYYMMDD </td></tr>
    <tr><td class="paramname">uTime</td><td>当前时间，格式HHMMSS</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，在回测器的定时任务触发时被调用，当前实现中未使用 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a2e95899a2f5e48dd47cdb89eef7af3d7">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00305">305</a> 行定义.</p>

</div>
</div>
<a id="abdc7f2fe277c08e0f82a8f857430148d" name="abdc7f2fe277c08e0f82a8f857430148d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc7f2fe277c08e0f82a8f857430148d">&#9670;&#160;</a></span>handle_session_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_session_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易日开始事件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日（YYYYMMDD）</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日开始时触发，用于执行策略的日初操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日期，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，在每个交易日开始时被调用，触发策略的on_session_begin回调 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a7518e7f54d3c02334d5bf8039d998ea1">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00315">315</a> 行定义.</p>

</div>
</div>
<a id="aa4dae33dafe0108c778f8f0939dd22e5" name="aa4dae33dafe0108c778f8f0939dd22e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dae33dafe0108c778f8f0939dd22e5">&#9670;&#160;</a></span>handle_session_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_session_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易日结束事件 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日（YYYYMMDD）</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日结束时触发，用于执行策略的日结操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日期，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，在每个交易日结束时被调用，触发策略的on_session_end回调 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a3a8c562237bfa38cf0a789d2156e7f83">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00325">325</a> 行定义.</p>

</div>
</div>
<a id="ab69fde97b863030a99ba736f46dd64a1" name="ab69fde97b863030a99ba736f46dd64a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69fde97b863030a99ba736f46dd64a1">&#9670;&#160;</a></span>handle_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>curTick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pxType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理Tick数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curTick</td><td>当前Tick数据 </td></tr>
    <tr><td class="paramname">pxType</td><td>价格类型</td></tr>
  </table>
  </dd>
</dl>
<p>接收并处理回放器推送的Tick数据，主要用于更新最新价格和触发策略的on_tick回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curTick</td><td>当前Tick数据 </td></tr>
    <tr><td class="paramname">pxType</td><td>价格类型</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，用于处理当前收到的Tick数据 先保存当前合约价格，然后更新浮动盈亏 如果该合约有未完成的委托，还会尝试处理这些委托 最后调用策略的on_tick回调函数通知有新的市场数据 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a49f916a6431df8140564afd06bf20158">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00237">237</a> 行定义.</p>

</div>
</div>
<a id="ae091f6c4053a526d76df2a9bac52b1b5" name="ae091f6c4053a526d76df2a9bac52b1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae091f6c4053a526d76df2a9bac52b1b5">&#9670;&#160;</a></span>handle_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::handle_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTransData.html">WTSTransData</a> *&#160;</td>
          <td class="paramname"><em>curTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理逐笔成交数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curTrans</td><td>当前逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>接收并处理回放器推送的逐笔成交数据，触发策略的on_transaction回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curTrans</td><td>当前的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的方法，用于接收并处理行情数据源发送的逐笔成交数据 </p>

<p>重载 <a class="el" href="classIDataSink.html#a1bdeadd1cef35b1976dfb8dcb8b82aab">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00270">270</a> 行定义.</p>

</div>
</div>
<a id="abb3853101bf75b4cdd0f81b7d5a9608c" name="abb3853101bf75b4cdd0f81b7d5a9608c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3853101bf75b4cdd0f81b7d5a9608c">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取策略ID </p>
<p>获取策略上下文ID</p>
<dl class="section return"><dt>返回</dt><dd>策略上下文对象的全局唯一ID</dd></dl>
<p>用于标识不同的策略上下文实例</p>
<dl class="section return"><dt>返回</dt><dd>返回策略上下文的唯一ID</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取策略上下文的唯一标识 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a691407a117e163a40579572c0be36828">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00523">523</a> 行定义.</p>

</div>
</div>
<a id="ad988622a5baae466097e196432f2d7f6" name="ad988622a5baae466097e196432f2d7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad988622a5baae466097e196432f2d7f6">&#9670;&#160;</a></span>init_uft_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UftMocker::init_uft_factory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWTSVariant.html">WTSVariant</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>初始化UFT策略工厂 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>配置项参数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>初始化是否成功</dd></dl>
<p>根据提供的配置初始化UFT策略工厂，加载对应的策略模块</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>配置参数，包含策略工厂的加载路径、撮合参数等 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>初始化是否成功</dd></dl>
<p>根据配置参数加载策略工厂动态链接库，初始化撮合参数，并创建UFT策略实例 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00188">188</a> 行定义.</p>

</div>
</div>
<a id="a57a329c44fadd6fd2ad1db1039899b7a" name="a57a329c44fadd6fd2ad1db1039899b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a329c44fadd6fd2ad1db1039899b7a">&#9670;&#160;</a></span>log_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::log_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>openTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>openpx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>closeTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>closepx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>profit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxprofit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxloss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>totalprofit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录平仓日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">openTime</td><td>开仓时间 </td></tr>
    <tr><td class="paramname">openpx</td><td>开仓价格 </td></tr>
    <tr><td class="paramname">closeTime</td><td>平仓时间 </td></tr>
    <tr><td class="paramname">closepx</td><td>平仓价格 </td></tr>
    <tr><td class="paramname">qty</td><td>数量 </td></tr>
    <tr><td class="paramname">profit</td><td>当次平仓盈亏 </td></tr>
    <tr><td class="paramname">maxprofit</td><td>最大浮盈 </td></tr>
    <tr><td class="paramname">maxloss</td><td>最大浮亏 </td></tr>
    <tr><td class="paramname">totalprofit</td><td>总盈亏</td></tr>
  </table>
  </dd>
</dl>
<p>记录平仓操作相关数据，用于生成交易报告和回测分析</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">openTime</td><td>开仓时间 </td></tr>
    <tr><td class="paramname">openpx</td><td>开仓价格 </td></tr>
    <tr><td class="paramname">closeTime</td><td>平仓时间 </td></tr>
    <tr><td class="paramname">closepx</td><td>平仓价格 </td></tr>
    <tr><td class="paramname">qty</td><td>平仓数量 </td></tr>
    <tr><td class="paramname">profit</td><td>平仓盈亏 </td></tr>
    <tr><td class="paramname">maxprofit</td><td>最大盈利 </td></tr>
    <tr><td class="paramname">maxloss</td><td>最大亏损 </td></tr>
    <tr><td class="paramname">totalprofit</td><td>总盈亏，默认为0</td></tr>
  </table>
  </dd>
</dl>
<p>将平仓信息格式化并追加到内部平仓日志流中 记录的信息包括合约代码、交易方向、开仓时间、开仓价格、平仓时间、 平仓价格、数量、平仓盈亏、最大盈利、最大亏损和总盈亏 这些日志最终会写入closes.csv文件中 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01704">1704</a> 行定义.</p>

</div>
</div>
<a id="ae73cb018d802faf69acc6af1ac92cc6c" name="ae73cb018d802faf69acc6af1ac92cc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73cb018d802faf69acc6af1ac92cc6c">&#9670;&#160;</a></span>log_debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::log_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录调试级别的日志 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>可变参数类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>格式化字符串 </td></tr>
    <tr><td class="paramname">args</td><td>格式化参数</td></tr>
  </table>
  </dd>
</dl>
<p>使用fmt库格式化字符串并记录调试级别的日志 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00066">66</a> 行定义.</p>

</div>
</div>
<a id="ac2ca81ea36d702d2b7c6871ac2c760d2" name="ac2ca81ea36d702d2b7c6871ac2c760d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2ca81ea36d702d2b7c6871ac2c760d2">&#9670;&#160;</a></span>log_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::log_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录错误级别的日志 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>可变参数类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>格式化字符串 </td></tr>
    <tr><td class="paramname">args</td><td>格式化参数</td></tr>
  </table>
  </dd>
</dl>
<p>使用fmt库格式化字符串并记录错误级别的日志 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00094">94</a> 行定义.</p>

</div>
</div>
<a id="a7add808e8aa139bb00ce608772ff674d" name="a7add808e8aa139bb00ce608772ff674d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7add808e8aa139bb00ce608772ff674d">&#9670;&#160;</a></span>log_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::log_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录信息级别的日志 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>可变参数类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>格式化字符串 </td></tr>
    <tr><td class="paramname">args</td><td>格式化参数</td></tr>
  </table>
  </dd>
</dl>
<p>使用fmt库格式化字符串并记录信息级别的日志 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00080">80</a> 行定义.</p>

</div>
</div>
<a id="aa59afdde809ae55c213d95ab34dd37b9" name="aa59afdde809ae55c213d95ab34dd37b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59afdde809ae55c213d95ab34dd37b9">&#9670;&#160;</a></span>log_trade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::log_trade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>curTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录交易日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平仓标记 </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格 </td></tr>
    <tr><td class="paramname">qty</td><td>成交数量 </td></tr>
    <tr><td class="paramname">fee</td><td>交易手续费</td></tr>
  </table>
  </dd>
</dl>
<p>记录交易日志，用于生成交易明细和分析报告</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平标记（0为开仓，1为平仓，2为平今） </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">fee</td><td>交易手续费</td></tr>
  </table>
  </dd>
</dl>
<p>将交易信息格式化并追加到内部交易日志流中 记录的信息包括合约代码、时间、交易方向、开平动作、价格、数量和手续费 这些日志最终会写入trades.csv文件中 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01680">1680</a> 行定义.</p>

</div>
</div>
<a id="a1c6db7dabeb1297eae8787929c05b60a" name="a1c6db7dabeb1297eae8787929c05b60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c6db7dabeb1297eae8787929c05b60a">&#9670;&#160;</a></span>on_bar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_bar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K线数据回调 </p>
<p>处理K线数据并调用策略的on_bar回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识符 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>当K线周期结束并生成新的K线数据时触发</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识符 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新生成的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的K线数据时，将其传递给策略实例的on_bar回调函数处理 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a6e0f96ce6a090ba048fe30c9f0cc4d7e">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00350">350</a> 行定义.</p>

</div>
</div>
<a id="aaab672033c90dc3bc142c2037b5ab7c4" name="aaab672033c90dc3bc142c2037b5ab7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab672033c90dc3bc142c2037b5ab7c4">&#9670;&#160;</a></span>on_channel_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_channel_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>通道就绪回调 </p>
<p>通知交易通道已就绪</p>
<p>当交易通道就绪时调用此函数，表示可以开始交易</p>
<p>当交易通道已经准备就绪可以开始交易时调用此函数 通过策略的on_channel_ready回调函数通知策略交易通道已就绪 策略可以在此时机开始执行交易操作 在回测框架中，这个函数在初始化完成后调用 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01160">1160</a> 行定义.</p>

</div>
</div>
<a id="af674be55e62dc791cfb68ba36335d6de" name="af674be55e62dc791cfb68ba36335d6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af674be55e62dc791cfb68ba36335d6de">&#9670;&#160;</a></span>on_entrust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_entrust </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSuccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>委托结果回调 </p>
<p>处理委托回报</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地委托ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">bSuccess</td><td>委托是否成功 </td></tr>
    <tr><td class="paramname">message</td><td>相关消息或错误原因</td></tr>
  </table>
  </dd>
</dl>
<p>当委托下达并收到结果反馈时调用此函数</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地委托单ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">bSuccess</td><td>委托是否成功 </td></tr>
    <tr><td class="paramname">message</td><td>委托回报消息</td></tr>
  </table>
  </dd>
</dl>
<p>当委托发出后收到交易所回报时调用此函数 通过策略的on_entrust回调函数将委托状态通知给策略 策略可以根据回报状态决定后续操作 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01147">1147</a> 行定义.</p>

</div>
</div>
<a id="ae9ab1bbb74eaf6ecf0e493517078e1a1" name="ae9ab1bbb74eaf6ecf0e493517078e1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ab1bbb74eaf6ecf0e493517078e1a1">&#9670;&#160;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略初始化回调 </p>
<p>初始化策略</p>
<p>当策略被加载并初始化后触发，策略可以在这里进行初始化操作</p>
<p>在回测开始时调用，触发策略的on_init回调函数，实现策略的初始化 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a825c3830bb34e51d427510142df652bf">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00532">532</a> 行定义.</p>

</div>
</div>
<a id="a3a11453469b65ee280d68d5f61ae3f37" name="a3a11453469b65ee280d68d5f61ae3f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a11453469b65ee280d68d5f61ae3f37">&#9670;&#160;</a></span>on_orddtl_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_orddtl_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *&#160;</td>
          <td class="paramname"><em>newOrdDtl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当委托明细数据更新时的回调 </p>
<p>处理委托明细数据更新并触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的委托明细数据</td></tr>
  </table>
  </dd>
</dl>
<p>当授权的合约的委托明细数据更新时触发此回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的委托明细数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的委托明细数据时，调用策略的on_order_detail回调函数处理 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a7298a13a26d4d5f57b3f986e5adacc0b">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00489">489</a> 行定义.</p>

</div>
</div>
<a id="a305c7de64825fb5f5644709931768025" name="a305c7de64825fb5f5644709931768025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305c7de64825fb5f5644709931768025">&#9670;&#160;</a></span>on_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_order </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>totalQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>leftQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCanceled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>委托状态回调 </p>
<p>处理订单状态变化</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地委托ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平标记 </td></tr>
    <tr><td class="paramname">totalQty</td><td>委托总数量 </td></tr>
    <tr><td class="paramname">leftQty</td><td>剩余未成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">isCanceled</td><td>是否已撤单</td></tr>
  </table>
  </dd>
</dl>
<p>当委托状态变化时调用此函数，例如送单成功、部分成交、撤单等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平标记（0为开仓，1为平仓，2为平今） </td></tr>
    <tr><td class="paramname">totalQty</td><td>总委托量 </td></tr>
    <tr><td class="paramname">leftQty</td><td>剩余未成交量 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">isCanceled</td><td>是否已撤单</td></tr>
  </table>
  </dd>
</dl>
<p>当订单状态发生变化时调用，将订单状态变化信息传递给策略 通过策略的on_order回调函数处理 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01111">1111</a> 行定义.</p>

</div>
</div>
<a id="a55646aca3a8637d8cbb31087077af2f0" name="a55646aca3a8637d8cbb31087077af2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55646aca3a8637d8cbb31087077af2f0">&#9670;&#160;</a></span>on_order_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_order_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *&#160;</td>
          <td class="paramname"><em>newOrdDtl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>委托明细数据回调 </p>
<p>处理委托明细数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的委托明细数据</td></tr>
  </table>
  </dd>
</dl>
<p>当有订阅的合约有新的委托明细数据到来时触发</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的委托明细数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的委托明细数据时，调用on_orddtl_updated方法处理 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aa5091d62fe254de5f01536a6ac68f2eb">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00478">478</a> 行定义.</p>

</div>
</div>
<a id="a7bd43e347f7143ea260a63a2650c9884" name="a7bd43e347f7143ea260a63a2650c9884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd43e347f7143ea260a63a2650c9884">&#9670;&#160;</a></span>on_order_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_order_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *&#160;</td>
          <td class="paramname"><em>newOrdQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>委托队列数据回调 </p>
<p>处理委托队列数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>当有订阅的合约有新的委托队列数据到来时触发</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的委托队列数据时，调用on_ordque_updated方法处理 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ac3a2a40952ae5482f059153ef503ff44">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00455">455</a> 行定义.</p>

</div>
</div>
<a id="a8b3921b1fe9e74af9aead5161065316e" name="a8b3921b1fe9e74af9aead5161065316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3921b1fe9e74af9aead5161065316e">&#9670;&#160;</a></span>on_ordque_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_ordque_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *&#160;</td>
          <td class="paramname"><em>newOrdQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当委托队列数据更新时的回调 </p>
<p>处理委托队列数据更新并触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>当授权的合约的委托队列数据更新时触发此回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的委托队列数据时，调用策略的on_order_queue回调函数处理 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a3c9af39621fde55eba23cc60007966fe">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00466">466</a> 行定义.</p>

</div>
</div>
<a id="a9576a3a77dd3cefde8ddcba3e941f4a6" name="a9576a3a77dd3cefde8ddcba3e941f4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9576a3a77dd3cefde8ddcba3e941f4a6">&#9670;&#160;</a></span>on_session_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_session_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日开始回调 </p>
<p>处理交易日开始事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日（YYYYMMDD）</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日开始时触发，策略可以在这里进行日初操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日期，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日开始时调用，首先处理持仓状态，将冻结持仓释放， 将新建持仓转为旧持仓，然后触发策略的on_session_begin回调 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#aa55be18f188d2f570a6c29057032c79d">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00544">544</a> 行定义.</p>

</div>
</div>
<a id="ad3147ad051ffc059fc356c2c8221ae30" name="ad3147ad051ffc059fc356c2c8221ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3147ad051ffc059fc356c2c8221ae30">&#9670;&#160;</a></span>on_session_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_session_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日结束回调 </p>
<p>处理交易日结束事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日（YYYYMMDD）</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日结束时触发，策略可以在这里进行日结操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日期，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日结束时调用，首先触发策略的on_session_end回调， 然后计算当日的盈亏情况，包括平仓盈亏和浮动盈亏， 并将持仓和资金信息记录到日志中 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a13e73ac1a881a377c5bdb556c84fead9">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00572">572</a> 行定义.</p>

</div>
</div>
<a id="ac83dda60dfa0874931852c13362eec54" name="ac83dda60dfa0874931852c13362eec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83dda60dfa0874931852c13362eec54">&#9670;&#160;</a></span>on_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick数据回调 </p>
<p>处理Tick行情数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>当有订阅的合约有新的Tick数据到来时触发，策略可以通过该函数接收并处理最新行情</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>这是回测模拟器的核心方法之一，负责处理新到的Tick数据，更新合约价格缓存， 计算动态收益，并根据配置决定是先处理订单还是先触发策略回调。 如果_match_this_tick为true，则先触发策略的on_tick回调，再处理订单； 否则先处理订单，再触发策略的on_tick回调。 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a5b584201e5933c1f424e0d8ee77a384c">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00365">365</a> 行定义.</p>

</div>
</div>
<a id="acc3cc7b1b3141a71be1e197c6dfe7bc6" name="acc3cc7b1b3141a71be1e197c6dfe7bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3cc7b1b3141a71be1e197c6dfe7bc6">&#9670;&#160;</a></span>on_tick_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_tick_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当Tick数据更新时的回调 </p>
<p>处理Tick数据更新并触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>当授权的合约的Tick数据更新时触发此回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的Tick数据时，首先检查该合约是否在订阅列表中， 如果在订阅列表中，则调用策略的on_tick回调函数处理该Tick数据 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a3d794ee670793263c6d6da5a48a61352">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00439">439</a> 行定义.</p>

</div>
</div>
<a id="adf95fedcd2a528aa0e54b4865220553f" name="adf95fedcd2a528aa0e54b4865220553f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf95fedcd2a528aa0e54b4865220553f">&#9670;&#160;</a></span>on_trade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_trade </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>成交回调 </p>
<p>处理成交回报</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地委托ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平标记 </td></tr>
    <tr><td class="paramname">vol</td><td>成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格</td></tr>
  </table>
  </dd>
</dl>
<p>当有成交发生时调用此函数，更新持仓信息和相关统计数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平标记（0为开仓，1为平仓，2为平今） </td></tr>
    <tr><td class="paramname">vol</td><td>成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格</td></tr>
  </table>
  </dd>
</dl>
<p>当订单成交时调用，首先更新持仓信息，然后将成交信息传递给策略 通过update_position更新持仓状态，并通过策略的on_trade回调函数处理 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01128">1128</a> 行定义.</p>

</div>
</div>
<a id="a5c61fb0db4b2645df23b85025fada9a7" name="a5c61fb0db4b2645df23b85025fada9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c61fb0db4b2645df23b85025fada9a7">&#9670;&#160;</a></span>on_trans_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_trans_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTransData.html">WTSTransData</a> *&#160;</td>
          <td class="paramname"><em>newTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当逐笔成交数据更新时的回调 </p>
<p>处理逐笔成交数据更新并触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>当授权的合约的逐笔成交数据更新时触发此回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的逐笔成交数据时，调用策略的on_transaction回调函数处理 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a6d92f2b024dc60115c2a9ff2e65103e6">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00512">512</a> 行定义.</p>

</div>
</div>
<a id="ab86556731170989deaf8223afc3f59b0" name="ab86556731170989deaf8223afc3f59b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86556731170989deaf8223afc3f59b0">&#9670;&#160;</a></span>on_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::on_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTransData.html">WTSTransData</a> *&#160;</td>
          <td class="paramname"><em>newTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>逐笔成交数据回调 </p>
<p>处理逐笔成交数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>当有订阅的合约有新的逐笔成交数据到来时触发</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>当收到新的逐笔成交数据时，调用on_trans_updated方法处理 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aebacae566647721c7c4462b84dfca5b4">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00501">501</a> 行定义.</p>

</div>
</div>
<a id="ae4968f9ed367c595ce2cfe4ce9f8b985" name="ae4968f9ed367c595ce2cfe4ce9f8b985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4968f9ed367c595ce2cfe4ce9f8b985">&#9670;&#160;</a></span>postTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::postTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUftMocker.html#a69c54d030844fd05177700555ba7194c">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>提交任务到任务队列 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>要提交的任务</td></tr>
  </table>
  </dd>
</dl>
<p>将任务提交到内部任务队列，等待异步处理</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>要提交的任务</td></tr>
  </table>
  </dd>
</dl>
<p>将任务添加到任务队列中，任务队列是线程安全的。 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00143">143</a> 行定义.</p>

</div>
</div>
<a id="ad43d8223a63e34c1a43b1ade2e861c3a" name="ad43d8223a63e34c1a43b1ade2e861c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43d8223a63e34c1a43b1ade2e861c3a">&#9670;&#160;</a></span>procOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UftMocker::procOrder </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理指定订单 </p>
<p>处理委托单</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>处理成功返回true，失败返回false</dd></dl>
<p>处理指定订单，包括模拟成交、撤单等操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地委托单ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>如果委托处理完成返回true，否则返回false</dd></dl>
<p>模拟委托单操作的应答和成交过程 首先检查是否在错误率范围内，如果在错误率范围内则模拟撤单 否则获取最新的Tick数据，并判断委托是否可能成交 如果有成交条件，则生成相应的成交结果并更新委托状态 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01246">1246</a> 行定义.</p>

</div>
</div>
<a id="a10286c31e65f9cfa510b9ccb1f79c31e" name="a10286c31e65f9cfa510b9ccb1f79c31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10286c31e65f9cfa510b9ccb1f79c31e">&#9670;&#160;</a></span>procTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::procTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理任务队列中的任务 </p>
<p>处理内部任务队列中的所有任务，按提交顺序依次执行</p>
<p>从任务队列中取出并执行所有待处理的任务，如果队列为空则直接返回。 使用递归锁保护整个任务处理过程，并在取出单个任务时使用互斥锁确保线程安全。 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00114">114</a> 行定义.</p>

</div>
</div>
<a id="a9e1509a8885e226a573b53a9d59cd3f1" name="a9e1509a8885e226a573b53a9d59cd3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1509a8885e226a573b53a9d59cd3f1">&#9670;&#160;</a></span>stra_buy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a> UftMocker::stra_buy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>买入交易 </p>
<p>买入操作（开多或平空）</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">flag</td><td>下单标志：0-normal，1-fak，2-fok，默认0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>提交的订单本地ID列表</dd></dl>
<p>用于提交买入委托订单，返回生成的订单ID列表</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">flag</td><td>标记，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托ID列表</dd></dl>
<p>实现IUftStraCtx接口的方法，用于执行买入操作 首先检查合约信息和数量有效性，然后根据以下规则处理：</p><ol type="1">
<li>如果有空头持仓，先平仓（根据平仓模式决定平仓方式）</li>
<li>剩余数量再开多仓 该方法会自动处理平仓和开仓的逻辑 </li>
</ol>

<p>重载 <a class="el" href="classIUftStraCtx.html#a4fd161ff52d4b39fdfe9f38bd04bf2ad">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00709">709</a> 行定义.</p>

</div>
</div>
<a id="a0b14656f5386b6213a6661cdfeba631a" name="a0b14656f5386b6213a6661cdfeba631a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b14656f5386b6213a6661cdfeba631a">&#9670;&#160;</a></span>stra_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UftMocker::stra_cancel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>撤销订单 </p>
<p>取消委托</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>撤单是否成功</dd></dl>
<p>用于撤销已提交但未完全成交的订单</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地委托ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>取消是否成功，始终返回true</dd></dl>
<p>实现IUftStraCtx接口的方法，用于取消指定的委托 将取消操作添加到任务队列中异步执行，包括以下步骤：</p><ol type="1">
<li>查找并锁定订单</li>
<li>如果是平仓订单，释放冻结的持仓</li>
<li>记录日志并触发on_order回调</li>
<li>从订单列表中移除该订单 </li>
</ol>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ab29eaeb26129c9ac7224dc2a9e15cb44">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00633">633</a> 行定义.</p>

</div>
</div>
<a id="aa15f8fa21f867d8ad1e8af76ca9e81a3" name="aa15f8fa21f867d8ad1e8af76ca9e81a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15f8fa21f867d8ad1e8af76ca9e81a3">&#9670;&#160;</a></span>stra_cancel_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a> UftMocker::stra_cancel_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>撤销指定合约的所有活跃订单 </p>
<p>取消指定合约的所有委托</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>被撤销订单的本地ID列表</dd></dl>
<p>用于批量撤销指定合约的所有未完全成交的订单</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>被取消的委托ID列表（当前实现中返回空列表）</dd></dl>
<p>实现IUftStraCtx接口的方法，用于取消指定合约的所有未完成委托 遍历所有未完成订单，如果合约代码匹配，则调用stra_cancel方法取消该订单 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a527a2d59f3dc89de15b1c08abb62dc2f">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00680">680</a> 行定义.</p>

</div>
</div>
<a id="a8002fb17cc11e7bb3ec4cb467a34f150" name="a8002fb17cc11e7bb3ec4cb467a34f150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8002fb17cc11e7bb3ec4cb467a34f150">&#9670;&#160;</a></span>stra_enter_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_enter_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>开多仓交易 </p>
<p>开多仓操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码，格式如SSE.600000 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>下单数量 </td></tr>
    <tr><td class="paramname">flag</td><td>下单标志: 0-normal，1-fak，2-fok，默认0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功提交的订单本地ID</dd></dl>
<p>提交开多委托订单，返回生成的订单ID</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">flag</td><td>标记，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托ID，如果委托失败返回0</dd></dl>
<p>实现IUftStraCtx接口的方法，用于执行开多仓操作 首先检查合约信息和数量有效性，然后创建并提交开多仓订单 该方法会异步触发on_entrust回调通知策略委托已提交 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a3cd3aecf080f63f2554d3c32bbd183de">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00857">857</a> 行定义.</p>

</div>
</div>
<a id="af755aba192acae21e4ec196fcdd2c4b4" name="af755aba192acae21e4ec196fcdd2c4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af755aba192acae21e4ec196fcdd2c4b4">&#9670;&#160;</a></span>stra_enter_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_enter_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>开空仓交易 </p>
<p>开空仓操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码，格式如SSE.600000 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>下单数量 </td></tr>
    <tr><td class="paramname">flag</td><td>下单标志: 0-normal，1-fak，2-fok，默认0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功提交的订单本地ID</dd></dl>
<p>提交开空委托订单，返回生成的订单ID</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">flag</td><td>标记，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托ID，如果委托失败返回0</dd></dl>
<p>实现IUftStraCtx接口的方法，用于执行开空仓操作 首先检查合约信息和数量有效性，然后创建并提交开空仓订单 该方法会异步触发on_entrust回调通知策略委托已提交 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a4de97ae31cd0a852723d4e04970544dc">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00909">909</a> 行定义.</p>

</div>
</div>
<a id="a57ef443692088bb95f18b53fd1ae3016" name="a57ef443692088bb95f18b53fd1ae3016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ef443692088bb95f18b53fd1ae3016">&#9670;&#160;</a></span>stra_enum_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double UftMocker::stra_enum_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>枚举指定合约的持仓 </p>
<p>枚举并回调所有持仓信息</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指定合约的持仓量（通常是作为计数器使用）</dd></dl>
<p>枚举指定合约的持仓，主要用于实现策略中的持仓枚举功能</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码，如果为空字符串则枚举所有合约 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>所有枚举合约的总持仓量</dd></dl>
<p>实现IUftStraCtx接口的方法，用于枚举当前所有或指定合约的持仓信息 对于每个合约，会通过策略的on_position回调将持仓详情传递给策略 同时累加计算总持仓量并返回 回调信息包括收盘持仓、可用持仓、新开持仓和新开可用持仓 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a3f9259051849e91af00307d9fbe2f9aa">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01472">1472</a> 行定义.</p>

</div>
</div>
<a id="a03dfc265a143669b643a83132aeb329b" name="a03dfc265a143669b643a83132aeb329b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dfc265a143669b643a83132aeb329b">&#9670;&#160;</a></span>stra_exit_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_exit_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isToday</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平多仓交易 </p>
<p>平多仓操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码，格式如SSE.600000 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>下单数量 </td></tr>
    <tr><td class="paramname">isToday</td><td>是否平今仓，SHFE、INE等上海交易所品种专用 </td></tr>
    <tr><td class="paramname">flag</td><td>下单标志: 0-normal，1-fak，2-fok，默认0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功提交的订单本地ID</dd></dl>
<p>提交平多委托订单，返回生成的订单ID</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">isToday</td><td>是否平今仓，默认为false表示平昨仓 </td></tr>
    <tr><td class="paramname">flag</td><td>标记，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托ID，如果委托失败返回0</dd></dl>
<p>实现IUftStraCtx接口的方法，用于执行平多仓操作 首先检查持仓量是否足够，然后根据平仓模式决定平仓方式 如果不区分平今和平昨，则优先平昨仓，不足部分再平今仓 如果区分平今和平昨，则根据isToday参数决定平仓类型 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a6b25c43de29a0b19efd9bad070c6de18">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00963">963</a> 行定义.</p>

</div>
</div>
<a id="a371afcdbcc32aa313051398f10069ae1" name="a371afcdbcc32aa313051398f10069ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371afcdbcc32aa313051398f10069ae1">&#9670;&#160;</a></span>stra_exit_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_exit_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isToday</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平空仓交易 </p>
<p>执行平空仓操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码，格式如SSE.600000 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>下单数量 </td></tr>
    <tr><td class="paramname">isToday</td><td>是否平今仓，SHFE、INE等上海交易所品种专用 </td></tr>
    <tr><td class="paramname">flag</td><td>下单标志: 0-normal，1-fak，2-fok，默认0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功提交的订单本地ID</dd></dl>
<p>提交平空委托订单，返回生成的订单ID</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">isToday</td><td>是否平今仓 </td></tr>
    <tr><td class="paramname">flag</td><td>标记，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托ID，如果委托失败返回0</dd></dl>
<p>实现IUftStraCtx接口的方法，用于执行平空仓操作 首先检查持仓量是否足够，然后根据平仓模式决定平仓方式 如果不区分平今和平昨，则优先平昨仓，不足部分再平今仓 如果区分平今和平昨，则根据isToday参数决定平仓类型 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#a328edbee57731834e30b70fe3482b056">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01037">1037</a> 行定义.</p>

</div>
</div>
<a id="a2aa8d6e9b8f35c00cfdec015c8326802" name="a2aa8d6e9b8f35c00cfdec015c8326802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa8d6e9b8f35c00cfdec015c8326802">&#9670;&#160;</a></span>stra_get_bars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSKlineSlice.html">WTSKlineSlice</a> * UftMocker::stra_get_bars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取K线切片数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识符，如m1/m5/d1等 </td></tr>
    <tr><td class="paramname">count</td><td>请求的K线数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>K线切片数据对象指针</dd></dl>
<p>获取指定合约的历史K线数据，包含指定数量的最新K线</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期字符串，如"m1"表示1分钟，"d1"表示日线 </td></tr>
    <tr><td class="paramname">count</td><td>请求的K线条数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>K线切片数据对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的K线数据 这里对周期进行解析，分离出基础周期和周期倍数 例如"m5"会被分解为基础周期"m"和倍数"5" </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a400b2915afabcc34c2dee7dfec85fb1f">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01348">1348</a> 行定义.</p>

</div>
</div>
<a id="a05e1c75a11fa4ccba9640d7d4b350f80" name="a05e1c75a11fa4ccba9640d7d4b350f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e1c75a11fa4ccba9640d7d4b350f80">&#9670;&#160;</a></span>stra_get_comminfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSCommodityInfo.html">WTSCommodityInfo</a> * UftMocker::stra_get_comminfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约基础信息 </p>
<p>获取合约信息</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合约基础信息对象指针</dd></dl>
<p>获取指定合约的基础信息，包括合约代码、品种、交易所、授权以及其他属性</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合约信息对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的详细信息 直接调用回放器的get_commodity_info方法获取合约信息 返回的对象包含合约的代码、类型、交易单位、手续费率、交易模式等信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aaae81348795c0f7f95b38ea7b6ff4a99">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01333">1333</a> 行定义.</p>

</div>
</div>
<a id="ae10b6149214e4a56619655a636c3bc7b" name="ae10b6149214e4a56619655a636c3bc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10b6149214e4a56619655a636c3bc7b">&#9670;&#160;</a></span>stra_get_date()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_get_date </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前交易日期 </p>
<p>获取当前日期</p>
<dl class="section return"><dt>返回</dt><dd>当前交易日期，格式YYYYMMDD</dd></dl>
<p>获取当前交易上下文中的日期，一般用于日志和计算</p>
<dl class="section return"><dt>返回</dt><dd>当前日期，格式为YYYYMMDD</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取回测当前的计算日期 返回四位数字格式的日期，如20220305表示2022年3月5日 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ab6de4a2a8ca261074f575b0dbbcf9e1a">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01509">1509</a> 行定义.</p>

</div>
</div>
<a id="ae6c7e021d7fac27b4cd076dcaa9a1dc3" name="ae6c7e021d7fac27b4cd076dcaa9a1dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c7e021d7fac27b4cd076dcaa9a1dc3">&#9670;&#160;</a></span>stra_get_last_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTickData.html">WTSTickData</a> * UftMocker::stra_get_last_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最新Tick数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最新的Tick数据对象指针</dd></dl>
<p>获取指定合约的最新一笔Tick数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最新Tick数据对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的最新市场行情数据 调用回放器的get_last_tick方法获取最新Tick数据 返回的对象包含当前价格、多空档位、成交量等实时市场信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aa90cf95cf271845a8c393313da8a96e9">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01423">1423</a> 行定义.</p>

</div>
</div>
<a id="a567d68634eec841482af2b7cfa657f57" name="a567d68634eec841482af2b7cfa657f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567d68634eec841482af2b7cfa657f57">&#9670;&#160;</a></span>stra_get_local_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double UftMocker::stra_get_local_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取本地持仓量 </p>
<p>获取合约的本地净持仓量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指定合约的本地持仓数量</dd></dl>
<p>获取本地计算的指定合约持仓量，通常用于与交易所持仓做对比</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>净持仓量（多头减去空头）</dd></dl>
<p>实现IUftStraCtx接口的方法，用于返回策略当前本地的净持仓量 计算方式为多头总仓位减去空头总仓位 与 stra_get_position(stdCode, false, 3) 结果相同 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ac1d826f977f82d146024f855308b8d19">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01457">1457</a> 行定义.</p>

</div>
</div>
<a id="a7c3a8a2153ca7534ca8a8d39c87c9045" name="a7c3a8a2153ca7534ca8a8d39c87c9045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3a8a2153ca7534ca8a8d39c87c9045">&#9670;&#160;</a></span>stra_get_order_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSOrdDtlSlice.html">WTSOrdDtlSlice</a> * UftMocker::stra_get_order_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取委托明细切片数据 </p>
<p>获取委托详情切片数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的委托明细数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托明细切片数据对象指针</dd></dl>
<p>获取指定合约的历史委托明细数据，包含指定数量的最新委托明细</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的委托详情数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托详情切片数据对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的委托详情数据 调用回放器的get_order_detail_slice方法获取委托详情数据 委托详情包含了委托价格、委托量、委托方向等详细信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a065e1d904fdf5b2a7fcf3ae6f526b1fe">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01396">1396</a> 行定义.</p>

</div>
</div>
<a id="a27db324d73c9177e7f5df2b5e8e63b82" name="a27db324d73c9177e7f5df2b5e8e63b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27db324d73c9177e7f5df2b5e8e63b82">&#9670;&#160;</a></span>stra_get_order_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSOrdQueSlice.html">WTSOrdQueSlice</a> * UftMocker::stra_get_order_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取委托队列切片数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的委托队列数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托队列切片数据对象指针</dd></dl>
<p>获取指定合约的历史委托队列数据，包含指定数量的最新委托队列</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的委托队列数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托队列切片数据对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的委托队列数据 调用回放器的get_order_queue_slice方法获取委托队列数据 委托队列数据包含了多空双边多档价格及其对应的量信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aabc583b296996944ec9f3ad9325b269f">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01382">1382</a> 行定义.</p>

</div>
</div>
<a id="af14be14492ee692c7c7fbcdc91c17e98" name="af14be14492ee692c7c7fbcdc91c17e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14be14492ee692c7c7fbcdc91c17e98">&#9670;&#160;</a></span>stra_get_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double UftMocker::stra_get_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOnlyValid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>iFlag</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取指定合约的持仓量 </p>
<p>获取合约的持仓量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码，格式如SSE.600000 </td></tr>
    <tr><td class="paramname">bOnlyValid</td><td>是否只获取可用持仓（不包含冻结部分） </td></tr>
    <tr><td class="paramname">iFlag</td><td>持仓方向标记：1-多头，2-空头，3-净头寸（多空对冲后的净持仓） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>指定合约的持仓数量</dd></dl>
<p>获取指定合约的持仓量，可以指定是否只返回可用持仓以及持仓方向</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">bOnlyValid</td><td>是否只返回可用仓位，默认为false表示返回总仓位 </td></tr>
    <tr><td class="paramname">iFlag</td><td>持仓方向标记，1为单返回多头仓位，2为单返回空头仓位，3为多空差额，默认为3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>持仓量</dd></dl>
<p>实现IUftStraCtx接口的方法，用于返回策略当前持有的指定合约的仓位 根据iFlag参数决定返回的是多头、空头还是多空差额 根据bOnlyValid参数决定返回的是总仓位还是可用仓位（总仓位减去冻结仓位） </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a48420eb467018e92e94d735772f41c4c">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01438">1438</a> 行定义.</p>

</div>
</div>
<a id="a2e737ba6a3d46a5bb42cf911c0ebfadf" name="a2e737ba6a3d46a5bb42cf911c0ebfadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e737ba6a3d46a5bb42cf911c0ebfadf">&#9670;&#160;</a></span>stra_get_price()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double UftMocker::stra_get_price </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约当前价格 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前价格</dd></dl>
<p>获取指定合约的当前最新价格，通常是最新成交价</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前价格</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取合约当前最新价格 通过调用回放器的get_cur_price方法获取当前价格 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aad45b26ac1b5e1c2441c9fd2ebfa45f2">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01498">1498</a> 行定义.</p>

</div>
</div>
<a id="a96d10bb6a3cc8a5da4c00a973e2161c2" name="a96d10bb6a3cc8a5da4c00a973e2161c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d10bb6a3cc8a5da4c00a973e2161c2">&#9670;&#160;</a></span>stra_get_secs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_get_secs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前时间秒数 </p>
<p>获取当前秒数</p>
<dl class="section return"><dt>返回</dt><dd>当前时间的秒数部分</dd></dl>
<p>获取当前交易上下文中的秒数部分，用于更精确的时间控制</p>
<dl class="section return"><dt>返回</dt><dd>当前秒数</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取回测当前的秒数信息 返回0-59的秒数值，与当前时间的秒数部分相对应 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#aaf074f861f97eb8b615d5c0e9e882541">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01531">1531</a> 行定义.</p>

</div>
</div>
<a id="a406c47b169ea834f36f18edaa4171270" name="a406c47b169ea834f36f18edaa4171270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406c47b169ea834f36f18edaa4171270">&#9670;&#160;</a></span>stra_get_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTickSlice.html">WTSTickSlice</a> * UftMocker::stra_get_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取Tick切片数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的Tick数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Tick切片数据对象指针</dd></dl>
<p>获取指定合约的历史Tick数据，包含指定数量的最新Tick</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的Tick数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Tick切片数据对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的Tick市场行情数据 调用回放器的get_tick_slice方法获取Tick数据 Tick数据包含了价格、成交量、委托量等市场行情信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a083f393dddfcd3dfe8dd09f14c8380a9">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01368">1368</a> 行定义.</p>

</div>
</div>
<a id="add0ee20334abc39f251cbccbfd2b6aac" name="add0ee20334abc39f251cbccbfd2b6aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0ee20334abc39f251cbccbfd2b6aac">&#9670;&#160;</a></span>stra_get_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::stra_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前交易时间 </p>
<p>获取当前时间</p>
<dl class="section return"><dt>返回</dt><dd>当前交易时间，格式HHMMSS</dd></dl>
<p>获取当前交易上下文中的时间，一般用于限定交易时间范围</p>
<dl class="section return"><dt>返回</dt><dd>当前时间，格式为HHMMSS或HHMM</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取回测当前的原始时间 返回数字格式的时间，如092530表示9点25分30秒或ह点25分 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ae5acb469bf4e7da19f12df52b0a3be88">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01520">1520</a> 行定义.</p>

</div>
</div>
<a id="a696f7b3357c99ad6fed6cbb2711e6d8d" name="a696f7b3357c99ad6fed6cbb2711e6d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696f7b3357c99ad6fed6cbb2711e6d8d">&#9670;&#160;</a></span>stra_get_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTransSlice.html">WTSTransSlice</a> * UftMocker::stra_get_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取逐笔成交切片数据 </p>
<p>获取成交切片数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的逐笔成交数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>逐笔成交切片数据对象指针</dd></dl>
<p>获取指定合约的历史逐笔成交数据，包含指定数量的最新逐笔成交</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的成交数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成交切片数据对象指针</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的成交数据 调用回放器的get_transaction_slice方法获取成交数据 成交数据包含了成交价格、成交量、成交方向等信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a35917e3ceb715444e4aa06d37235102b">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01410">1410</a> 行定义.</p>

</div>
</div>
<a id="ae8cc5f82941a13e61dbdd8cd10ae157b" name="ae8cc5f82941a13e61dbdd8cd10ae157b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cc5f82941a13e61dbdd8cd10ae157b">&#9670;&#160;</a></span>stra_get_undone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double UftMocker::stra_get_undone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取未完成委托数量 </p>
<p>获取未完成委托的数量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>未完成委托数量</dd></dl>
<p>获取指定合约的未完成（未成交）委托数量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>未完成委托的数量，多头为正，空头为负</dd></dl>
<p>实现IUftStraCtx接口的方法，用于获取指定合约的未完成委托数量 遍历所有未完成订单，累加计算指定合约的未成交数量 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a1b7ee39019baa5cde3a41660b52bb9cb">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00607">607</a> 行定义.</p>

</div>
</div>
<a id="a9cd9fd8db52f99fb492ddc437af5e447" name="a9cd9fd8db52f99fb492ddc437af5e447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd9fd8db52f99fb492ddc437af5e447">&#9670;&#160;</a></span>stra_log_debug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_log_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>输出调试级别日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容</td></tr>
  </table>
  </dd>
</dl>
<p>输出策略的调试级别日志，用于记录详细信息，通常在调试时使用</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于输出调试级别的日志 调用WTSLogger的log_dyn_raw方法，将日志写入到strategy模块下当前策略的日志文件中 日志级别为DEBUG，用于记录详细的调试信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ad9fa71b1f1aedc03d0474b8c2c9fa7c6">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01610">1610</a> 行定义.</p>

</div>
</div>
<a id="aae5925a1b644093bb852704ee1cec5a5" name="aae5925a1b644093bb852704ee1cec5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5925a1b644093bb852704ee1cec5a5">&#9670;&#160;</a></span>stra_log_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_log_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>输出错误级别日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容</td></tr>
  </table>
  </dd>
</dl>
<p>输出策略的错误级别日志，用于记录错误信息，例如交易失败等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于输出错误级别的日志 调用WTSLogger的log_dyn_raw方法，将日志写入到strategy模块下当前策略的日志文件中 日志级别为ERROR，用于记录错误信息和异常情况 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a992d4d9318f4c4a7e27024bdcffbd9e8">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01622">1622</a> 行定义.</p>

</div>
</div>
<a id="a25b1dd38e16c329f753ef7e8ba0f42ba" name="a25b1dd38e16c329f753ef7e8ba0f42ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b1dd38e16c329f753ef7e8ba0f42ba">&#9670;&#160;</a></span>stra_log_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_log_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>输出信息级别日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容</td></tr>
  </table>
  </dd>
</dl>
<p>输出策略的信息级别日志，用于记录普通信息，例如交易状态变化等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于输出信息级别的日志 调用WTSLogger的log_dyn_raw方法，将日志写入到strategy模块下当前策略的日志文件中 日志级别为INFO，用于记录普通信息 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a445add638bb9b8c84e9c03c425c57c56">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01598">1598</a> 行定义.</p>

</div>
</div>
<a id="afed7220165228852ce704691a3fca182" name="afed7220165228852ce704691a3fca182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed7220165228852ce704691a3fca182">&#9670;&#160;</a></span>stra_sell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a> UftMocker::stra_sell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>卖出交易 </p>
<p>执行平空仓操作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">flag</td><td>下单标志：0-normal，1-fak，2-fok，默认0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>提交的订单本地ID列表</dd></dl>
<p>用于提交卖出委托订单，返回生成的订单ID列表</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">flag</td><td>标记，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托ID列表，如果委托失败返回空列表</dd></dl>
<p>实现IUftStraCtx接口的方法，用于执行平空仓操作 首先检查持仓量是否足够，然后根据平仓模式决定平仓方式 如果不区分平今和平昨，则优先平昨仓，不足部分再平今仓 如果区分平今和平昨，则根据isToday参数决定平仓类型 </p>

<p>重载 <a class="el" href="classIUftStraCtx.html#aebf350b1b476c2032b809df41781c456">IUftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l00783">783</a> 行定义.</p>

</div>
</div>
<a id="a5c0b3c998cb22f277ef18d08f3f3d0e4" name="a5c0b3c998cb22f277ef18d08f3f3d0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0b3c998cb22f277ef18d08f3f3d0e4">&#9670;&#160;</a></span>stra_sub_order_details()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_sub_order_details </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅委托明细数据 </p>
<p>订阅订单详情数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的委托明细数据，订阅后可以通过on_order_detail回调接收数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于订阅指定合约的订单详情数据 直接调用回放器的sub_order_detail方法进行订阅 订阅后将通过handle_order_detail方法接收订单详情数据 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a2359d40145d1e5be957e143e6992e111">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01574">1574</a> 行定义.</p>

</div>
</div>
<a id="a47540e87d498b01a28fb0e880eaf53b6" name="a47540e87d498b01a28fb0e880eaf53b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47540e87d498b01a28fb0e880eaf53b6">&#9670;&#160;</a></span>stra_sub_order_queues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_sub_order_queues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅委托队列数据 </p>
<p>订阅订单队列数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的委托队列数据，订阅后可以通过on_order_queue回调接收数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于订阅指定合约的订单队列数据 直接调用回放器的sub_order_queue方法进行订阅 订阅后将通过handle_order_queue方法接收订单队列数据 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a8308ae91cf4060710ac11524c24a9873">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01562">1562</a> 行定义.</p>

</div>
</div>
<a id="aa83b6c6a8b142b7cb254da2e56c627c0" name="aa83b6c6a8b142b7cb254da2e56c627c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83b6c6a8b142b7cb254da2e56c627c0">&#9670;&#160;</a></span>stra_sub_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_sub_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅Tick数据 </p>
<p>订阅tick数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的Tick数据，订阅后可以通过on_tick回调接收数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于订阅指定合约的tick数据 首先将合约代码添加到本地订阅列表中，然后通知回放器订阅该合约的tick数据 自从2022.03.01起，增加了本地订阅列表，以便在tick数据回调前进行检查 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#a5eafaadd9aaddb9fd11a2d00826592f8">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01543">1543</a> 行定义.</p>

</div>
</div>
<a id="aa1b33e622a3294496f2224542f172b3b" name="aa1b33e622a3294496f2224542f172b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b33e622a3294496f2224542f172b3b">&#9670;&#160;</a></span>stra_sub_transactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::stra_sub_transactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅逐笔成交数据 </p>
<p>订阅逆回成交数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的逐笔成交数据，订阅后可以通过on_transaction回调接收数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IUftStraCtx接口的方法，用于订阅指定合约的逆回成交数据 直接调用回放器的sub_transaction方法进行订阅 订阅后将通过handle_transaction方法接收成交数据 </p>

<p>实现了 <a class="el" href="classIUftStraCtx.html#ab3cccd15415ddf9546da5d44451853b3">IUftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01586">1586</a> 行定义.</p>

</div>
</div>
<a id="a1d0403941dd029f7e26c45f5faffda21" name="a1d0403941dd029f7e26c45f5faffda21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0403941dd029f7e26c45f5faffda21">&#9670;&#160;</a></span>update_dyn_profit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::update_dyn_profit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>更新动态收益 </p>
<p>更新动态浮动盈亏</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>最新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>根据最新的市场数据更新持仓的动态收益</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>最新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>根据最新的市场行情数据计算当前持仓的浮动盈亏 分别计算多头和空头持仓的盈亏情况 对于多头持仓，使用买一档来计算 对于空头持仓，使用卖一档来计算 并更新每笔明细交易的最大盈利和最大亏损 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01176">1176</a> 行定义.</p>

</div>
</div>
<a id="af040581dfbad9adea966486ee63748cd" name="af040581dfbad9adea966486ee63748cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af040581dfbad9adea966486ee63748cd">&#9670;&#160;</a></span>update_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void UftMocker::update_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>更新持仓信息 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平仓标记 </td></tr>
    <tr><td class="paramname">qty</td><td>数量 </td></tr>
    <tr><td class="paramname">price</td><td>价格，默认为0.0</td></tr>
  </table>
  </dd>
</dl>
<p>根据成交结果更新合约的持仓信息</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头方向 </td></tr>
    <tr><td class="paramname">offset</td><td>开平标记（0为开仓，1为平仓，2为平今） </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格，默认为0.0会使用当前的市场价格</td></tr>
  </table>
  </dd>
</dl>
<p>根据交易信息更新账户持仓状态 不同的offset值对应不同的处理逻辑：</p><ul>
<li>开仓(0): 添加新的持仓明细，更新新开仓量</li>
<li>平仓(1): 优先平收盘前持仓，然后再平新开仓仓，计算平仓盈亏</li>
<li>平今(2): 只平当日新开的仓位，计算平仓盈亏 同时记录交易日志和平仓日志，更新资金信息 </li>
</ul>

<p class="definition">在文件 <a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a> 第 <a class="el" href="UftMocker_8cpp_source.html#l01726">1726</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="ab5fe80527477d3615665768afe88986c" name="ab5fe80527477d3615665768afe88986c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fe80527477d3615665768afe88986c">&#9670;&#160;</a></span>_close_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream UftMocker::_close_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平仓日志流 </p>
<p>存储平仓信息的日志流，用于记录每笔平仓的详细信息 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01101">1101</a> 行定义.</p>

</div>
</div>
<a id="a7509f9633ab5f7e986ec7ffba3ccebc3" name="a7509f9633ab5f7e986ec7ffba3ccebc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7509f9633ab5f7e986ec7ffba3ccebc3">&#9670;&#160;</a></span>_context_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::_context_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01156">1156</a> 行定义.</p>

</div>
</div>
<a id="a2e277763d6fab9e14a2fd72b10b543af" name="a2e277763d6fab9e14a2fd72b10b543af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e277763d6fab9e14a2fd72b10b543af">&#9670;&#160;</a></span>_error_rate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UftMocker::_error_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>错误率设置 </p>
<p>模拟交易的错误率，用于模拟现实交易中可能出现的错误情况，单位为万分之一 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00694">694</a> 行定义.</p>

</div>
</div>
<a id="a02de1e268e424e0ddd354c9c321f5d44" name="a02de1e268e424e0ddd354c9c321f5d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02de1e268e424e0ddd354c9c321f5d44">&#9670;&#160;</a></span>_factory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftMocker.html#a653f4c1567920315b47b7fb79b0b54bc">StraFactInfo</a> UftMocker::_factory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UFT策略工厂实例 </p>
<p>存储当前加载的UFT策略工厂的信息和实例 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00775">775</a> 行定义.</p>

</div>
</div>
<a id="ab12cdaf6e524e508e8040b46ca967879" name="ab12cdaf6e524e508e8040b46ca967879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12cdaf6e524e508e8040b46ca967879">&#9670;&#160;</a></span>_fund_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftMocker.html#a45464aae4e1ace2f9f466e15ca366405">StraFundInfo</a> UftMocker::_fund_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略资金信息 </p>
<p>存储当前策略的资金情况，包括盈亏和手续费 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01153">1153</a> 行定义.</p>

</div>
</div>
<a id="a8e63abbbd43a222d3f5dbff64cfad3c0" name="a8e63abbbd43a222d3f5dbff64cfad3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e63abbbd43a222d3f5dbff64cfad3c0">&#9670;&#160;</a></span>_fund_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream UftMocker::_fund_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>资金日志流 </p>
<p>存储资金变化信息的日志流，用于记录资金的日常变化 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01107">1107</a> 行定义.</p>

</div>
</div>
<a id="a991d3586964063f36305956b95fd9b92" name="a991d3586964063f36305956b95fd9b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991d3586964063f36305956b95fd9b92">&#9670;&#160;</a></span>_match_this_tick</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UftMocker::_match_this_tick</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当前tick撮合标志 </p>
<p>是否在当前tick数据到达时立即进行撮合，true表示立即撮合，false表示延迟撮合 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00700">700</a> 行定义.</p>

</div>
</div>
<a id="aee8af1a927e4e93da6da8ec435c5fdd6" name="aee8af1a927e4e93da6da8ec435c5fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8af1a927e4e93da6da8ec435c5fdd6">&#9670;&#160;</a></span>_mtx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a> UftMocker::_mtx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>线程互斥锁 </p>
<p>用于保护对共享数据的并发访问，确保线程安全 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00788">788</a> 行定义.</p>

</div>
</div>
<a id="a93b2fcfd0004a1f071b3b1325e3945e8" name="a93b2fcfd0004a1f071b3b1325e3945e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b2fcfd0004a1f071b3b1325e3945e8">&#9670;&#160;</a></span>_mtx_control</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a> UftMocker::_mtx_control</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>递归互斥锁 </p>
<p>用于保护对控制数据的并发访问，支持递归锁定，同一线程可以多次获取该锁 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00801">801</a> 行定义.</p>

</div>
</div>
<a id="a7e8f668d850021c131649a040b87850c" name="a7e8f668d850021c131649a040b87850c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8f668d850021c131649a040b87850c">&#9670;&#160;</a></span>_mtx_ords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a> UftMocker::_mtx_ords</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单管理的互斥锁 </p>
<p>用于保护对订单数据的并发访问，支持递归锁定 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00872">872</a> 行定义.</p>

</div>
</div>
<a id="a88d76b0afa2e03f0ac63eefe551d5d63" name="a88d76b0afa2e03f0ac63eefe551d5d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d76b0afa2e03f0ac63eefe551d5d63">&#9670;&#160;</a></span>_orders</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftMocker.html#aca29ae03c9acd16d9f523690c2a26ab9">Orders</a> UftMocker::_orders</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单容器 </p>
<p>存储所有当前活跃的订单，以本地ID为键 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00878">878</a> 行定义.</p>

</div>
</div>
<a id="a074d811c5a8ecaf5dbba6e2f6ec4e282" name="a074d811c5a8ecaf5dbba6e2f6ec4e282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074d811c5a8ecaf5dbba6e2f6ec4e282">&#9670;&#160;</a></span>_pos_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream UftMocker::_pos_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓日志流 </p>
<p>存储持仓变化信息的日志流，用于记录持仓的日常变化 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01113">1113</a> 行定义.</p>

</div>
</div>
<a id="a27a2a1ec1fb7922a4ba4ae4a2a2a74c1" name="a27a2a1ec1fb7922a4ba4ae4a2a2a74c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a2a1ec1fb7922a4ba4ae4a2a2a74c1">&#9670;&#160;</a></span>_pos_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftMocker.html#a74fdc0434f73839c8aaf157af4c10bd0">PositionMap</a> UftMocker::_pos_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓映射容器 </p>
<p>存储所有合约的持仓信息，以标准合约代码为键 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01089">1089</a> 行定义.</p>

</div>
</div>
<a id="a3d3d44e1f3370b3bb655d5a7d25ae46b" name="a3d3d44e1f3370b3bb655d5a7d25ae46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3d44e1f3370b3bb655d5a7d25ae46b">&#9670;&#160;</a></span>_price_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftMocker.html#aaf4e5ac5169311b387d1142ab051b576">PriceMap</a> UftMocker::_price_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>价格映射表 </p>
<p>存储各个合约的当前价格，键为合约代码，值为对应价格 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00712">712</a> 行定义.</p>

</div>
</div>
<a id="af09507d16b2ea6210c653cee490ed865" name="af09507d16b2ea6210c653cee490ed865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09507d16b2ea6210c653cee490ed865">&#9670;&#160;</a></span>_replayer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a>* UftMocker::_replayer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>历史数据回放器指针 </p>
<p>指向历史数据回放器的指针，用于获取回测所需的历史行情数据 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00682">682</a> 行定义.</p>

</div>
</div>
<a id="aab4828872447a8ca8c3566c7a52e16fe" name="aab4828872447a8ca8c3566c7a52e16fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4828872447a8ca8c3566c7a52e16fe">&#9670;&#160;</a></span>_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftStrategy.html">UftStrategy</a>* UftMocker::_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UFT策略实例指针 </p>
<p>指向当前正在进行回测的UFT策略实例 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00781">781</a> 行定义.</p>

</div>
</div>
<a id="af554869084300d5227dac1639c165196" name="af554869084300d5227dac1639c165196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af554869084300d5227dac1639c165196">&#9670;&#160;</a></span>_tasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="classUftMocker.html#a69c54d030844fd05177700555ba7194c">Task</a>&gt; UftMocker::_tasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>任务队列 </p>
<p>存储待处理的任务列表，由postTask方法添加任务，procTask方法处理任务 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00794">794</a> 行定义.</p>

</div>
</div>
<a id="a2392a6d5b1ce2fe3b14f9c8f10668c87" name="a2392a6d5b1ce2fe3b14f9c8f10668c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2392a6d5b1ce2fe3b14f9c8f10668c87">&#9670;&#160;</a></span>_tick_subs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwt__hashset.html">wt_hashset</a>&lt;std::string&gt; UftMocker::_tick_subs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01159">1159</a> 行定义.</p>

</div>
</div>
<a id="a1f56e451de15b544e8e6f3a4e95a6720" name="a1f56e451de15b544e8e6f3a4e95a6720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f56e451de15b544e8e6f3a4e95a6720">&#9670;&#160;</a></span>_trade_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream UftMocker::_trade_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日志流 </p>
<p>存储交易详细信息的日志流，用于记录每笔交易 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l01095">1095</a> 行定义.</p>

</div>
</div>
<a id="a197d52ee213e45a824690bc56bc6f4e6" name="a197d52ee213e45a824690bc56bc6f4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197d52ee213e45a824690bc56bc6f4e6">&#9670;&#160;</a></span>_ud_modified</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UftMocker::_ud_modified</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>用户数据修改标记 </p>
<p>标记用户数据是否被修改，用于决定是否需要持久化 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00897">897</a> 行定义.</p>

</div>
</div>
<a id="a1d59cab79c09ef3ad3831fcb68b1d8e1" name="a1d59cab79c09ef3ad3831fcb68b1d8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d59cab79c09ef3ad3831fcb68b1d8e1">&#9670;&#160;</a></span>_use_newpx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UftMocker::_use_newpx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否使用最新价格标志 </p>
<p>控制是否使用最新价格进行回测撮合，true表示使用最新价格，false表示使用其他价格（如开盘价或收盘价） </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00688">688</a> 行定义.</p>

</div>
</div>
<a id="ac8623451cd87ba2fea88ba57508e01c7" name="ac8623451cd87ba2fea88ba57508e01c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8623451cd87ba2fea88ba57508e01c7">&#9670;&#160;</a></span>_user_datas</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUftMocker.html#ad47f6559cc48ef3cffa711f0584f79bb">StringHashMap</a> UftMocker::_user_datas</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>用户数据容器 </p>
<p>存储策略使用的自定义数据，支持持久化 </p>

<p class="definition">在文件 <a class="el" href="UftMocker_8h_source.html">UftMocker.h</a> 第 <a class="el" href="UftMocker_8h_source.html#l00891">891</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/WtBtCore/<a class="el" href="UftMocker_8h_source.html">UftMocker.h</a></li>
<li>src/WtBtCore/<a class="el" href="UftMocker_8cpp_source.html">UftMocker.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classUftMocker.html">UftMocker</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
