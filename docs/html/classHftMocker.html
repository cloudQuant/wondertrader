<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WonderTrader: HftMocker类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WonderTrader<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">高性能量化交易平台</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classHftMocker.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-types">Protected 类型</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pri-types">Private 类型</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="#pri-attribs">Private 属性</a> &#124;
<a href="classHftMocker-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">HftMocker类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>高频策略回测模拟器类  
 <a href="classHftMocker.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="HftMocker_8h_source.html">HftMocker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHftMocker_1_1__DetailInfo.html">_DetailInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓明细结构体  <a href="structHftMocker_1_1__DetailInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHftMocker_1_1__OrderInfo.html">_OrderInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单信息结构体  <a href="structHftMocker_1_1__OrderInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHftMocker_1_1__PosInfo.html">_PosInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓信息结构体  <a href="structHftMocker_1_1__PosInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHftMocker_1_1__StraFactInfo.html">_StraFactInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息结构  <a href="structHftMocker_1_1__StraFactInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHftMocker_1_1__StraFundInfo.html">_StraFundInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息结构体  <a href="structHftMocker_1_1__StraFundInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a61b7b3644f87bd87ef422e6c27be62ca" id="r_a61b7b3644f87bd87ef422e6c27be62ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a61b7b3644f87bd87ef422e6c27be62ca">HftMocker</a> (<a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *replayer, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIHftStraCtx.html#a83f0f0ed8878ced941cf9eab83320273">name</a>)</td></tr>
<tr class="memdesc:a61b7b3644f87bd87ef422e6c27be62ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">高频策略模拟器构造函数  <br /></td></tr>
<tr class="separator:a61b7b3644f87bd87ef422e6c27be62ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aaf542aed7a59a22867c4dd7e06702" id="r_a04aaf542aed7a59a22867c4dd7e06702"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a04aaf542aed7a59a22867c4dd7e06702">~HftMocker</a> ()</td></tr>
<tr class="memdesc:a04aaf542aed7a59a22867c4dd7e06702"><td class="mdescLeft">&#160;</td><td class="mdescRight">高频策略模拟器析构函数  <br /></td></tr>
<tr class="separator:a04aaf542aed7a59a22867c4dd7e06702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e463735e0a29ff14f6e61a24052eaa" id="r_a18e463735e0a29ff14f6e61a24052eaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a18e463735e0a29ff14f6e61a24052eaa">handle_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *curTick, uint32_t pxType) override</td></tr>
<tr class="memdesc:a18e463735e0a29ff14f6e61a24052eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理Tick行情数据  <br /></td></tr>
<tr class="separator:a18e463735e0a29ff14f6e61a24052eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac45105efbee0b89a0d06d7a38e6578" id="r_afac45105efbee0b89a0d06d7a38e6578"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#afac45105efbee0b89a0d06d7a38e6578">handle_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *curOrdQue) override</td></tr>
<tr class="memdesc:afac45105efbee0b89a0d06d7a38e6578"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理委托队列数据  <br /></td></tr>
<tr class="separator:afac45105efbee0b89a0d06d7a38e6578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7354d2ace0eb3677b49d41cd5cc13d19" id="r_a7354d2ace0eb3677b49d41cd5cc13d19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7354d2ace0eb3677b49d41cd5cc13d19">handle_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *curOrdDtl) override</td></tr>
<tr class="memdesc:a7354d2ace0eb3677b49d41cd5cc13d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理逐笔委托数据  <br /></td></tr>
<tr class="separator:a7354d2ace0eb3677b49d41cd5cc13d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0a4809fa4b427c60a55b2e59cf50a6" id="r_a7b0a4809fa4b427c60a55b2e59cf50a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7b0a4809fa4b427c60a55b2e59cf50a6">handle_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *curTrans) override</td></tr>
<tr class="memdesc:a7b0a4809fa4b427c60a55b2e59cf50a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理逐笔成交数据  <br /></td></tr>
<tr class="separator:a7b0a4809fa4b427c60a55b2e59cf50a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd2aa1d1ed4c2c499a12d0213072455" id="r_a2cd2aa1d1ed4c2c499a12d0213072455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2cd2aa1d1ed4c2c499a12d0213072455">handle_bar_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t times, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:a2cd2aa1d1ed4c2c499a12d0213072455"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理K线周期数据收盘  <br /></td></tr>
<tr class="separator:a2cd2aa1d1ed4c2c499a12d0213072455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae990a5c2e58cf5750eec3cf6943feb33" id="r_ae990a5c2e58cf5750eec3cf6943feb33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae990a5c2e58cf5750eec3cf6943feb33">handle_schedule</a> (uint32_t uDate, uint32_t uTime) override</td></tr>
<tr class="memdesc:ae990a5c2e58cf5750eec3cf6943feb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理定时任务  <br /></td></tr>
<tr class="separator:ae990a5c2e58cf5750eec3cf6943feb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daa29261940a5c85336f4a169817221" id="r_a9daa29261940a5c85336f4a169817221"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a9daa29261940a5c85336f4a169817221">handle_init</a> () override</td></tr>
<tr class="memdesc:a9daa29261940a5c85336f4a169817221"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理模拟器初始化  <br /></td></tr>
<tr class="separator:a9daa29261940a5c85336f4a169817221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14d271745db9601e66fcdd63c1d36e" id="r_aba14d271745db9601e66fcdd63c1d36e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aba14d271745db9601e66fcdd63c1d36e">handle_session_begin</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:aba14d271745db9601e66fcdd63c1d36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易日开始  <br /></td></tr>
<tr class="separator:aba14d271745db9601e66fcdd63c1d36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79bb04408c2a7a68e9daf3e4edd0b16" id="r_ab79bb04408c2a7a68e9daf3e4edd0b16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ab79bb04408c2a7a68e9daf3e4edd0b16">handle_session_end</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:ab79bb04408c2a7a68e9daf3e4edd0b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易日结束  <br /></td></tr>
<tr class="separator:ab79bb04408c2a7a68e9daf3e4edd0b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86669678becea177cf375cc579eaabc6" id="r_a86669678becea177cf375cc579eaabc6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a86669678becea177cf375cc579eaabc6">handle_replay_done</a> () override</td></tr>
<tr class="memdesc:a86669678becea177cf375cc579eaabc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理回放结束  <br /></td></tr>
<tr class="separator:a86669678becea177cf375cc579eaabc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d791cb4eb5f850613ab1900fdd4f0f7" id="r_a6d791cb4eb5f850613ab1900fdd4f0f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a6d791cb4eb5f850613ab1900fdd4f0f7">on_tick_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick) override</td></tr>
<tr class="memdesc:a6d791cb4eb5f850613ab1900fdd4f0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理Tick数据更新  <br /></td></tr>
<tr class="separator:a6d791cb4eb5f850613ab1900fdd4f0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc6649b5858855b5e79efdc9bde58ba" id="r_a0cc6649b5858855b5e79efdc9bde58ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a0cc6649b5858855b5e79efdc9bde58ba">on_ordque_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *newOrdQue) override</td></tr>
<tr class="memdesc:a0cc6649b5858855b5e79efdc9bde58ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理委托队列数据更新  <br /></td></tr>
<tr class="separator:a0cc6649b5858855b5e79efdc9bde58ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbbe3f7f0273f5f8d0dd5dbd80156a7" id="r_a7fbbe3f7f0273f5f8d0dd5dbd80156a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7fbbe3f7f0273f5f8d0dd5dbd80156a7">on_orddtl_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *newOrdDtl) override</td></tr>
<tr class="memdesc:a7fbbe3f7f0273f5f8d0dd5dbd80156a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理逐笔委托数据更新  <br /></td></tr>
<tr class="separator:a7fbbe3f7f0273f5f8d0dd5dbd80156a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ca44777f0a573a49e8206ef9df26b" id="r_a144ca44777f0a573a49e8206ef9df26b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a144ca44777f0a573a49e8206ef9df26b">on_trans_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *newTrans) override</td></tr>
<tr class="memdesc:a144ca44777f0a573a49e8206ef9df26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理逐笔成交数据更新  <br /></td></tr>
<tr class="separator:a144ca44777f0a573a49e8206ef9df26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275d7ef0a12254062bd8464bb9e80303" id="r_a275d7ef0a12254062bd8464bb9e80303"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a275d7ef0a12254062bd8464bb9e80303">on_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick) override</td></tr>
<tr class="memdesc:a275d7ef0a12254062bd8464bb9e80303"><td class="mdescLeft">&#160;</td><td class="mdescRight">实现策略收到Tick数据的回调  <br /></td></tr>
<tr class="separator:a275d7ef0a12254062bd8464bb9e80303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba0819569eb4a76b2b75e65a2bf7da1" id="r_adba0819569eb4a76b2b75e65a2bf7da1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#adba0819569eb4a76b2b75e65a2bf7da1">on_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *newOrdQue) override</td></tr>
<tr class="memdesc:adba0819569eb4a76b2b75e65a2bf7da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">实现策略收到委托队列数据的回调  <br /></td></tr>
<tr class="separator:adba0819569eb4a76b2b75e65a2bf7da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33dbec5a1369440522985fbdde8d728" id="r_ae33dbec5a1369440522985fbdde8d728"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae33dbec5a1369440522985fbdde8d728">on_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *newOrdDtl) override</td></tr>
<tr class="memdesc:ae33dbec5a1369440522985fbdde8d728"><td class="mdescLeft">&#160;</td><td class="mdescRight">实现策略收到逐笔委托数据的回调  <br /></td></tr>
<tr class="separator:ae33dbec5a1369440522985fbdde8d728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e014f9189f7b1f2cfe1db61f770faa" id="r_ae6e014f9189f7b1f2cfe1db61f770faa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae6e014f9189f7b1f2cfe1db61f770faa">on_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *newTrans) override</td></tr>
<tr class="memdesc:ae6e014f9189f7b1f2cfe1db61f770faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">实现策略收到逐笔成交数据的回调  <br /></td></tr>
<tr class="separator:ae6e014f9189f7b1f2cfe1db61f770faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d06e29c19e648097042912e2e47a4d" id="r_a61d06e29c19e648097042912e2e47a4d"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a61d06e29c19e648097042912e2e47a4d">id</a> () override</td></tr>
<tr class="memdesc:a61d06e29c19e648097042912e2e47a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取策略ID  <br /></td></tr>
<tr class="separator:a61d06e29c19e648097042912e2e47a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d647524e23ac3e67ef68b28a848e67" id="r_a98d647524e23ac3e67ef68b28a848e67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a98d647524e23ac3e67ef68b28a848e67">on_init</a> () override</td></tr>
<tr class="memdesc:a98d647524e23ac3e67ef68b28a848e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略初始化回调  <br /></td></tr>
<tr class="separator:a98d647524e23ac3e67ef68b28a848e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d8f8c71a2b3c758908d6680a4e1c62" id="r_ae4d8f8c71a2b3c758908d6680a4e1c62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae4d8f8c71a2b3c758908d6680a4e1c62">on_bar</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t times, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:ae4d8f8c71a2b3c758908d6680a4e1c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线数据回调  <br /></td></tr>
<tr class="separator:ae4d8f8c71a2b3c758908d6680a4e1c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb62cffd1f0ab613f104556ed2f3486b" id="r_adb62cffd1f0ab613f104556ed2f3486b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#adb62cffd1f0ab613f104556ed2f3486b">on_session_begin</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:adb62cffd1f0ab613f104556ed2f3486b"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日开始回调  <br /></td></tr>
<tr class="separator:adb62cffd1f0ab613f104556ed2f3486b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1432ce83a33c5e98d7790ef7eec107f1" id="r_a1432ce83a33c5e98d7790ef7eec107f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1432ce83a33c5e98d7790ef7eec107f1">on_session_end</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:a1432ce83a33c5e98d7790ef7eec107f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日结束回调  <br /></td></tr>
<tr class="separator:a1432ce83a33c5e98d7790ef7eec107f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad707bd83c39287c0c0ac07fa66f23af8" id="r_ad707bd83c39287c0c0ac07fa66f23af8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ad707bd83c39287c0c0ac07fa66f23af8">stra_cancel</a> (uint32_t localid) override</td></tr>
<tr class="memdesc:ad707bd83c39287c0c0ac07fa66f23af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据本地订单ID撤单  <br /></td></tr>
<tr class="separator:ad707bd83c39287c0c0ac07fa66f23af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c21deadc6206531ecebc85e0420bd78" id="r_a6c21deadc6206531ecebc85e0420bd78"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a6c21deadc6206531ecebc85e0420bd78">stra_cancel</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isBuy, double qty=0) override</td></tr>
<tr class="memdesc:a6c21deadc6206531ecebc85e0420bd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">根据合约和方向批量撤单  <br /></td></tr>
<tr class="separator:a6c21deadc6206531ecebc85e0420bd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee5ae15821fd1809d8eccb0ef1976ac" id="r_acee5ae15821fd1809d8eccb0ef1976ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#acee5ae15821fd1809d8eccb0ef1976ac">stra_buy</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, int flag=0, bool bForceClose=false) override</td></tr>
<tr class="memdesc:acee5ae15821fd1809d8eccb0ef1976ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送买入订单  <br /></td></tr>
<tr class="separator:acee5ae15821fd1809d8eccb0ef1976ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0a504cadbeeb05d9d3bfc6ffe991c1" id="r_a9e0a504cadbeeb05d9d3bfc6ffe991c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a9e0a504cadbeeb05d9d3bfc6ffe991c1">stra_sell</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, int flag=0, bool bForceClose=false) override</td></tr>
<tr class="memdesc:a9e0a504cadbeeb05d9d3bfc6ffe991c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">发送卖出订单  <br /></td></tr>
<tr class="separator:a9e0a504cadbeeb05d9d3bfc6ffe991c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca39ae2c7e4511fc36d4d041d66c7b7" id="r_a1ca39ae2c7e4511fc36d4d041d66c7b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSCommodityInfo.html">WTSCommodityInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1ca39ae2c7e4511fc36d4d041d66c7b7">stra_get_comminfo</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a1ca39ae2c7e4511fc36d4d041d66c7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约信息  <br /></td></tr>
<tr class="separator:a1ca39ae2c7e4511fc36d4d041d66c7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af0513f23e1bb7cb901b79928daa62" id="r_ae9af0513f23e1bb7cb901b79928daa62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSKlineSlice.html">WTSKlineSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae9af0513f23e1bb7cb901b79928daa62">stra_get_bars</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t count) override</td></tr>
<tr class="memdesc:ae9af0513f23e1bb7cb901b79928daa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取K线序列数据  <br /></td></tr>
<tr class="separator:ae9af0513f23e1bb7cb901b79928daa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb17f55bae6202f4337043eb70ce0c7" id="r_a4eb17f55bae6202f4337043eb70ce0c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTickSlice.html">WTSTickSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a4eb17f55bae6202f4337043eb70ce0c7">stra_get_ticks</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:a4eb17f55bae6202f4337043eb70ce0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取Tick序列数据  <br /></td></tr>
<tr class="separator:a4eb17f55bae6202f4337043eb70ce0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a4fef2a1e5ffd191e7b60d05b6a4fa" id="r_ae1a4fef2a1e5ffd191e7b60d05b6a4fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSOrdDtlSlice.html">WTSOrdDtlSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae1a4fef2a1e5ffd191e7b60d05b6a4fa">stra_get_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:ae1a4fef2a1e5ffd191e7b60d05b6a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取逐笔委托序列数据  <br /></td></tr>
<tr class="separator:ae1a4fef2a1e5ffd191e7b60d05b6a4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac199e77855db6b88ea9b29215b9e860b" id="r_ac199e77855db6b88ea9b29215b9e860b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSOrdQueSlice.html">WTSOrdQueSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ac199e77855db6b88ea9b29215b9e860b">stra_get_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:ac199e77855db6b88ea9b29215b9e860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取委托队列序列数据  <br /></td></tr>
<tr class="separator:ac199e77855db6b88ea9b29215b9e860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea26718c2a4bf32771db39d2431e6320" id="r_aea26718c2a4bf32771db39d2431e6320"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTransSlice.html">WTSTransSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aea26718c2a4bf32771db39d2431e6320">stra_get_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:aea26718c2a4bf32771db39d2431e6320"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取逐笔成交序列数据  <br /></td></tr>
<tr class="separator:aea26718c2a4bf32771db39d2431e6320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e520aecfd510ce44a23e26418bae6c" id="r_a49e520aecfd510ce44a23e26418bae6c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a49e520aecfd510ce44a23e26418bae6c">stra_get_last_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a49e520aecfd510ce44a23e26418bae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最新的Tick数据  <br /></td></tr>
<tr class="separator:a49e520aecfd510ce44a23e26418bae6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca80698bf51efbf2a919584ee156f05" id="r_abca80698bf51efbf2a919584ee156f05"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#abca80698bf51efbf2a919584ee156f05">stra_get_rawcode</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:abca80698bf51efbf2a919584ee156f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取分月合约代码  <br /></td></tr>
<tr class="separator:abca80698bf51efbf2a919584ee156f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bce905302fb94935472a3a591639f67" id="r_a1bce905302fb94935472a3a591639f67"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1bce905302fb94935472a3a591639f67">stra_get_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool bOnlyValid=false, int flag=3) override</td></tr>
<tr class="memdesc:a1bce905302fb94935472a3a591639f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约持仓量  <br /></td></tr>
<tr class="separator:a1bce905302fb94935472a3a591639f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4206d6b38801282bae1a8fdf7337f2" id="r_a7f4206d6b38801282bae1a8fdf7337f2"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7f4206d6b38801282bae1a8fdf7337f2">stra_get_position_avgpx</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a7f4206d6b38801282bae1a8fdf7337f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约持仓均价  <br /></td></tr>
<tr class="separator:a7f4206d6b38801282bae1a8fdf7337f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272f622b0771d2e3265f5045ac284197" id="r_a272f622b0771d2e3265f5045ac284197"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a272f622b0771d2e3265f5045ac284197">stra_get_position_profit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a272f622b0771d2e3265f5045ac284197"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约持仓盈亏  <br /></td></tr>
<tr class="separator:a272f622b0771d2e3265f5045ac284197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53421109f10c732a70d27d540aaa9d6" id="r_ae53421109f10c732a70d27d540aaa9d6"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae53421109f10c732a70d27d540aaa9d6">stra_get_undone</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:ae53421109f10c732a70d27d540aaa9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约未完成数量  <br /></td></tr>
<tr class="separator:ae53421109f10c732a70d27d540aaa9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c43361df8fb23f77d8a3dad1f73acc" id="r_a10c43361df8fb23f77d8a3dad1f73acc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a10c43361df8fb23f77d8a3dad1f73acc">stra_get_price</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a10c43361df8fb23f77d8a3dad1f73acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取合约当前价格  <br /></td></tr>
<tr class="separator:a10c43361df8fb23f77d8a3dad1f73acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c31ace00eecc5d848105202bf37355" id="r_a48c31ace00eecc5d848105202bf37355"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a48c31ace00eecc5d848105202bf37355">stra_get_date</a> () override</td></tr>
<tr class="memdesc:a48c31ace00eecc5d848105202bf37355"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前交易日期  <br /></td></tr>
<tr class="separator:a48c31ace00eecc5d848105202bf37355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b342d9b678ce0031b419f50fbdd06f2" id="r_a1b342d9b678ce0031b419f50fbdd06f2"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1b342d9b678ce0031b419f50fbdd06f2">stra_get_time</a> () override</td></tr>
<tr class="memdesc:a1b342d9b678ce0031b419f50fbdd06f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前交易时间  <br /></td></tr>
<tr class="separator:a1b342d9b678ce0031b419f50fbdd06f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb712ae4d243e7f83f7e689144734471" id="r_adb712ae4d243e7f83f7e689144734471"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#adb712ae4d243e7f83f7e689144734471">stra_get_secs</a> () override</td></tr>
<tr class="memdesc:adb712ae4d243e7f83f7e689144734471"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前交易时间（秒）  <br /></td></tr>
<tr class="separator:adb712ae4d243e7f83f7e689144734471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e235606406214513cc6348795cce58" id="r_a57e235606406214513cc6348795cce58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a57e235606406214513cc6348795cce58">stra_sub_ticks</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a57e235606406214513cc6348795cce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅Tick行情数据  <br /></td></tr>
<tr class="separator:a57e235606406214513cc6348795cce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0723b5832e9acc3d2ef0e6c431b80c9" id="r_ab0723b5832e9acc3d2ef0e6c431b80c9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ab0723b5832e9acc3d2ef0e6c431b80c9">stra_sub_order_queues</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:ab0723b5832e9acc3d2ef0e6c431b80c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅委托队列数据  <br /></td></tr>
<tr class="separator:ab0723b5832e9acc3d2ef0e6c431b80c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9ed8d695da919910b8dd00456c3083" id="r_a5e9ed8d695da919910b8dd00456c3083"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a5e9ed8d695da919910b8dd00456c3083">stra_sub_order_details</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a5e9ed8d695da919910b8dd00456c3083"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅逐笔委托数据  <br /></td></tr>
<tr class="separator:a5e9ed8d695da919910b8dd00456c3083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9467db36278bb1aea6262e94cf64d1c2" id="r_a9467db36278bb1aea6262e94cf64d1c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a9467db36278bb1aea6262e94cf64d1c2">stra_sub_transactions</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a9467db36278bb1aea6262e94cf64d1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅逐笔成交数据  <br /></td></tr>
<tr class="separator:a9467db36278bb1aea6262e94cf64d1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bca8aab086a650ad2f83c53a4ac63a8" id="r_a2bca8aab086a650ad2f83c53a4ac63a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2bca8aab086a650ad2f83c53a4ac63a8">stra_log_info</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:a2bca8aab086a650ad2f83c53a4ac63a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录信息级别日志  <br /></td></tr>
<tr class="separator:a2bca8aab086a650ad2f83c53a4ac63a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae826802cdc50af57e7a83fb53e562484" id="r_ae826802cdc50af57e7a83fb53e562484"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae826802cdc50af57e7a83fb53e562484">stra_log_debug</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:ae826802cdc50af57e7a83fb53e562484"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录调试级别日志  <br /></td></tr>
<tr class="separator:ae826802cdc50af57e7a83fb53e562484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6589c1b6e29ecd9352f470155733f1" id="r_aeb6589c1b6e29ecd9352f470155733f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aeb6589c1b6e29ecd9352f470155733f1">stra_log_warn</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:aeb6589c1b6e29ecd9352f470155733f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录警告级别日志  <br /></td></tr>
<tr class="separator:aeb6589c1b6e29ecd9352f470155733f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a640ca3f4a39103892f18b56a613310" id="r_a2a640ca3f4a39103892f18b56a613310"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2a640ca3f4a39103892f18b56a613310">stra_log_error</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:a2a640ca3f4a39103892f18b56a613310"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录错误级别日志  <br /></td></tr>
<tr class="separator:a2a640ca3f4a39103892f18b56a613310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278328a822b80c2d64ad1f046f8f6d2f" id="r_a278328a822b80c2d64ad1f046f8f6d2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a278328a822b80c2d64ad1f046f8f6d2f">stra_save_user_data</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *key, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *val) override</td></tr>
<tr class="memdesc:a278328a822b80c2d64ad1f046f8f6d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">保存用户自定义数据  <br /></td></tr>
<tr class="separator:a278328a822b80c2d64ad1f046f8f6d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4415991a646c0581534effbaa2c4fc" id="r_a2b4415991a646c0581534effbaa2c4fc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2b4415991a646c0581534effbaa2c4fc">stra_load_user_data</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *key, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *defVal=&quot;&quot;) override</td></tr>
<tr class="memdesc:a2b4415991a646c0581534effbaa2c4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">读取用户自定义数据  <br /></td></tr>
<tr class="separator:a2b4415991a646c0581534effbaa2c4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029d356e187a5355ad7eddc5af8bb69" id="r_ad029d356e187a5355ad7eddc5af8bb69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ad029d356e187a5355ad7eddc5af8bb69">on_trade</a> (uint32_t localid, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isBuy, double vol, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag)</td></tr>
<tr class="memdesc:ad029d356e187a5355ad7eddc5af8bb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">成交回调  <br /></td></tr>
<tr class="separator:ad029d356e187a5355ad7eddc5af8bb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3011ef0f877f49fcf450d12bc29710f1" id="r_a3011ef0f877f49fcf450d12bc29710f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a3011ef0f877f49fcf450d12bc29710f1">on_order</a> (uint32_t localid, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isBuy, double totalQty, double leftQty, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, bool isCanceled, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag)</td></tr>
<tr class="memdesc:a3011ef0f877f49fcf450d12bc29710f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单状态回调  <br /></td></tr>
<tr class="separator:a3011ef0f877f49fcf450d12bc29710f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34de491dfb14dbe78a67819a93b29294" id="r_a34de491dfb14dbe78a67819a93b29294"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a34de491dfb14dbe78a67819a93b29294">on_channel_ready</a> ()</td></tr>
<tr class="memdesc:a34de491dfb14dbe78a67819a93b29294"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易通道就绪回调  <br /></td></tr>
<tr class="separator:a34de491dfb14dbe78a67819a93b29294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9d7f53110bea5e11a812e58046b18e" id="r_a2b9d7f53110bea5e11a812e58046b18e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2b9d7f53110bea5e11a812e58046b18e">on_entrust</a> (uint32_t localid, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool bSuccess, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag)</td></tr>
<tr class="memdesc:a2b9d7f53110bea5e11a812e58046b18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">委托回报回调  <br /></td></tr>
<tr class="separator:a2b9d7f53110bea5e11a812e58046b18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc9115402558b43383fb7ee310b34a" id="r_a2dfc9115402558b43383fb7ee310b34a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2dfc9115402558b43383fb7ee310b34a">init_hft_factory</a> (<a class="el" href="classWTSVariant.html">WTSVariant</a> *cfg)</td></tr>
<tr class="memdesc:a2dfc9115402558b43383fb7ee310b34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化高频策略工厂  <br /></td></tr>
<tr class="separator:a2dfc9115402558b43383fb7ee310b34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab8a0a44a1f621dd55055b9ac522fa7" id="r_abab8a0a44a1f621dd55055b9ac522fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#abab8a0a44a1f621dd55055b9ac522fa7">install_hook</a> ()</td></tr>
<tr class="memdesc:abab8a0a44a1f621dd55055b9ac522fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">安装钩子函数  <br /></td></tr>
<tr class="separator:abab8a0a44a1f621dd55055b9ac522fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8491bb3b4c34634bde9da6ddfae7fa4" id="r_ad8491bb3b4c34634bde9da6ddfae7fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ad8491bb3b4c34634bde9da6ddfae7fa4">enable_hook</a> (bool bEnabled=true)</td></tr>
<tr class="memdesc:ad8491bb3b4c34634bde9da6ddfae7fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">启用或禁用钩子函数  <br /></td></tr>
<tr class="separator:ad8491bb3b4c34634bde9da6ddfae7fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edcdfd9b34dfcc0ed265fd3a8cee6bb" id="r_a1edcdfd9b34dfcc0ed265fd3a8cee6bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1edcdfd9b34dfcc0ed265fd3a8cee6bb">step_tick</a> ()</td></tr>
<tr class="memdesc:a1edcdfd9b34dfcc0ed265fd3a8cee6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理下一个Tick  <br /></td></tr>
<tr class="separator:a1edcdfd9b34dfcc0ed265fd3a8cee6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIDataSink"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIDataSink')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classIDataSink.html">IDataSink</a></td></tr>
<tr class="memitem:a484f5ab1b9ea855ddbc56cfedf324312 inherit pub_methods_classIDataSink" id="r_a484f5ab1b9ea855ddbc56cfedf324312"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDataSink.html#a484f5ab1b9ea855ddbc56cfedf324312">handle_section_end</a> (uint32_t curTDate, uint32_t curTime)</td></tr>
<tr class="memdesc:a484f5ab1b9ea855ddbc56cfedf324312 inherit pub_methods_classIDataSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易时段结束事件  <br /></td></tr>
<tr class="separator:a484f5ab1b9ea855ddbc56cfedf324312 inherit pub_methods_classIDataSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIHftStraCtx"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIHftStraCtx')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classIHftStraCtx.html">IHftStraCtx</a></td></tr>
<tr class="memitem:a83193fab005fe1bbfce6043da2d9b504 inherit pub_methods_classIHftStraCtx" id="r_a83193fab005fe1bbfce6043da2d9b504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a83193fab005fe1bbfce6043da2d9b504">IHftStraCtx</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classIHftStraCtx.html#a83f0f0ed8878ced941cf9eab83320273">name</a>)</td></tr>
<tr class="memdesc:a83193fab005fe1bbfce6043da2d9b504 inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="separator:a83193fab005fe1bbfce6043da2d9b504 inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acf8795877eb29dc265cca31267d99c inherit pub_methods_classIHftStraCtx" id="r_a8acf8795877eb29dc265cca31267d99c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a8acf8795877eb29dc265cca31267d99c">~IHftStraCtx</a> ()</td></tr>
<tr class="memdesc:a8acf8795877eb29dc265cca31267d99c inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数  <br /></td></tr>
<tr class="separator:a8acf8795877eb29dc265cca31267d99c inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f0f0ed8878ced941cf9eab83320273 inherit pub_methods_classIHftStraCtx" id="r_a83f0f0ed8878ced941cf9eab83320273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a83f0f0ed8878ced941cf9eab83320273">name</a> () <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a></td></tr>
<tr class="memdesc:a83f0f0ed8878ced941cf9eab83320273 inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取策略名称  <br /></td></tr>
<tr class="separator:a83f0f0ed8878ced941cf9eab83320273 inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a802daada69d3a7e615d52dc38e7ba inherit pub_methods_classIHftStraCtx" id="r_a58a802daada69d3a7e615d52dc38e7ba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a58a802daada69d3a7e615d52dc38e7ba">on_bactest_end</a> ()</td></tr>
<tr class="memdesc:a58a802daada69d3a7e615d52dc38e7ba inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">回测结束事件回调  <br /></td></tr>
<tr class="separator:a58a802daada69d3a7e615d52dc38e7ba inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86ea508ea2226e1fc5b2a17e6b6cf31 inherit pub_methods_classIHftStraCtx" id="r_ac86ea508ea2226e1fc5b2a17e6b6cf31"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#ac86ea508ea2226e1fc5b2a17e6b6cf31">stra_enter_long</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, int flag=0)</td></tr>
<tr class="memdesc:ac86ea508ea2226e1fc5b2a17e6b6cf31 inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">下单接口: 开多(买入开仓)  <br /></td></tr>
<tr class="separator:ac86ea508ea2226e1fc5b2a17e6b6cf31 inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb0ba7787bfadb956206ec776f6c7b5 inherit pub_methods_classIHftStraCtx" id="r_a8bb0ba7787bfadb956206ec776f6c7b5"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a8bb0ba7787bfadb956206ec776f6c7b5">stra_enter_short</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, int flag=0)</td></tr>
<tr class="memdesc:a8bb0ba7787bfadb956206ec776f6c7b5 inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">下单接口: 开空(卖出开仓)  <br /></td></tr>
<tr class="separator:a8bb0ba7787bfadb956206ec776f6c7b5 inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7454d4bc12ac127944e5fbd031018909 inherit pub_methods_classIHftStraCtx" id="r_a7454d4bc12ac127944e5fbd031018909"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a7454d4bc12ac127944e5fbd031018909">stra_exit_long</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, bool isToday=false, int flag=0)</td></tr>
<tr class="memdesc:a7454d4bc12ac127944e5fbd031018909 inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">下单接口: 平多(卖出平仓)  <br /></td></tr>
<tr class="separator:a7454d4bc12ac127944e5fbd031018909 inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3f83faeba5ca6e221f7dd3c56ca5cb inherit pub_methods_classIHftStraCtx" id="r_a8d3f83faeba5ca6e221f7dd3c56ca5cb"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#a8d3f83faeba5ca6e221f7dd3c56ca5cb">stra_exit_short</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, bool isToday=false, int flag=0)</td></tr>
<tr class="memdesc:a8d3f83faeba5ca6e221f7dd3c56ca5cb inherit pub_methods_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">下单接口: 平空(买入平仓)  <br /></td></tr>
<tr class="separator:a8d3f83faeba5ca6e221f7dd3c56ca5cb inherit pub_methods_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected 类型</h2></td></tr>
<tr class="memitem:a7ededf4904cc4767a9b13909ca0b1759" id="r_a7ededf4904cc4767a9b13909ca0b1759"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classWTSHashMap.html">WTSHashMap</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7ededf4904cc4767a9b13909ca0b1759">TickCache</a></td></tr>
<tr class="memdesc:a7ededf4904cc4767a9b13909ca0b1759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick缓存类型  <br /></td></tr>
<tr class="separator:a7ededf4904cc4767a9b13909ca0b1759"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:abdfad05d029695eb56523e8bc7ba8438" id="r_abdfad05d029695eb56523e8bc7ba8438"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#abdfad05d029695eb56523e8bc7ba8438">_context_id</a></td></tr>
<tr class="memdesc:abdfad05d029695eb56523e8bc7ba8438"><td class="mdescLeft">&#160;</td><td class="mdescRight">上下文ID  <br /></td></tr>
<tr class="separator:abdfad05d029695eb56523e8bc7ba8438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dfcbde27d69ab31bb18b8819832344" id="r_aa9dfcbde27d69ab31bb18b8819832344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aa9dfcbde27d69ab31bb18b8819832344">_mtx_calc</a></td></tr>
<tr class="memdesc:aa9dfcbde27d69ab31bb18b8819832344"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算互斥锁  <br /></td></tr>
<tr class="separator:aa9dfcbde27d69ab31bb18b8819832344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e836b7def332c4ca8c905b1e2df71ff" id="r_a7e836b7def332c4ca8c905b1e2df71ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gafaa630f2eecc6c68bc508cb484fcd3a3">StdCondVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7e836b7def332c4ca8c905b1e2df71ff">_cond_calc</a></td></tr>
<tr class="memdesc:a7e836b7def332c4ca8c905b1e2df71ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算条件变量  <br /></td></tr>
<tr class="separator:a7e836b7def332c4ca8c905b1e2df71ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa8b2faf7f19ba168344d0de752defc" id="r_a5fa8b2faf7f19ba168344d0de752defc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a5fa8b2faf7f19ba168344d0de752defc">_has_hook</a></td></tr>
<tr class="memdesc:a5fa8b2faf7f19ba168344d0de752defc"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否启用钩子  <br /></td></tr>
<tr class="separator:a5fa8b2faf7f19ba168344d0de752defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c1d3f8020e88636e92163653b4709a" id="r_ae3c1d3f8020e88636e92163653b4709a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae3c1d3f8020e88636e92163653b4709a">_hook_valid</a></td></tr>
<tr class="memdesc:ae3c1d3f8020e88636e92163653b4709a"><td class="mdescLeft">&#160;</td><td class="mdescRight">钩子是否有效  <br /></td></tr>
<tr class="separator:ae3c1d3f8020e88636e92163653b4709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd7701d0e543c7675f90c57095fe450" id="r_a9cd7701d0e543c7675f90c57095fe450"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a9cd7701d0e543c7675f90c57095fe450">_resumed</a></td></tr>
<tr class="memdesc:a9cd7701d0e543c7675f90c57095fe450"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否已恢复标志  <br /></td></tr>
<tr class="separator:a9cd7701d0e543c7675f90c57095fe450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd99f6733f42971519f3ffef4576cad" id="r_afdd99f6733f42971519f3ffef4576cad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwt__hashset.html">wt_hashset</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#afdd99f6733f42971519f3ffef4576cad">_tick_subs</a></td></tr>
<tr class="memdesc:afdd99f6733f42971519f3ffef4576cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick数据订阅列表  <br /></td></tr>
<tr class="separator:afdd99f6733f42971519f3ffef4576cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b286f55446e699340d8cf116cd7fae" id="r_a49b286f55446e699340d8cf116cd7fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#a7ededf4904cc4767a9b13909ca0b1759">TickCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a49b286f55446e699340d8cf116cd7fae">_ticks</a></td></tr>
<tr class="memdesc:a49b286f55446e699340d8cf116cd7fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick缓存  <br /></td></tr>
<tr class="separator:a49b286f55446e699340d8cf116cd7fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classIHftStraCtx"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classIHftStraCtx')"><img src="closed.png" alt="-"/>&#160;Protected 属性 继承自 <a class="el" href="classIHftStraCtx.html">IHftStraCtx</a></td></tr>
<tr class="memitem:ab918b4493ea1270cb1bfd81cf39f6c41 inherit pro_attribs_classIHftStraCtx" id="r_ab918b4493ea1270cb1bfd81cf39f6c41"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIHftStraCtx.html#ab918b4493ea1270cb1bfd81cf39f6c41">_name</a></td></tr>
<tr class="memdesc:ab918b4493ea1270cb1bfd81cf39f6c41 inherit pro_attribs_classIHftStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略名称  <br /></td></tr>
<tr class="separator:ab918b4493ea1270cb1bfd81cf39f6c41 inherit pro_attribs_classIHftStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-types" name="pri-types"></a>
Private 类型</h2></td></tr>
<tr class="memitem:aaee83663162e7bbf8d80043cb7796408" id="r_aaee83663162e7bbf8d80043cb7796408"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aaee83663162e7bbf8d80043cb7796408">Task</a></td></tr>
<tr class="memdesc:aaee83663162e7bbf8d80043cb7796408"><td class="mdescLeft">&#160;</td><td class="mdescRight">任务函数类型定义  <br /></td></tr>
<tr class="separator:aaee83663162e7bbf8d80043cb7796408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f6f54ea67cef5accfe4b1d2e981a06" id="r_a69f6f54ea67cef5accfe4b1d2e981a06"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a69f6f54ea67cef5accfe4b1d2e981a06">PriceMap</a></td></tr>
<tr class="memdesc:a69f6f54ea67cef5accfe4b1d2e981a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">价格映射类型定义  <br /></td></tr>
<tr class="separator:a69f6f54ea67cef5accfe4b1d2e981a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab276208bb5da43beec85694b843d811b" id="r_ab276208bb5da43beec85694b843d811b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHftMocker_1_1__StraFactInfo.html">HftMocker::_StraFactInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ab276208bb5da43beec85694b843d811b">StraFactInfo</a></td></tr>
<tr class="memdesc:ab276208bb5da43beec85694b843d811b"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息结构  <br /></td></tr>
<tr class="separator:ab276208bb5da43beec85694b843d811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b80872ed9baf4f04030622100e9485" id="r_a11b80872ed9baf4f04030622100e9485"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHftMocker_1_1__OrderInfo.html">HftMocker::_OrderInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a11b80872ed9baf4f04030622100e9485">OrderInfo</a></td></tr>
<tr class="memdesc:a11b80872ed9baf4f04030622100e9485"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单信息结构体  <br /></td></tr>
<tr class="separator:a11b80872ed9baf4f04030622100e9485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15befa6883aa3db5a339537e38f0f1e" id="r_aa15befa6883aa3db5a339537e38f0f1e"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classHftMocker.html#a11b80872ed9baf4f04030622100e9485">OrderInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aa15befa6883aa3db5a339537e38f0f1e">OrderInfoPtr</a></td></tr>
<tr class="memdesc:aa15befa6883aa3db5a339537e38f0f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单信息指针类型  <br /></td></tr>
<tr class="separator:aa15befa6883aa3db5a339537e38f0f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7a6ca7ddb642eb7b290d6622f6b66c" id="r_a5a7a6ca7ddb642eb7b290d6622f6b66c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; uint32_t, <a class="el" href="classHftMocker.html#aa15befa6883aa3db5a339537e38f0f1e">OrderInfoPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a5a7a6ca7ddb642eb7b290d6622f6b66c">Orders</a></td></tr>
<tr class="memdesc:a5a7a6ca7ddb642eb7b290d6622f6b66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单容器类型  <br /></td></tr>
<tr class="separator:a5a7a6ca7ddb642eb7b290d6622f6b66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819ce31204edca9060fcaecec75b0152" id="r_a819ce31204edca9060fcaecec75b0152"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classWTSHashMap.html">WTSHashMap</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a819ce31204edca9060fcaecec75b0152">CommodityMap</a></td></tr>
<tr class="memdesc:a819ce31204edca9060fcaecec75b0152"><td class="mdescLeft">&#160;</td><td class="mdescRight">商品映射类型  <br /></td></tr>
<tr class="separator:a819ce31204edca9060fcaecec75b0152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa7628a81e6f43a303036e080890fe6" id="r_a6fa7628a81e6f43a303036e080890fe6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a6fa7628a81e6f43a303036e080890fe6">StringHashMap</a></td></tr>
<tr class="memdesc:a6fa7628a81e6f43a303036e080890fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">字符串映射类型  <br /></td></tr>
<tr class="separator:a6fa7628a81e6f43a303036e080890fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7721eb03b1f99cbf2b1881128a948a7c" id="r_a7721eb03b1f99cbf2b1881128a948a7c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHftMocker_1_1__DetailInfo.html">HftMocker::_DetailInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7721eb03b1f99cbf2b1881128a948a7c">DetailInfo</a></td></tr>
<tr class="memdesc:a7721eb03b1f99cbf2b1881128a948a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓明细结构体  <br /></td></tr>
<tr class="separator:a7721eb03b1f99cbf2b1881128a948a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dc6d3a07bb2c55ca19b5d678982e5e" id="r_af3dc6d3a07bb2c55ca19b5d678982e5e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHftMocker_1_1__PosInfo.html">HftMocker::_PosInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#af3dc6d3a07bb2c55ca19b5d678982e5e">PosInfo</a></td></tr>
<tr class="memdesc:af3dc6d3a07bb2c55ca19b5d678982e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓信息结构体  <br /></td></tr>
<tr class="separator:af3dc6d3a07bb2c55ca19b5d678982e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff87a9e5c69c4f0363ad6e3cd5d202ab" id="r_aff87a9e5c69c4f0363ad6e3cd5d202ab"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, <a class="el" href="classHftMocker.html#af3dc6d3a07bb2c55ca19b5d678982e5e">PosInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aff87a9e5c69c4f0363ad6e3cd5d202ab">PositionMap</a></td></tr>
<tr class="memdesc:aff87a9e5c69c4f0363ad6e3cd5d202ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓映射容器类型  <br /></td></tr>
<tr class="separator:aff87a9e5c69c4f0363ad6e3cd5d202ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d85fa0e6d19557b48c7b19aef519d9c" id="r_a1d85fa0e6d19557b48c7b19aef519d9c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structHftMocker_1_1__StraFundInfo.html">HftMocker::_StraFundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1d85fa0e6d19557b48c7b19aef519d9c">StraFundInfo</a></td></tr>
<tr class="memdesc:a1d85fa0e6d19557b48c7b19aef519d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息结构体  <br /></td></tr>
<tr class="separator:a1d85fa0e6d19557b48c7b19aef519d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:a8d9a6a481b80078bea4cb2e05e312c4e" id="r_a8d9a6a481b80078bea4cb2e05e312c4e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8d9a6a481b80078bea4cb2e05e312c4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a8d9a6a481b80078bea4cb2e05e312c4e">log_debug</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:a8d9a6a481b80078bea4cb2e05e312c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录调试级别日志  <br /></td></tr>
<tr class="separator:a8d9a6a481b80078bea4cb2e05e312c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee2a9df3b28a3b90cc593cc1c4ece1a" id="r_a2ee2a9df3b28a3b90cc593cc1c4ece1a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a2ee2a9df3b28a3b90cc593cc1c4ece1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2ee2a9df3b28a3b90cc593cc1c4ece1a">log_info</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:a2ee2a9df3b28a3b90cc593cc1c4ece1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录信息级别日志  <br /></td></tr>
<tr class="separator:a2ee2a9df3b28a3b90cc593cc1c4ece1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a43d3f166d4f942b66856bd9f3b648" id="r_ae0a43d3f166d4f942b66856bd9f3b648"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae0a43d3f166d4f942b66856bd9f3b648"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae0a43d3f166d4f942b66856bd9f3b648">log_error</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:ae0a43d3f166d4f942b66856bd9f3b648"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录错误级别日志  <br /></td></tr>
<tr class="separator:ae0a43d3f166d4f942b66856bd9f3b648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d2f75badd1bf4ab9c5c0ddb728c84f" id="r_a58d2f75badd1bf4ab9c5c0ddb728c84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a58d2f75badd1bf4ab9c5c0ddb728c84f">postTask</a> (<a class="el" href="classHftMocker.html#aaee83663162e7bbf8d80043cb7796408">Task</a> task)</td></tr>
<tr class="memdesc:a58d2f75badd1bf4ab9c5c0ddb728c84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">将任务添加到任务队列  <br /></td></tr>
<tr class="separator:a58d2f75badd1bf4ab9c5c0ddb728c84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b21aa812ee05cacd35465f012ce202" id="r_aa4b21aa812ee05cacd35465f012ce202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aa4b21aa812ee05cacd35465f012ce202">procTask</a> ()</td></tr>
<tr class="memdesc:aa4b21aa812ee05cacd35465f012ce202"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理任务队列中的任务  <br /></td></tr>
<tr class="separator:aa4b21aa812ee05cacd35465f012ce202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a91c14a56e410510ed954718092ff4e" id="r_a7a91c14a56e410510ed954718092ff4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a7a91c14a56e410510ed954718092ff4e">procOrder</a> (uint32_t localid)</td></tr>
<tr class="memdesc:a7a91c14a56e410510ed954718092ff4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理订单  <br /></td></tr>
<tr class="separator:a7a91c14a56e410510ed954718092ff4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d2f5ade87058e77772c8cdf933f32" id="r_a305d2f5ade87058e77772c8cdf933f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a305d2f5ade87058e77772c8cdf933f32">do_set_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>=0.0, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;)</td></tr>
<tr class="memdesc:a305d2f5ade87058e77772c8cdf933f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置持仓量  <br /></td></tr>
<tr class="separator:a305d2f5ade87058e77772c8cdf933f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac325172459209a198edc4788896f1cf9" id="r_ac325172459209a198edc4788896f1cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ac325172459209a198edc4788896f1cf9">update_dyn_profit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick)</td></tr>
<tr class="memdesc:ac325172459209a198edc4788896f1cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新动态持仓盈亏  <br /></td></tr>
<tr class="separator:ac325172459209a198edc4788896f1cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2689d0cc5b94f4315bf73d94b76059a2" id="r_a2689d0cc5b94f4315bf73d94b76059a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2689d0cc5b94f4315bf73d94b76059a2">dump_outputs</a> ()</td></tr>
<tr class="memdesc:a2689d0cc5b94f4315bf73d94b76059a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出回测结果  <br /></td></tr>
<tr class="separator:a2689d0cc5b94f4315bf73d94b76059a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee44cb92e60c9685bf8148fa39a8bff4" id="r_aee44cb92e60c9685bf8148fa39a8bff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aee44cb92e60c9685bf8148fa39a8bff4">log_trade</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, bool isOpen, uint64_t curTime, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, double fee, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag)</td></tr>
<tr class="memdesc:aee44cb92e60c9685bf8148fa39a8bff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录交易日志  <br /></td></tr>
<tr class="separator:aee44cb92e60c9685bf8148fa39a8bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d5b52f7e95a752532ad6db1c59d4e0" id="r_a42d5b52f7e95a752532ad6db1c59d4e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a42d5b52f7e95a752532ad6db1c59d4e0">log_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint64_t openTime, double openpx, uint64_t closeTime, double closepx, double qty, double profit, double maxprofit, double maxloss, double totalprofit, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *enterTag, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *exitTag)</td></tr>
<tr class="memdesc:a42d5b52f7e95a752532ad6db1c59d4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录平仓日志  <br /></td></tr>
<tr class="separator:a42d5b52f7e95a752532ad6db1c59d4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private 属性</h2></td></tr>
<tr class="memitem:ae9412786a0ff069aff7e500d4e142797" id="r_ae9412786a0ff069aff7e500d4e142797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae9412786a0ff069aff7e500d4e142797">_replayer</a></td></tr>
<tr class="memdesc:ae9412786a0ff069aff7e500d4e142797"><td class="mdescLeft">&#160;</td><td class="mdescRight">历史数据回放器指针  <br /></td></tr>
<tr class="separator:ae9412786a0ff069aff7e500d4e142797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6a528bc6c85a3c9f7d3a364f7ab688" id="r_aef6a528bc6c85a3c9f7d3a364f7ab688"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aef6a528bc6c85a3c9f7d3a364f7ab688">_use_newpx</a></td></tr>
<tr class="memdesc:aef6a528bc6c85a3c9f7d3a364f7ab688"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否使用新价格  <br /></td></tr>
<tr class="separator:aef6a528bc6c85a3c9f7d3a364f7ab688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d03810863dd82f208aa557bc74d9b26" id="r_a8d03810863dd82f208aa557bc74d9b26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a8d03810863dd82f208aa557bc74d9b26">_error_rate</a></td></tr>
<tr class="memdesc:a8d03810863dd82f208aa557bc74d9b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">错误率  <br /></td></tr>
<tr class="separator:a8d03810863dd82f208aa557bc74d9b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933aca33d2ad168cdabcdf22314ff227" id="r_a933aca33d2ad168cdabcdf22314ff227"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a933aca33d2ad168cdabcdf22314ff227">_match_this_tick</a></td></tr>
<tr class="memdesc:a933aca33d2ad168cdabcdf22314ff227"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否在当前Tick撤单  <br /></td></tr>
<tr class="separator:a933aca33d2ad168cdabcdf22314ff227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac126d2a5570a0a4701d3c8c0a3dfcc2c" id="r_ac126d2a5570a0a4701d3c8c0a3dfcc2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#a69f6f54ea67cef5accfe4b1d2e981a06">PriceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ac126d2a5570a0a4701d3c8c0a3dfcc2c">_price_map</a></td></tr>
<tr class="memdesc:ac126d2a5570a0a4701d3c8c0a3dfcc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">合约价格映射表  <br /></td></tr>
<tr class="separator:ac126d2a5570a0a4701d3c8c0a3dfcc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dd4502da42c899f1f9bb27deaa66ce" id="r_a99dd4502da42c899f1f9bb27deaa66ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#ab276208bb5da43beec85694b843d811b">StraFactInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a99dd4502da42c899f1f9bb27deaa66ce">_factory</a></td></tr>
<tr class="memdesc:a99dd4502da42c899f1f9bb27deaa66ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息  <br /></td></tr>
<tr class="separator:a99dd4502da42c899f1f9bb27deaa66ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e14fa9ef3761aa3a6526f791d23c46" id="r_ab7e14fa9ef3761aa3a6526f791d23c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftStrategy.html">HftStrategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ab7e14fa9ef3761aa3a6526f791d23c46">_strategy</a></td></tr>
<tr class="memdesc:ab7e14fa9ef3761aa3a6526f791d23c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">高频策略实例指针  <br /></td></tr>
<tr class="separator:ab7e14fa9ef3761aa3a6526f791d23c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f95b18e413ac45773b41156a06eda6" id="r_af0f95b18e413ac45773b41156a06eda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#af0f95b18e413ac45773b41156a06eda6">_mtx</a></td></tr>
<tr class="memdesc:af0f95b18e413ac45773b41156a06eda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">任务队列互斥锁  <br /></td></tr>
<tr class="separator:af0f95b18e413ac45773b41156a06eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc16df1355f76244a99d7c4270557321" id="r_acc16df1355f76244a99d7c4270557321"><td class="memItemLeft" align="right" valign="top">std::queue&lt; <a class="el" href="classHftMocker.html#aaee83663162e7bbf8d80043cb7796408">Task</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#acc16df1355f76244a99d7c4270557321">_tasks</a></td></tr>
<tr class="memdesc:acc16df1355f76244a99d7c4270557321"><td class="mdescLeft">&#160;</td><td class="mdescRight">任务队列  <br /></td></tr>
<tr class="separator:acc16df1355f76244a99d7c4270557321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53620bc3724f505128af4719ea86bcc0" id="r_a53620bc3724f505128af4719ea86bcc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a53620bc3724f505128af4719ea86bcc0">_mtx_control</a></td></tr>
<tr class="memdesc:a53620bc3724f505128af4719ea86bcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">控制互斥锁  <br /></td></tr>
<tr class="separator:a53620bc3724f505128af4719ea86bcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9eb5d31ed1659235e2ef9dfc076923" id="r_a2d9eb5d31ed1659235e2ef9dfc076923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a2d9eb5d31ed1659235e2ef9dfc076923">_mtx_ords</a></td></tr>
<tr class="memdesc:a2d9eb5d31ed1659235e2ef9dfc076923"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单管理互斥锁  <br /></td></tr>
<tr class="separator:a2d9eb5d31ed1659235e2ef9dfc076923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60eff986515334f2199145699b308eba" id="r_a60eff986515334f2199145699b308eba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#a5a7a6ca7ddb642eb7b290d6622f6b66c">Orders</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a60eff986515334f2199145699b308eba">_orders</a></td></tr>
<tr class="memdesc:a60eff986515334f2199145699b308eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">订单容器  <br /></td></tr>
<tr class="separator:a60eff986515334f2199145699b308eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1441a736663deba894ad6d999c5e4c3e" id="r_a1441a736663deba894ad6d999c5e4c3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#a819ce31204edca9060fcaecec75b0152">CommodityMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a1441a736663deba894ad6d999c5e4c3e">_commodities</a></td></tr>
<tr class="memdesc:a1441a736663deba894ad6d999c5e4c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">商品映射对象  <br /></td></tr>
<tr class="separator:a1441a736663deba894ad6d999c5e4c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84331281febce3bf1092d6518d0288e9" id="r_a84331281febce3bf1092d6518d0288e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#a6fa7628a81e6f43a303036e080890fe6">StringHashMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a84331281febce3bf1092d6518d0288e9">_user_datas</a></td></tr>
<tr class="memdesc:a84331281febce3bf1092d6518d0288e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户自定义数据存储  <br /></td></tr>
<tr class="separator:a84331281febce3bf1092d6518d0288e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5d630cea48dec8f7996bc305a429ea" id="r_aac5d630cea48dec8f7996bc305a429ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aac5d630cea48dec8f7996bc305a429ea">_ud_modified</a></td></tr>
<tr class="separator:aac5d630cea48dec8f7996bc305a429ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da18408ff15aa119798a49a98f16bd2" id="r_a4da18408ff15aa119798a49a98f16bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#aff87a9e5c69c4f0363ad6e3cd5d202ab">PositionMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a4da18408ff15aa119798a49a98f16bd2">_pos_map</a></td></tr>
<tr class="memdesc:a4da18408ff15aa119798a49a98f16bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓映射容器  <br /></td></tr>
<tr class="separator:a4da18408ff15aa119798a49a98f16bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab46e2cc84e56a7a99c830bd843dbd29" id="r_aab46e2cc84e56a7a99c830bd843dbd29"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aab46e2cc84e56a7a99c830bd843dbd29">_trade_logs</a></td></tr>
<tr class="memdesc:aab46e2cc84e56a7a99c830bd843dbd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日志流  <br /></td></tr>
<tr class="separator:aab46e2cc84e56a7a99c830bd843dbd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa741b64e5e856dab86f182f8bc1077ad" id="r_aa741b64e5e856dab86f182f8bc1077ad"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#aa741b64e5e856dab86f182f8bc1077ad">_close_logs</a></td></tr>
<tr class="memdesc:aa741b64e5e856dab86f182f8bc1077ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">平仓日志流  <br /></td></tr>
<tr class="separator:aa741b64e5e856dab86f182f8bc1077ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336b49ced236d6d0ad2629c48c99507b" id="r_a336b49ced236d6d0ad2629c48c99507b"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a336b49ced236d6d0ad2629c48c99507b">_fund_logs</a></td></tr>
<tr class="memdesc:a336b49ced236d6d0ad2629c48c99507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">资金日志流  <br /></td></tr>
<tr class="separator:a336b49ced236d6d0ad2629c48c99507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e871d564410cd643ef330c8746f437" id="r_a82e871d564410cd643ef330c8746f437"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#a82e871d564410cd643ef330c8746f437">_sig_logs</a></td></tr>
<tr class="memdesc:a82e871d564410cd643ef330c8746f437"><td class="mdescLeft">&#160;</td><td class="mdescRight">信号日志流  <br /></td></tr>
<tr class="separator:a82e871d564410cd643ef330c8746f437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aa2ae02207525e03d669d6a5f03726" id="r_ae1aa2ae02207525e03d669d6a5f03726"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ae1aa2ae02207525e03d669d6a5f03726">_pos_logs</a></td></tr>
<tr class="memdesc:ae1aa2ae02207525e03d669d6a5f03726"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓日志流  <br /></td></tr>
<tr class="separator:ae1aa2ae02207525e03d669d6a5f03726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac759fad8fa9d68ef015d654daf232a03" id="r_ac759fad8fa9d68ef015d654daf232a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHftMocker.html#a1d85fa0e6d19557b48c7b19aef519d9c">StraFundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHftMocker.html#ac759fad8fa9d68ef015d654daf232a03">_fund_info</a></td></tr>
<tr class="memdesc:ac759fad8fa9d68ef015d654daf232a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息  <br /></td></tr>
<tr class="separator:ac759fad8fa9d68ef015d654daf232a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>高频策略回测模拟器类 </p>
<p>实现高频策略的回测模拟，继承自IDataSink（数据接收器）和IHftStraCtx（高频策略上下文）接口 主要负责：</p><ol type="1">
<li>接收并处理各类行情数据（Tick、K线、委托队列等）</li>
<li>模拟订单执行和成交流程</li>
<li>记录交易记录和统计策略绩效</li>
<li>管理策略状态和资金情况</li>
<li>提供策略所需的各类接口和数据查询功能 </li>
</ol>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00039">39</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a819ce31204edca9060fcaecec75b0152" name="a819ce31204edca9060fcaecec75b0152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819ce31204edca9060fcaecec75b0152">&#9670;&#160;</a></span>CommodityMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classWTSHashMap.html">WTSHashMap</a>&lt;std::string&gt; <a class="el" href="classHftMocker.html#a819ce31204edca9060fcaecec75b0152">HftMocker::CommodityMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>商品映射类型 </p>
<p>定义商品映射类型，用于存储和检索商品信息 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00984">984</a> 行定义.</p>

</div>
</div>
<a id="a7721eb03b1f99cbf2b1881128a948a7c" name="a7721eb03b1f99cbf2b1881128a948a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7721eb03b1f99cbf2b1881128a948a7c">&#9670;&#160;</a></span>DetailInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHftMocker_1_1__DetailInfo.html">HftMocker::_DetailInfo</a> <a class="el" href="classHftMocker.html#a7721eb03b1f99cbf2b1881128a948a7c">HftMocker::DetailInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓明细结构体 </p>
<p>记录单个持仓明细的详细信息，包括方向、价格、数量及开仓时间等 用于跟踪每个仓位的盈亏状况和历史记录 </p>

</div>
</div>
<a id="a11b80872ed9baf4f04030622100e9485" name="a11b80872ed9baf4f04030622100e9485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b80872ed9baf4f04030622100e9485">&#9670;&#160;</a></span>OrderInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHftMocker_1_1__OrderInfo.html">HftMocker::_OrderInfo</a> <a class="el" href="classHftMocker.html#a11b80872ed9baf4f04030622100e9485">HftMocker::OrderInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单信息结构体 </p>
<p>存储订单的各项基本信息，包括方向、价格、数量等 </p>

</div>
</div>
<a id="aa15befa6883aa3db5a339537e38f0f1e" name="aa15befa6883aa3db5a339537e38f0f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15befa6883aa3db5a339537e38f0f1e">&#9670;&#160;</a></span>OrderInfoPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classHftMocker.html#a11b80872ed9baf4f04030622100e9485">OrderInfo</a>&gt; <a class="el" href="classHftMocker.html#aa15befa6883aa3db5a339537e38f0f1e">HftMocker::OrderInfoPtr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单信息指针类型 </p>
<p>定义一个智能指针类型，指向订单信息结构，实现自动内存管理 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00960">960</a> 行定义.</p>

</div>
</div>
<a id="a5a7a6ca7ddb642eb7b290d6622f6b66c" name="a5a7a6ca7ddb642eb7b290d6622f6b66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7a6ca7ddb642eb7b290d6622f6b66c">&#9670;&#160;</a></span>Orders</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;uint32_t, <a class="el" href="classHftMocker.html#aa15befa6883aa3db5a339537e38f0f1e">OrderInfoPtr</a>&gt; <a class="el" href="classHftMocker.html#a5a7a6ca7ddb642eb7b290d6622f6b66c">HftMocker::Orders</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单容器类型 </p>
<p>定义一个哈希表类型，用于存储本地订单ID到订单信息的映射 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00966">966</a> 行定义.</p>

</div>
</div>
<a id="af3dc6d3a07bb2c55ca19b5d678982e5e" name="af3dc6d3a07bb2c55ca19b5d678982e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3dc6d3a07bb2c55ca19b5d678982e5e">&#9670;&#160;</a></span>PosInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHftMocker_1_1__PosInfo.html">HftMocker::_PosInfo</a> <a class="el" href="classHftMocker.html#af3dc6d3a07bb2c55ca19b5d678982e5e">HftMocker::PosInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓信息结构体 </p>
<p>存储特定合约的总体持仓情况，包括总持仓量、盈亏和明细列表 用于统一管理同一合约的所有仓位和计算盈亏 </p>

</div>
</div>
<a id="aff87a9e5c69c4f0363ad6e3cd5d202ab" name="aff87a9e5c69c4f0363ad6e3cd5d202ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff87a9e5c69c4f0363ad6e3cd5d202ab">&#9670;&#160;</a></span>PositionMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, <a class="el" href="classHftMocker.html#af3dc6d3a07bb2c55ca19b5d678982e5e">PosInfo</a>&gt; <a class="el" href="classHftMocker.html#aff87a9e5c69c4f0363ad6e3cd5d202ab">HftMocker::PositionMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓映射容器类型 </p>
<p>定义一个从合约代码到持仓信息的映射类型 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01137">1137</a> 行定义.</p>

</div>
</div>
<a id="a69f6f54ea67cef5accfe4b1d2e981a06" name="a69f6f54ea67cef5accfe4b1d2e981a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f6f54ea67cef5accfe4b1d2e981a06">&#9670;&#160;</a></span>PriceMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, double&gt; <a class="el" href="classHftMocker.html#a69f6f54ea67cef5accfe4b1d2e981a06">HftMocker::PriceMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>价格映射类型定义 </p>
<p>定义一个哈希表，用于存储合约代码到其当前价格的映射 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00775">775</a> 行定义.</p>

</div>
</div>
<a id="ab276208bb5da43beec85694b843d811b" name="ab276208bb5da43beec85694b843d811b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab276208bb5da43beec85694b843d811b">&#9670;&#160;</a></span>StraFactInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHftMocker_1_1__StraFactInfo.html">HftMocker::_StraFactInfo</a> <a class="el" href="classHftMocker.html#ab276208bb5da43beec85694b843d811b">HftMocker::StraFactInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略工厂信息结构 </p>
<p>存储策略动态链接库和策略工厂相关的信息 </p>

</div>
</div>
<a id="a1d85fa0e6d19557b48c7b19aef519d9c" name="a1d85fa0e6d19557b48c7b19aef519d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d85fa0e6d19557b48c7b19aef519d9c">&#9670;&#160;</a></span>StraFundInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structHftMocker_1_1__StraFundInfo.html">HftMocker::_StraFundInfo</a> <a class="el" href="classHftMocker.html#a1d85fa0e6d19557b48c7b19aef519d9c">HftMocker::StraFundInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略资金信息结构体 </p>
<p>记录策略的整体资金状况，包括总盈亏、浮动盈亏和手续费等 用于策略性能的统计和评估 </p>

</div>
</div>
<a id="a6fa7628a81e6f43a303036e080890fe6" name="a6fa7628a81e6f43a303036e080890fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa7628a81e6f43a303036e080890fe6">&#9670;&#160;</a></span>StringHashMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, std::string&gt; <a class="el" href="classHftMocker.html#a6fa7628a81e6f43a303036e080890fe6">HftMocker::StringHashMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>字符串映射类型 </p>
<p>定义一个字符串哈希表类型，用于存储键值对的字符串数据 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00997">997</a> 行定义.</p>

</div>
</div>
<a id="aaee83663162e7bbf8d80043cb7796408" name="aaee83663162e7bbf8d80043cb7796408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee83663162e7bbf8d80043cb7796408">&#9670;&#160;</a></span>Task</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void()&gt; <a class="el" href="classHftMocker.html#aaee83663162e7bbf8d80043cb7796408">HftMocker::Task</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>任务函数类型定义 </p>
<p>定义一个无参数、无返回值的函数对象类型，用于定义可排队执行的任务 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00658">658</a> 行定义.</p>

</div>
</div>
<a id="a7ededf4904cc4767a9b13909ca0b1759" name="a7ededf4904cc4767a9b13909ca0b1759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ededf4904cc4767a9b13909ca0b1759">&#9670;&#160;</a></span>TickCache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classWTSHashMap.html">WTSHashMap</a>&lt;std::string&gt; <a class="el" href="classHftMocker.html#a7ededf4904cc4767a9b13909ca0b1759">HftMocker::TickCache</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick缓存类型 </p>
<p>定义Tick数据缓存的映射类型 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01264">1264</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a61b7b3644f87bd87ef422e6c27be62ca" name="a61b7b3644f87bd87ef422e6c27be62ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b7b3644f87bd87ef422e6c27be62ca">&#9670;&#160;</a></span>HftMocker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HftMocker::HftMocker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *&#160;</td>
          <td class="paramname"><em>replayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>高频策略模拟器构造函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">replayer</td><td>历史数据回放器指针，提供行情数据和回测环境 </td></tr>
    <tr><td class="paramname">name</td><td>策略名称，用于标识策略实例</td></tr>
  </table>
  </dd>
</dl>
<p>初始化高频策略模拟器，建立与历史数据回放器的连接，初始化各类状态和数据结构</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">replayer</td><td>历史数据回放器指针 </td></tr>
    <tr><td class="paramname">name</td><td>策略名称</td></tr>
  </table>
  </dd>
</dl>
<p>初始化高频策略回测模拟器，设置各项必要的初始参数和内部状态 包括创建商品信息和数据缓存容器，以及生成唯一的上下文ID </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00163">163</a> 行定义.</p>

</div>
</div>
<a id="a04aaf542aed7a59a22867c4dd7e06702" name="a04aaf542aed7a59a22867c4dd7e06702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aaf542aed7a59a22867c4dd7e06702">&#9670;&#160;</a></span>~HftMocker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HftMocker::~HftMocker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>高频策略模拟器析构函数 </p>
<p>清理模拟器资源，释放策略实例和相关数据结构，确保内存安全释放</p>
<p>清理高频策略模拟器的资源，释放策略实例和各种容器 包括从工厂中删除策略实例，释放商品信息和Tick缓存 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00187">187</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a305d2f5ade87058e77772c8cdf933f32" name="a305d2f5ade87058e77772c8cdf933f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305d2f5ade87058e77772c8cdf933f32">&#9670;&#160;</a></span>do_set_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::do_set_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置持仓量 </p>
<p>设置合约持仓量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>持仓数量，正数为多头，负数为空头 </td></tr>
    <tr><td class="paramname">price</td><td>持仓价格，默认为0.0 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>直接设置指定合约的持仓量，不通过交易而是直接修改持仓数据 通常用于以特定持仓量和价格初始化策略的持仓</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>要设置的持仓量，正数表示多头持仓，负数表示空头持仓 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格，默认为0，表示使用当前行情价格 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>该函数处理合约持仓变化的核心逻辑，包括开仓、平仓和持仓量调整 首先获取当前合约的持仓信息和当前时间 如果指定价格为0，则使用当前合约行情的价格 如果新持仓量与当前持仓量相等，则直接返回 根据新的持仓量和当前持仓量的差异，实现开仓、平仓或反手等操作 该函数会更新持仓明细、计算交易费用并记录成交日志 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01751">1751</a> 行定义.</p>

</div>
</div>
<a id="a2689d0cc5b94f4315bf73d94b76059a2" name="a2689d0cc5b94f4315bf73d94b76059a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2689d0cc5b94f4315bf73d94b76059a2">&#9670;&#160;</a></span>dump_outputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::dump_outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>输出回测结果 </p>
<p>输出回测结果到文件</p>
<p>将当前回测的结果数据输出到指定文件或控制台 包括交易记录、收益统计、策略表现细节等信息 通常在回测结束时调用</p>
<p>将回测过程中收集的各种数据输出到CSV和JSON文件中 输出的文件包括：</p><ol type="1">
<li>trades.csv - 交易记录，包含每笔交易的详细信息</li>
<li>closes.csv - 平仓记录，包含每笔平仓的详细信息和盈亏</li>
<li>funds.csv - 资金记录，包含每日的资金状况</li>
<li>signals.csv - 信号记录，包含策略产生的交易信号</li>
<li>positions.csv - 持仓记录，包含每日的持仓情况</li>
<li>ud_[策略名].json - 用户数据，包含策略保存的自定义数据 这些文件保存在输出目录下以策略名命名的文件夹中 </li>
</ol>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01636">1636</a> 行定义.</p>

</div>
</div>
<a id="ad8491bb3b4c34634bde9da6ddfae7fa4" name="ad8491bb3b4c34634bde9da6ddfae7fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8491bb3b4c34634bde9da6ddfae7fa4">&#9670;&#160;</a></span>enable_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::enable_hook </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnabled</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>启用或禁用钩子函数 </p>
<p>启用或禁用计算钩子</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnabled</td><td>是否启用钩子，默认为true</td></tr>
  </table>
  </dd>
</dl>
<p>对挂载到策略实例上的钩子函数进行启用或禁用操作 可以用于暂时暂停策略的回调执行，如在特定情况下防止策略交易</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnabled</td><td>是否启用钩子，默认为true</td></tr>
  </table>
  </dd>
</dl>
<p>设置钩子的有效性状态，并记录日志 钩子机制用于在交易计算过程中插入控制逻辑，实现逻辑更新与执行的分离 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00466">466</a> 行定义.</p>

</div>
</div>
<a id="a2cd2aa1d1ed4c2c499a12d0213072455" name="a2cd2aa1d1ed4c2c499a12d0213072455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd2aa1d1ed4c2c499a12d0213072455">&#9670;&#160;</a></span>handle_bar_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_bar_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理K线周期数据收盘 </p>
<p>处理递过来的K线关闭数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识，如m1（分钟）、d1（日线）等 </td></tr>
    <tr><td class="paramname">times</td><td>周期倒数，例如对于分钟线，1表示1分钟，5表示5分钟 </td></tr>
    <tr><td class="paramname">newBar</td><td>新收盘的K线数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的K线收盘数据处理方法，接收并处理周期性K线收盘数据 当一个周期结束时，将新的K线数据提供给策略进行处理</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期 </td></tr>
    <tr><td class="paramname">times</td><td>周期基数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_bar函数处理K线关闭事件 用于在K线但登完成时触发策略的处理逻辑 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a7b32410de4629a8ea22ff8f9547f9f4d">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00383">383</a> 行定义.</p>

</div>
</div>
<a id="a9daa29261940a5c85336f4a169817221" name="a9daa29261940a5c85336f4a169817221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daa29261940a5c85336f4a169817221">&#9670;&#160;</a></span>handle_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理模拟器初始化 </p>
<p>处理初始化事件</p>
<p>实现IDataSink接口的初始化方法，在回测开始前调用 用于初始化模拟器的各种资源和数据结构，并找到对应策略并调用其on_init方法</p>
<p>先调用on_init函数进行初始化，然后调用on_channel_ready函数通知通道准备完毕 该函数在回测开始前触发，用于策略实例的初始化工作 </p>

<p>实现了 <a class="el" href="classIDataSink.html#aad99745d3af1e228d167db17730e755c">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00393">393</a> 行定义.</p>

</div>
</div>
<a id="a7354d2ace0eb3677b49d41cd5cc13d19" name="a7354d2ace0eb3677b49d41cd5cc13d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7354d2ace0eb3677b49d41cd5cc13d19">&#9670;&#160;</a></span>handle_order_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_order_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *&#160;</td>
          <td class="paramname"><em>curOrdDtl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理逐笔委托数据 </p>
<p>处理递过来的逆序数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">curOrdDtl</td><td>当前的逐笔委托数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的逐笔委托数据处理方法，接收并处理实时逐笔委托数据 逐笔委托数据提供了市场上各个委托的详细信息，在高频交易中用于细粒度分析</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curOrdDtl</td><td>当前逆序数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_order_detail函数处理收到的逆序数据 逆序数据指逻辑上按时间顺序排列的成交条件 </p>

<p>重载 <a class="el" href="classIDataSink.html#ab181668bb73591a42e322dbc4a32ff8a">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00345">345</a> 行定义.</p>

</div>
</div>
<a id="afac45105efbee0b89a0d06d7a38e6578" name="afac45105efbee0b89a0d06d7a38e6578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac45105efbee0b89a0d06d7a38e6578">&#9670;&#160;</a></span>handle_order_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_order_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *&#160;</td>
          <td class="paramname"><em>curOrdQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理委托队列数据 </p>
<p>处理递过来的委托队列数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">curOrdQue</td><td>当前的委托队列数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的委托队列数据处理方法，接收并处理实时委托队列数据 在高频交易回测中，委托队列数据用于分析市场深度和流动性</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curOrdQue</td><td>当前委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_order_queue函数处理收到的委托队列数据 委托队列包含买卖相应价格的等待委托数量 </p>

<p>重载 <a class="el" href="classIDataSink.html#ac0ac665e5f5e9330b4847393a8d5a253">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00357">357</a> 行定义.</p>

</div>
</div>
<a id="a86669678becea177cf375cc579eaabc6" name="a86669678becea177cf375cc579eaabc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86669678becea177cf375cc579eaabc6">&#9670;&#160;</a></span>handle_replay_done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_replay_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理回放结束 </p>
<p>处理回测完成事件</p>
<p>实现IDataSink接口的回放结束方法，在整个回测完成后调用 用于最终清理工作，如输出策略回测结果、生成统计报告等</p>
<p>回测完成时执行的操作，包括输出结果并触发策略的回测结束事件 先调用dump_outputs函数输出回测结果，然后触发on_bactest_end事件 </p>

<p>重载 <a class="el" href="classIDataSink.html#a449d6fee677ebdce5747ec8db2cb1afc">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00438">438</a> 行定义.</p>

</div>
</div>
<a id="ae990a5c2e58cf5750eec3cf6943feb33" name="ae990a5c2e58cf5750eec3cf6943feb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae990a5c2e58cf5750eec3cf6943feb33">&#9670;&#160;</a></span>handle_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_schedule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uDate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理定时任务 </p>
<p>处理定时调度事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uDate</td><td>当前日期，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">uTime</td><td>当前时间，格式HHMMSSmmm，其中mmm为毫秒</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的定时任务处理方法，在回测中按照设定的时间间隔触发 可以用于定时调用策略的on_schedule方法，执行策略定时任务</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uDate</td><td>当前日期，格式YYYYMMDD </td></tr>
    <tr><td class="paramname">uTime</td><td>当前时间，格式HHMMSS或HHMMSS.mmm(毫秒)</td></tr>
  </table>
  </dd>
</dl>
<p>当前实现中已经注释了on_schedule函数的调用 该函数原本用于按时间触发策略的调度事件 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a2e95899a2f5e48dd47cdb89eef7af3d7">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00406">406</a> 行定义.</p>

</div>
</div>
<a id="aba14d271745db9601e66fcdd63c1d36e" name="aba14d271745db9601e66fcdd63c1d36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba14d271745db9601e66fcdd63c1d36e">&#9670;&#160;</a></span>handle_session_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_session_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易日开始 </p>
<p>处理交易日开始事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的交易日开始方法，在每个交易日开始时调用 用于处理交易日开始时的各种初始化和清理工作，并调用策略的on_session_begin方法</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_session_begin函数处理一个交易日开始的事件 用于在新交易日开始时进行必要的初始化工作 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a7518e7f54d3c02334d5bf8039d998ea1">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00417">417</a> 行定义.</p>

</div>
</div>
<a id="ab79bb04408c2a7a68e9daf3e4edd0b16" name="ab79bb04408c2a7a68e9daf3e4edd0b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79bb04408c2a7a68e9daf3e4edd0b16">&#9670;&#160;</a></span>handle_session_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_session_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易日结束 </p>
<p>处理交易日结束事件</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的交易日结束方法，在每个交易日结束时调用 用于处理交易日结束时的清算和统计工作，如计算每日盈亏和清算账户，并调用策略的on_session_end方法</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_session_end函数处理一个交易日结束的事件 用于在交易日结束时进行清算、统计等操作 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a3a8c562237bfa38cf0a789d2156e7f83">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00428">428</a> 行定义.</p>

</div>
</div>
<a id="a18e463735e0a29ff14f6e61a24052eaa" name="a18e463735e0a29ff14f6e61a24052eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e463735e0a29ff14f6e61a24052eaa">&#9670;&#160;</a></span>handle_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>curTick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pxType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理Tick行情数据 </p>
<p>处理递过来的造市数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">curTick</td><td>当前的Tick数据指针 </td></tr>
    <tr><td class="paramname">pxType</td><td>价格类型</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的Tick数据处理方法，接收并处理实时Tick行情数据 在回测中模拟实时行情数据的处理通道，将数据转发给策略实现</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curTick</td><td>当前Tick数据 </td></tr>
    <tr><td class="paramname">pxType</td><td>价格类型</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_tick函数处理收到的造市数据 这是报价处理的入口函数，由外部模块触发 </p>

<p>实现了 <a class="el" href="classIDataSink.html#a49f916a6431df8140564afd06bf20158">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00333">333</a> 行定义.</p>

</div>
</div>
<a id="a7b0a4809fa4b427c60a55b2e59cf50a6" name="a7b0a4809fa4b427c60a55b2e59cf50a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0a4809fa4b427c60a55b2e59cf50a6">&#9670;&#160;</a></span>handle_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::handle_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTransData.html">WTSTransData</a> *&#160;</td>
          <td class="paramname"><em>curTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理逐笔成交数据 </p>
<p>处理递过来的逐笔成交数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">curTrans</td><td>当前的逐笔成交数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的逐笔成交数据处理方法，接收并处理实时逐笔成交数据 逐笔成交数据前市场上的实际成交情况，在高频交易中用于分析市场成交活跃度</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">curTrans</td><td>当前逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_transaction函数处理收到的逐笔成交数据 逐笔成交数据是市场中实际成交的明细信息 </p>

<p>重载 <a class="el" href="classIDataSink.html#a1bdeadd1cef35b1976dfb8dcb8b82aab">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00369">369</a> 行定义.</p>

</div>
</div>
<a id="a61d06e29c19e648097042912e2e47a4d" name="a61d06e29c19e648097042912e2e47a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d06e29c19e648097042912e2e47a4d">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HftMocker::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取策略ID </p>
<p>获取策略上下文ID</p>
<dl class="section return"><dt>返回</dt><dd>策略唯一标识ID</dd></dl>
<p>实现IHftStraCtx接口的id方法，返回策略实例的唯一标识 在系统中用于标识不同的策略实例，特别是在有多个策略实例运行时</p>
<dl class="section return"><dt>返回</dt><dd>当前策略实例的上下文ID</dd></dl>
<p>返回在构造函数中生成的唯一策略上下文ID 该ID用于在回测引擎中唯一标识当前策略实例 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#acc7e0748c86f625dd9e7dab119c8a54c">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00706">706</a> 行定义.</p>

</div>
</div>
<a id="a2dfc9115402558b43383fb7ee310b34a" name="a2dfc9115402558b43383fb7ee310b34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfc9115402558b43383fb7ee310b34a">&#9670;&#160;</a></span>init_hft_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::init_hft_factory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWTSVariant.html">WTSVariant</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>初始化高频策略工厂 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>策略配置对象指针 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>初始化是否成功</dd></dl>
<p>初始化高频策略工厂，加载策略模块并创建策略实例 根据配置加载指定的策略动态链接库，并创建策略工厂和策略实例</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>策略工厂配置参数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>初始化是否成功，true表示成功，false表示失败</dd></dl>
<p>根据配置对象初始化高频交易策略工厂 首先加载配置的交易参数，如是否使用新价成交、错单率等 然后加载指定的策略工厂动态库，获取工厂创建函数和删除函数 最后创建并初始化策略实例 这个函数是策略回测的关键步骤，确保策略模块可以正确运行 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00286">286</a> 行定义.</p>

</div>
</div>
<a id="abab8a0a44a1f621dd55055b9ac522fa7" name="abab8a0a44a1f621dd55055b9ac522fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab8a0a44a1f621dd55055b9ac522fa7">&#9670;&#160;</a></span>install_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::install_hook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>安装钩子函数 </p>
<p>安装计算钩子</p>
<p>安装策略实例的钩子函数，将需要策略回调的函数挂载到策略实例上 包括实现交易回调、成交回调等与策略相关的钩子</p>
<p>标记钩子已经安装，并记录相应日志 安装钩子后，在处理行情数据时会触发钩子机制 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00478">478</a> 行定义.</p>

</div>
</div>
<a id="a42d5b52f7e95a752532ad6db1c59d4e0" name="a42d5b52f7e95a752532ad6db1c59d4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d5b52f7e95a752532ad6db1c59d4e0">&#9670;&#160;</a></span>log_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::log_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>openTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>openpx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>closeTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>closepx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>profit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxprofit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxloss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>totalprofit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>enterTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>exitTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录平仓日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为平多仓位，true为平多，false为平空 </td></tr>
    <tr><td class="paramname">openTime</td><td>开仓时间戳 </td></tr>
    <tr><td class="paramname">openpx</td><td>开仓价格 </td></tr>
    <tr><td class="paramname">closeTime</td><td>平仓时间戳 </td></tr>
    <tr><td class="paramname">closepx</td><td>平仓价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">profit</td><td>当前平仓盈亏 </td></tr>
    <tr><td class="paramname">maxprofit</td><td>最大浮盈 </td></tr>
    <tr><td class="paramname">maxloss</td><td>最大浮亏 </td></tr>
    <tr><td class="paramname">totalprofit</td><td>累计盈亏 </td></tr>
    <tr><td class="paramname">enterTag</td><td>开仓标签 </td></tr>
    <tr><td class="paramname">exitTag</td><td>平仓标签</td></tr>
  </table>
  </dd>
</dl>
<p>记录平仓操作的详细信息，包括开平仓时间、价格、数量及交易盈亏等 这些信息在回测结束后将被用于统计和分析策略性能</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头，true为多头，false为空头 </td></tr>
    <tr><td class="paramname">openTime</td><td>开仓时间 </td></tr>
    <tr><td class="paramname">openpx</td><td>开仓价格 </td></tr>
    <tr><td class="paramname">closeTime</td><td>平仓时间 </td></tr>
    <tr><td class="paramname">closepx</td><td>平仓价格 </td></tr>
    <tr><td class="paramname">qty</td><td>平仓数量 </td></tr>
    <tr><td class="paramname">profit</td><td>平仓盈亏 </td></tr>
    <tr><td class="paramname">maxprofit</td><td>最大浮盈 </td></tr>
    <tr><td class="paramname">maxloss</td><td>最大浮亏 </td></tr>
    <tr><td class="paramname">totalprofit</td><td>总平仓盈亏，默认为0 </td></tr>
    <tr><td class="paramname">enterTag</td><td>开仓标签，默认为空字符串 </td></tr>
    <tr><td class="paramname">exitTag</td><td>平仓标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>将平仓记录添加到平仓日志中 记录的信息包括合约代码、方向、开平时间、价格、数量、盈亏和标签等 这些日志将在回测结束时写入closes.csv文件 平仓日志对于分析策略的盈亏表现和交易效率非常重要 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01730">1730</a> 行定义.</p>

</div>
</div>
<a id="a8d9a6a481b80078bea4cb2e05e312c4e" name="a8d9a6a481b80078bea4cb2e05e312c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9a6a481b80078bea4cb2e05e312c4e">&#9670;&#160;</a></span>log_debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::log_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录调试级别日志 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>参数包类型，支持可变参数模板 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>日志格式化字符串，类似printf格式 </td></tr>
    <tr><td class="paramname">args</td><td>可变参数列表，与format中的占位符对应</td></tr>
  </table>
  </dd>
</dl>
<p>使用fmtlib格式化日志内容，并调用stra_log_debug将调试级别日志写入日志系统 该函数用于记录策略运行中的详细调试信息，便于排错和分析 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00066">66</a> 行定义.</p>

</div>
</div>
<a id="ae0a43d3f166d4f942b66856bd9f3b648" name="ae0a43d3f166d4f942b66856bd9f3b648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a43d3f166d4f942b66856bd9f3b648">&#9670;&#160;</a></span>log_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::log_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录错误级别日志 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>参数包类型，支持可变参数模板 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>日志格式化字符串，类似printf格式 </td></tr>
    <tr><td class="paramname">args</td><td>可变参数列表，与format中的占位符对应</td></tr>
  </table>
  </dd>
</dl>
<p>使用fmtlib格式化日志内容，并调用stra_log_error将错误级别日志写入日志系统 该函数用于记录策略运行中的错误情况，如订单失败、数据异常等 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00096">96</a> 行定义.</p>

</div>
</div>
<a id="a2ee2a9df3b28a3b90cc593cc1c4ece1a" name="a2ee2a9df3b28a3b90cc593cc1c4ece1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee2a9df3b28a3b90cc593cc1c4ece1a">&#9670;&#160;</a></span>log_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::log_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录信息级别日志 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>参数包类型，支持可变参数模板 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>日志格式化字符串，类似printf格式 </td></tr>
    <tr><td class="paramname">args</td><td>可变参数列表，与format中的占位符对应</td></tr>
  </table>
  </dd>
</dl>
<p>使用fmtlib格式化日志内容，并调用stra_log_info将信息级别日志写入日志系统 该函数用于记录策略运行中的一般信息，如定期的状态更新等 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00081">81</a> 行定义.</p>

</div>
</div>
<a id="aee44cb92e60c9685bf8148fa39a8bff4" name="aee44cb92e60c9685bf8148fa39a8bff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee44cb92e60c9685bf8148fa39a8bff4">&#9670;&#160;</a></span>log_trade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::log_trade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>curTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录交易日志 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头交易，true为多头，false为空头 </td></tr>
    <tr><td class="paramname">isOpen</td><td>是否为开仓交易，true为开仓，false为平仓 </td></tr>
    <tr><td class="paramname">curTime</td><td>当前交易时间戳 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">fee</td><td>交易手续费 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签</td></tr>
  </table>
  </dd>
</dl>
<p>记录每笔交易的详细信息，便于后续分析和统计 将交易信息格式化并保存到交易日志中</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头，true为多头，false为空头 </td></tr>
    <tr><td class="paramname">isOpen</td><td>是否为开仓，true为开仓，false为平仓 </td></tr>
    <tr><td class="paramname">curTime</td><td>交易时间 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格 </td></tr>
    <tr><td class="paramname">qty</td><td>成交数量 </td></tr>
    <tr><td class="paramname">fee</td><td>交易手续费 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>将交易记录添加到交易日志中 记录的信息包括合约代码、交易时间、方向、开平标志、价格、数量、手续费和用户标签 这些日志将在回测结束时写入trades.csv文件 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01704">1704</a> 行定义.</p>

</div>
</div>
<a id="ae4d8f8c71a2b3c758908d6680a4e1c62" name="ae4d8f8c71a2b3c758908d6680a4e1c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d8f8c71a2b3c758908d6680a4e1c62">&#9670;&#160;</a></span>on_bar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_bar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K线数据回调 </p>
<p>处理K线数据回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识，如m1（分钟）、d1（日线）等 </td></tr>
    <tr><td class="paramname">times</td><td>周期倒数，例如对于分钟线，1表示1分钟，5表示5分钟 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的on_bar方法，在K线数据更新时调用 用于调用策略实现的on_bar方法，允许策略根据K线数据做出交易决策</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期 </td></tr>
    <tr><td class="paramname">times</td><td>周期基数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>将K线数据事件转发给策略实例的on_bar函数处理 如果策略实例不存在，则不做任何处理 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#ac23dc64794d07d2445cf891513eb49e2">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#aa5d33369fc61f4f1b082908bcdaee4d0">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00454">454</a> 行定义.</p>

</div>
</div>
<a id="a34de491dfb14dbe78a67819a93b29294" name="a34de491dfb14dbe78a67819a93b29294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34de491dfb14dbe78a67819a93b29294">&#9670;&#160;</a></span>on_channel_ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_channel_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易通道就绪回调 </p>
<p>交易通道就绪回调函数</p>
<p>当交易通道就绪可用时的回调方法 通常用于通知策略交易系统已经准备就绪，可以开始发送交易指令</p>
<p>当交易通道准备就绪可以使用时，此函数会被调用 通知策略可以开始正常交易操作 该函数在策略初始化完成或通道重连后触发 </p>

<p>被 <a class="el" href="classExpHftMocker.html#a91412edeaa55665ecb595f284d3edf0f">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01009">1009</a> 行定义.</p>

</div>
</div>
<a id="a2b9d7f53110bea5e11a812e58046b18e" name="a2b9d7f53110bea5e11a812e58046b18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9d7f53110bea5e11a812e58046b18e">&#9670;&#160;</a></span>on_entrust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_entrust </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSuccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>委托回报回调 </p>
<p>委托回报回调函数</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>订单的本地ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">bSuccess</td><td>委托是否成功 </td></tr>
    <tr><td class="paramname">message</td><td>委托返回的消息，通常在失败时包含错误信息 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，用于订单跟踪和识别</td></tr>
  </table>
  </dd>
</dl>
<p>委托返回时的回调方法，当委托被提交后收到交易系统的回报时触发 通知策略委托是否被交易系统接受，如果失败则提供错误原因</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">bSuccess</td><td>委托下单是否成功 </td></tr>
    <tr><td class="paramname">message</td><td>委托回报消息 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>当委托下单得到回报时，此函数会被调用并通知策略 委托回报包含订单是否提交成功及相关的回报信息 策略可以根据委托成功与否调整交易逻辑 </p>

<p>被 <a class="el" href="classExpHftMocker.html#a64b6f794cd71c4ac4c92b8639a29511a">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00997">997</a> 行定义.</p>

</div>
</div>
<a id="a98d647524e23ac3e67ef68b28a848e67" name="a98d647524e23ac3e67ef68b28a848e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d647524e23ac3e67ef68b28a848e67">&#9670;&#160;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略初始化回调 </p>
<p>实现IHftStraCtx接口的on_init方法，在策略初始化时调用 用于调用策略实现的on_init函数，完成策略的初始化操作，如订阅数据、设置参数等</p>
<p>触发策略实例的on_init函数进行初始化 如果策略实例存在，调用其on_init函数进行策略初始化 策略可以在此函数中设置各种初始参数和状态 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a5b0f47d9c3cbb909ad48fddfb332839f">IHftStraCtx</a>.</p>

<p>被 <a class="el" href="classExpHftMocker.html#a179ccc00c428877ec88610ace455ab22">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00717">717</a> 行定义.</p>

</div>
</div>
<a id="a7fbbe3f7f0273f5f8d0dd5dbd80156a7" name="a7fbbe3f7f0273f5f8d0dd5dbd80156a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbbe3f7f0273f5f8d0dd5dbd80156a7">&#9670;&#160;</a></span>on_orddtl_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_orddtl_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *&#160;</td>
          <td class="paramname"><em>newOrdDtl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理逐笔委托数据更新 </p>
<p>逆序数据更新时触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的逐笔委托数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的逐笔委托数据更新方法，在逐笔委托数据更新时调用 用于处理逐笔委托数据更新后的内部逻辑</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的逆序数据</td></tr>
  </table>
  </dd>
</dl>
<p>如果策略实例存在，则调用策略的on_order_detail函数 将逆序数据转发给策略对象处理 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#a63f0b7ca833e449ad42a1699f062045c">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#a08c48c7e639cb1fb54266d8209a5adf7">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00669">669</a> 行定义.</p>

</div>
</div>
<a id="a3011ef0f877f49fcf450d12bc29710f1" name="a3011ef0f877f49fcf450d12bc29710f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3011ef0f877f49fcf450d12bc29710f1">&#9670;&#160;</a></span>on_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_order </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBuy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>totalQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>leftQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCanceled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单状态回调 </p>
<p>订单状态变化回调函数</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>订单的本地ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">isBuy</td><td>是否为买入订单，true为买入，false为卖出 </td></tr>
    <tr><td class="paramname">totalQty</td><td>订单总数量 </td></tr>
    <tr><td class="paramname">leftQty</td><td>剩余未成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>订单价格 </td></tr>
    <tr><td class="paramname">isCanceled</td><td>订单是否已撤销 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，用于订单跟踪和识别</td></tr>
  </table>
  </dd>
</dl>
<p>订单状态变化时的回调方法，当订单状态发生变化时触发 如订单提交、部分成交、全部成交或被撤销时都会触发此回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isBuy</td><td>是否为买单，true为买单，false为卖单 </td></tr>
    <tr><td class="paramname">totalQty</td><td>订单总数量 </td></tr>
    <tr><td class="paramname">leftQty</td><td>剩余未成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格 </td></tr>
    <tr><td class="paramname">isCanceled</td><td>是否已撤单，默认为false </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>当订单状态发生变化时，此函数会被调用并将订单状态变化通知给策略 当订单成交、撤单或部分成交时都会触发此回调 策略可以基于该回调函数捕捉订单状态变化并进行相应处理 </p>

<p>被 <a class="el" href="classExpHftMocker.html#aecdfb9ae8f3de32f04145e52c99475f0">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00959">959</a> 行定义.</p>

</div>
</div>
<a id="ae33dbec5a1369440522985fbdde8d728" name="ae33dbec5a1369440522985fbdde8d728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33dbec5a1369440522985fbdde8d728">&#9670;&#160;</a></span>on_order_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_order_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *&#160;</td>
          <td class="paramname"><em>newOrdDtl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>实现策略收到逐笔委托数据的回调 </p>
<p>处理逆序数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的逐笔委托数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的逐笔委托数据回调方法，在策略订阅的合约收到新逐笔委托数据时触发 调用到策略实现的on_order_detail方法，允许策略根据逐笔委托进行更精细的市场分析</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdDtl</td><td>新的逆序数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_orddtl_updated函数进行进一步处理 这是逆序数据处理的入口函数 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#aa22b958a190305017cac0d0500dfdeb9">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00657">657</a> 行定义.</p>

</div>
</div>
<a id="adba0819569eb4a76b2b75e65a2bf7da1" name="adba0819569eb4a76b2b75e65a2bf7da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba0819569eb4a76b2b75e65a2bf7da1">&#9670;&#160;</a></span>on_order_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_order_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *&#160;</td>
          <td class="paramname"><em>newOrdQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>实现策略收到委托队列数据的回调 </p>
<p>处理委托队列数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的委托队列数据回调方法，在策略订阅的合约收到新委托队列数据时触发 调用到策略实现的on_order_queue方法，允许策略根据委托队列信息分析市场深度</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_ordque_updated函数进行进一步处理 这是委托队列数据处理的入口函数 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a7fe60ba3dba84e4d494b790a61b97de4">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00632">632</a> 行定义.</p>

</div>
</div>
<a id="a0cc6649b5858855b5e79efdc9bde58ba" name="a0cc6649b5858855b5e79efdc9bde58ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc6649b5858855b5e79efdc9bde58ba">&#9670;&#160;</a></span>on_ordque_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_ordque_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *&#160;</td>
          <td class="paramname"><em>newOrdQue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理委托队列数据更新 </p>
<p>委托队列数据更新时触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的委托队列数据更新方法，在委托队列数据更新时调用 用于处理委托队列数据更新后的内部逻辑</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newOrdQue</td><td>新的委托队列数据</td></tr>
  </table>
  </dd>
</dl>
<p>如果策略实例存在，则调用策略的on_order_queue函数 将委托队列数据转发给策略对象处理 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#ac02bbe0848db9aa11258b17881ebde88">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#a4a07f7cff2cab521ebd09b2188709887">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00644">644</a> 行定义.</p>

</div>
</div>
<a id="adb62cffd1f0ab613f104556ed2f3486b" name="adb62cffd1f0ab613f104556ed2f3486b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb62cffd1f0ab613f104556ed2f3486b">&#9670;&#160;</a></span>on_session_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_session_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日开始回调 </p>
<p>交易日开始时调用的函数</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的on_session_begin方法，在每个交易日开始时调用 用于调用策略实现的on_session_begin方法，让策略有机会在新交易日开始时进行必要的初始化</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日开始时执行的操作，包括：</p><ol type="1">
<li>重置所有标的冻结持仓为零，解除前一交易日的冻结持仓</li>
<li>记录持仓重置日志</li>
<li>触发策略的on_session_begin回调 这是实现T+1交易规则的关键函数之一 </li>
</ol>

<p>重载 <a class="el" href="classIHftStraCtx.html#a81f238e832996be135c6dfdbd488a287">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#a2f29c3e3e12f472241fc9b1507a57b99">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00732">732</a> 行定义.</p>

</div>
</div>
<a id="a1432ce83a33c5e98d7790ef7eec107f1" name="a1432ce83a33c5e98d7790ef7eec107f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1432ce83a33c5e98d7790ef7eec107f1">&#9670;&#160;</a></span>on_session_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_session_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日结束回调 </p>
<p>交易日结束时调用的函数</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的on_session_end方法，在每个交易日结束时调用 用于调用策略实现的on_session_end方法，让策略有机会在交易日结束时进行清算和统计工作</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日结束时执行的操作，包括：</p><ol type="1">
<li>统计各标的的平仓盈亏和浮动盈亏</li>
<li>将非空持仓的标的信息记录到持仓日志</li>
<li>将资金信息记录到资金日志，包括平仓盈亏、浮动盈亏、动态权盈和手续费</li>
<li>触发策略的on_session_end回调 这个函数主要用于每日结束时的持仓和资金统计，以及日志记录 </li>
</ol>

<p>重载 <a class="el" href="classIHftStraCtx.html#ab22715fbe495b0bb6eabe5230b8786f1">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#a207e5e1f811f5504b3e70992bee3f91f">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00760">760</a> 行定义.</p>

</div>
</div>
<a id="a275d7ef0a12254062bd8464bb9e80303" name="a275d7ef0a12254062bd8464bb9e80303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275d7ef0a12254062bd8464bb9e80303">&#9670;&#160;</a></span>on_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>实现策略收到Tick数据的回调 </p>
<p>处理Tick数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的Tick数据回调方法，在策略订阅的合约收到新Tick数据时触发 调用到策略实现的on_tick方法，允许策略根据Tick数据做出交易决策</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>实现完整的Tick数据处理逻辑：</p><ol type="1">
<li>更新合约最新价格和动态盈亏</li>
<li>根据_match_this_tick选项决定处理顺序：<ul>
<li>如果为true，先触发策略的on_tick回调，再处理订单</li>
<li>如果为false，先处理订单，再触发策略的on_tick回调</li>
</ul>
</li>
<li>支持钩子机制，实现计算线程和数据线程的分离同步 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a05a76d1fe356ef9d614c82b79da9ff27">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00520">520</a> 行定义.</p>

</div>
</div>
<a id="a6d791cb4eb5f850613ab1900fdd4f0f7" name="a6d791cb4eb5f850613ab1900fdd4f0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d791cb4eb5f850613ab1900fdd4f0f7">&#9670;&#160;</a></span>on_tick_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_tick_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理Tick数据更新 </p>
<p>Tick数据更新时触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的Tick数据更新方法，在Tick数据更新时调用 与handle_tick不同，该方法负责处理更新的内部逻辑，如更新日盈亏、海面表数据等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>检查合约是否在订阅列表中，如果在则调用策略的on_tick函数 这是将Tick数据传递给策略进行处理的关键函数 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#ad73fcab074f80eedd97519bf18a9c46e">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#a0ad7ccbe666ddd8e6693305dc665d16f">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00615">615</a> 行定义.</p>

</div>
</div>
<a id="ad029d356e187a5355ad7eddc5af8bb69" name="ad029d356e187a5355ad7eddc5af8bb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad029d356e187a5355ad7eddc5af8bb69">&#9670;&#160;</a></span>on_trade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_trade </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBuy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>vol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>成交回调 </p>
<p>订单成交回调函数</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>订单的本地ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">isBuy</td><td>是否为买入成交，true为买入，false为卖出 </td></tr>
    <tr><td class="paramname">vol</td><td>成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，用于订单跟踪和识别</td></tr>
  </table>
  </dd>
</dl>
<p>订单成交时的回调方法，当订单在回测中被操作成交时触发 用于处理订单成交后的操作，如更新持仓、记录成交详情等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isBuy</td><td>是否为买单成交，true为买单，false为卖单 </td></tr>
    <tr><td class="paramname">vol</td><td>成交数量 </td></tr>
    <tr><td class="paramname">price</td><td>成交价格 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>当订单成交时，此函数会被调用并处理成交后的持仓变化 首先获取当前合约的持仓信息，计算成交后的最新持仓量 然后将成交信息通知给策略实例 </p>

<p>被 <a class="el" href="classExpHftMocker.html#a7401a29151268d40cde37ca944f520ca">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00977">977</a> 行定义.</p>

</div>
</div>
<a id="a144ca44777f0a573a49e8206ef9df26b" name="a144ca44777f0a573a49e8206ef9df26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144ca44777f0a573a49e8206ef9df26b">&#9670;&#160;</a></span>on_trans_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_trans_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTransData.html">WTSTransData</a> *&#160;</td>
          <td class="paramname"><em>newTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理逐笔成交数据更新 </p>
<p>逐笔成交数据更新时触发策略回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的逐笔成交数据更新方法，在逐笔成交数据更新时调用 用于处理逐笔成交数据更新后的内部逻辑</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>如果策略实例存在，则调用策略的on_transaction函数 将逐笔成交数据转发给策略对象处理 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#a46e9d8138c75960742d2bdaaa517605f">IHftStraCtx</a> .</p>

<p>被 <a class="el" href="classExpHftMocker.html#a48bb66500f744f529a7accd58dff3e5a">ExpHftMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00694">694</a> 行定义.</p>

</div>
</div>
<a id="ae6e014f9189f7b1f2cfe1db61f770faa" name="ae6e014f9189f7b1f2cfe1db61f770faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e014f9189f7b1f2cfe1db61f770faa">&#9670;&#160;</a></span>on_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::on_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTransData.html">WTSTransData</a> *&#160;</td>
          <td class="paramname"><em>newTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>实现策略收到逐笔成交数据的回调 </p>
<p>处理逐笔成交数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的逐笔成交数据回调方法，在策略订阅的合约收到新逐笔成交数据时触发 调用到策略实现的on_transaction方法，允许策略根据成交信息分析市场活跃度</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTrans</td><td>新的逐笔成交数据</td></tr>
  </table>
  </dd>
</dl>
<p>调用on_trans_updated函数进行进一步处理 这是逐笔成交数据处理的入口函数 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a94556c7ef3b4a1ffc43be1435c2f2cf2">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00682">682</a> 行定义.</p>

</div>
</div>
<a id="a58d2f75badd1bf4ab9c5c0ddb728c84f" name="a58d2f75badd1bf4ab9c5c0ddb728c84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d2f75badd1bf4ab9c5c0ddb728c84f">&#9670;&#160;</a></span>postTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::postTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHftMocker.html#aaee83663162e7bbf8d80043cb7796408">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将任务添加到任务队列 </p>
<p>添加任务到任务队列</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>要添加的任务函数</td></tr>
  </table>
  </dd>
</dl>
<p>将任务加入到任务队列中，等待处理线程执行 用于实现线程安全的任务处理，尤其是当任务来自不同线程时</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>要添加的任务函数</td></tr>
  </table>
  </dd>
</dl>
<p>将任务函数添加到任务队列中，等待后续处理 使用互斥锁确保在多线程环境下安全地添加任务 注释的代码是之前的多线程处理方式，当前已简化为单线程模式 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00237">237</a> 行定义.</p>

</div>
</div>
<a id="a7a91c14a56e410510ed954718092ff4e" name="a7a91c14a56e410510ed954718092ff4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a91c14a56e410510ed954718092ff4e">&#9670;&#160;</a></span>procOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::procOrder </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理订单 </p>
<p>处理订单模拟成交</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>订单的本地ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>处理是否成功</dd></dl>
<p>根据本地订单ID处理订单，包括订单的撤销和成交模拟 基于当前的市场数据和订单信息判断订单是否应该成交或撤销</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>本地订单ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>处理结果，true表示处理成功，false表示订单不存在</dd></dl>
<p>模拟订单的成交过程，包含以下步骤：</p><ol type="1">
<li>查找指定订单ID对应的订单信息</li>
<li>根据错单率决定订单是否随机撤销</li>
<li>对于新下的订单，通知订单已提交成功</li>
<li>根据当前行情和市场状况决定订单是否可以成交</li>
<li>如果可以成交，根据成交规则生成成交数量和价格</li>
<li>触发订单和成交回调 该函数是高频策略回测模拟器中的核心函数之一 </li>
</ol>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01073">1073</a> 行定义.</p>

</div>
</div>
<a id="aa4b21aa812ee05cacd35465f012ce202" name="aa4b21aa812ee05cacd35465f012ce202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b21aa812ee05cacd35465f012ce202">&#9670;&#160;</a></span>procTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::procTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理任务队列中的任务 </p>
<p>处理任务队列中的所有任务，按照先进先出的顺序执行 通常在主线程中调用，以确保任务在正确的线程上下文中执行</p>
<p>从任务队列中按顺序取出并执行任务，直到队列为空 整个处理过程由控制锁保护，确保在执行任务时不会被其他线程中断 当任务队列为空时直接返回 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00206">206</a> 行定义.</p>

</div>
</div>
<a id="a1edcdfd9b34dfcc0ed265fd3a8cee6bb" name="a1edcdfd9b34dfcc0ed265fd3a8cee6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edcdfd9b34dfcc0ed265fd3a8cee6bb">&#9670;&#160;</a></span>step_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::step_tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>处理下一个Tick </p>
<p>推进一个Tick的计算</p>
<p>在回测过程中处理下一个Tick数据的方法 用于逐个处理Tick数据，并调用相应的策略回调，通常用于逻速式回测</p>
<p>实现计算线程与控制线程的同步通信机制 如果钩子未安装，直接返回不做处理 通知计算线程进行计算，并等待计算完成通知 完成后重置状态标记，为下一次计算做准备 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00492">492</a> 行定义.</p>

</div>
</div>
<a id="acee5ae15821fd1809d8eccb0ef1976ac" name="acee5ae15821fd1809d8eccb0ef1976ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee5ae15821fd1809d8eccb0ef1976ac">&#9670;&#160;</a></span>stra_buy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a> HftMocker::stra_buy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForceClose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>发送买入订单 </p>
<p>策略买入下单接口</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>买入价格 </td></tr>
    <tr><td class="paramname">qty</td><td>买入数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，用于订单跟踪和识别 </td></tr>
    <tr><td class="paramname">flag</td><td>标志，用于指定下单类型，默认为0 </td></tr>
    <tr><td class="paramname">bForceClose</td><td>是否强制平仓，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>新创建的订单ID列表</dd></dl>
<p>实现IHftStraCtx接口的买入方法，发送买入订单并返回订单ID 在回测中模拟下单流程，创建新订单并根据回测环境中的行情数据进行撤单成交处理</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格，如果为0则表示市价单 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，可用于订单跟踪 </td></tr>
    <tr><td class="paramname">flag</td><td>标志，默认为0 </td></tr>
    <tr><td class="paramname">bForceClose</td><td>是否强制平仓，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>订单ID列表，包含新下单的本地ID</dd></dl>
<p>处理策略的买入请求，实现流程：</p><ol type="1">
<li>验证合约信息和下单数量</li>
<li>生成本地订单ID并创建订单信息</li>
<li>将订单信息添加到订单列表中</li>
<li>异步发送下单确认通知</li>
<li>返回订单ID列表 该函数是策略交易的核心接口之一，用于发起买入操作 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a75f8ae11ad8d0e9e27bf600306fe7a56">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00904">904</a> 行定义.</p>

</div>
</div>
<a id="a6c21deadc6206531ecebc85e0420bd78" name="a6c21deadc6206531ecebc85e0420bd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c21deadc6206531ecebc85e0420bd78">&#9670;&#160;</a></span>stra_cancel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a> HftMocker::stra_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBuy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据合约和方向批量撤单 </p>
<p>根据合约代码和买卖方向批量撤单</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">isBuy</td><td>是否为买单，true为买单，false为卖单 </td></tr>
    <tr><td class="paramname">qty</td><td>需要撤销的数量，默认为0表示撤销所有指定方向的未成交订单 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>撤销的订单ID列表</dd></dl>
<p>实现IHftStraCtx接口的批量撤单方法，根据合约代码、交易方向和数量撤销对应的订单 允许策略同时撤销多个符合条件的未成交订单，提高策略的灵活性</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isBuy</td><td>是否为买单，true表示买单，false表示卖单 </td></tr>
    <tr><td class="paramname">qty</td><td>要撤销的数量，默认为0，表示撤销全部符合条件的订单 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>所有被撤销的订单ID列表</dd></dl>
<p>批量撤销指定合约和方向的未完成订单 操作流程：</p><ol type="1">
<li>遍历所有订单，找出匹配的合约和方向</li>
<li>依次撤销这些订单并记录订单ID</li>
<li>如果指定了数量，会在累计撤销数量达到指定值时停止</li>
<li>返回已撤销的订单ID列表 这个函数在需要批量撤销指定合约的所有委托或指定数量委托时非常有用 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#aaab44981c08a56ce800bdbe6578ac5d6">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00864">864</a> 行定义.</p>

</div>
</div>
<a id="ad707bd83c39287c0c0ac07fa66f23af8" name="ad707bd83c39287c0c0ac07fa66f23af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad707bd83c39287c0c0ac07fa66f23af8">&#9670;&#160;</a></span>stra_cancel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::stra_cancel </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>localid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>根据本地订单ID撤单 </p>
<p>根据本地订单ID撤销单个订单</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>订单的本地ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>撤单是否成功</dd></dl>
<p>实现IHftStraCtx接口的撤单方法，根据订单的本地ID发送撤单请求 在回测中模拟实际交易中的撤单操作，将订单状态标记为已撤销</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">localid</td><td>要撤销的订单的本地ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>撤单请求是否成功发送，始终返回true</dd></dl>
<p>将撤单操作作为任务添加到任务队列中执行，实现异步撤单 任务中的操作包括：</p><ol type="1">
<li>从订单列表中找到对应的订单</li>
<li>将订单的剩余数量置为0</li>
<li>触发on_order回调，标记订单已撤销</li>
<li>从订单列表中删除该订单 所有操作都使用锁保护，确保线程安全 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#ac7c1367da45930a9b9dd82c3592510d0">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00824">824</a> 行定义.</p>

</div>
</div>
<a id="ae9af0513f23e1bb7cb901b79928daa62" name="ae9af0513f23e1bb7cb901b79928daa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9af0513f23e1bb7cb901b79928daa62">&#9670;&#160;</a></span>stra_get_bars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSKlineSlice.html">WTSKlineSlice</a> * HftMocker::stra_get_bars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取K线序列数据 </p>
<p>获及k线历史数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期标识，如m1（分钟）、d1（日线）等 </td></tr>
    <tr><td class="paramname">count</td><td>要请求的K线数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>K线序列数据指针</dd></dl>
<p>实现IHftStraCtx接口的获取K线序列方法，返回指定合约和周期的历史K线数据 并根据请求的数量返回最近的count条K线数据记录</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>周期字符串，如"m1"表示1分钟，"d1"表示日线 </td></tr>
    <tr><td class="paramname">count</td><td>请求的K线条数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>K线切片数据指针，包含请求的K线数据</dd></dl>
<p>从回放器中获取指定合约的K线切片数据 周期格式为单个字符加数字，比如“m5”表礨5分钟线，“d1”表示日线 函数分离出基础周期和倍数，然后调用回放器的接口获及数据 K线数据是策略分析和判断的重要依据 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a390d7d431fccd5874912a67fbac9836f">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01266">1266</a> 行定义.</p>

</div>
</div>
<a id="a1ca39ae2c7e4511fc36d4d041d66c7b7" name="a1ca39ae2c7e4511fc36d4d041d66c7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca39ae2c7e4511fc36d4d041d66c7b7">&#9670;&#160;</a></span>stra_get_comminfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSCommodityInfo.html">WTSCommodityInfo</a> * HftMocker::stra_get_comminfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约信息 </p>
<p>获取合约品种信息</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合约信息指针</dd></dl>
<p>实现IHftStraCtx接口的获取合约信息方法，返回指定合约的详细信息 包括合约的交易单位、最小变动单位、手续费率等相关信息</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的品种信息对象指针</dd></dl>
<p>从回放器中获取指定合约的品种信息 品种信息包括手续费率、交易时段、合约单位等重要参数 策略可以通过该函数查询品种信息以进行交易决策 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a91e746704c765a4edc0541f69a0faaee">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01237">1237</a> 行定义.</p>

</div>
</div>
<a id="a48c31ace00eecc5d848105202bf37355" name="a48c31ace00eecc5d848105202bf37355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c31ace00eecc5d848105202bf37355">&#9670;&#160;</a></span>stra_get_date()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HftMocker::stra_get_date </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前交易日期 </p>
<dl class="section return"><dt>返回</dt><dd>当前交易日期，格式为YYYYMMDD</dd></dl>
<p>实现IHftStraCtx接口的获取当前日期方法，返回当前回测系统中的交易日期 该日期在每个交易日开始时更新</p>
<dl class="section return"><dt>返回</dt><dd>当前交易日期，格式YYYYMMDD</dd></dl>
<p>从回放器中获取当前回测的交易日期 策略可以使用此函数获取日期信息进行交易决策 比如判断是否为月初、月底或特定日期 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a99a9e72ad78d2f0db268632ecd8bbd5d">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01455">1455</a> 行定义.</p>

</div>
</div>
<a id="a49e520aecfd510ce44a23e26418bae6c" name="a49e520aecfd510ce44a23e26418bae6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e520aecfd510ce44a23e26418bae6c">&#9670;&#160;</a></span>stra_get_last_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTickData.html">WTSTickData</a> * HftMocker::stra_get_last_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最新的Tick数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最新Tick数据指针</dd></dl>
<p>实现IHftStraCtx接口的获取最新Tick方法，返回指定合约的最新一条Tick数据 该方法常用于获取当前市场价格、成交量等实时信息</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最新的Tick数据指针，如果找不到则返回NULL</dd></dl>
<p>获取指定合约的最新Tick数据，查找顺序为：</p><ol type="1">
<li>先从本地缓存_ticks中查找，如果找到则增加引用计数并返回</li>
<li>如果本地缓存中没有，则从回放器中获取 这个函数在高频策略中经常使用，用于获取合约的最新行情 注意返回的Tick数据需要手动释放引用计数 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#adbe8252725218a0669ecd096ef9c004f">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01343">1343</a> 行定义.</p>

</div>
</div>
<a id="ae1a4fef2a1e5ffd191e7b60d05b6a4fa" name="ae1a4fef2a1e5ffd191e7b60d05b6a4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a4fef2a1e5ffd191e7b60d05b6a4fa">&#9670;&#160;</a></span>stra_get_order_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSOrdDtlSlice.html">WTSOrdDtlSlice</a> * HftMocker::stra_get_order_detail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取逐笔委托序列数据 </p>
<p>获取逆序明细历史数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>要请求的逐笔委托数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>逐笔委托序列数据指针</dd></dl>
<p>实现IHftStraCtx接口的获取逐笔委托序列方法，返回指定合约的历史逐笔委托数据 并根据请求的数量返回最近的count条逐笔委托数据记录</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的逆序明细数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>逆序明细切片数据指针，包含指定数量的逆序明细数据</dd></dl>
<p>从回放器中获取指定合约的逆序明细历史数据 逆序明细数据包含交易所额外提供的委托明细信息，如委托价格、方向、时间等 高频策略可以利用这些数据深入分析市场的微观结构和订单流 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a6a99a4af04f9936c23f3ac1d2e66e183">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01314">1314</a> 行定义.</p>

</div>
</div>
<a id="ac199e77855db6b88ea9b29215b9e860b" name="ac199e77855db6b88ea9b29215b9e860b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac199e77855db6b88ea9b29215b9e860b">&#9670;&#160;</a></span>stra_get_order_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSOrdQueSlice.html">WTSOrdQueSlice</a> * HftMocker::stra_get_order_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取委托队列序列数据 </p>
<p>获取委托队列历史数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>要请求的委托队列数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托队列序列数据指针</dd></dl>
<p>实现IHftStraCtx接口的获取委托队列序列方法，返回指定合约的历史委托队列数据 并根据请求的数量返回最近的count条委托队列数据记录</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的委托队列数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>委托队列切片数据指针，包含指定数量的委托队列数据</dd></dl>
<p>从回放器中获取指定合约的委托队列历史数据 委托队列数据包含各个价位上的委托数量排队情况，可以看到买卖双方的充足程度 高频交易可以使用委托队列信息分析市场深度和价格层的压力 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a7dc662d97943175fcea78d2e5a0f92a2">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01300">1300</a> 行定义.</p>

</div>
</div>
<a id="a1bce905302fb94935472a3a591639f67" name="a1bce905302fb94935472a3a591639f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bce905302fb94935472a3a591639f67">&#9670;&#160;</a></span>stra_get_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double HftMocker::stra_get_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOnlyValid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约持仓量 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">bOnlyValid</td><td>是否只返回有效持仓，默认为false </td></tr>
    <tr><td class="paramname">flag</td><td>持仓类型标志，3表示全部，1表示多头，2表示空头，默认为3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>持仓量，正数表示多头，负数表示空头</dd></dl>
<p>实现IHftStraCtx接口的获取持仓量方法，返回指定合约的当前持仓量 可以指定只查询有效持仓（即实际可用于交易的持仓）或查询指定方向的持仓</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">bOnlyValid</td><td>是否只返回可用持仓，默认为false返回总持仓 </td></tr>
    <tr><td class="paramname">flag</td><td>标志参数，默认为3，暂时未使用 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合约持仓量，正数表示多头持仓，负数表示空头持仓</dd></dl>
<p>获取指定合约的持仓情况：</p><ol type="1">
<li>如果bOnlyValid为true，则返回总持仓减去冻结持仓，主要用于交易权限检查</li>
<li>如果bOnlyValid为false，则返回总持仓数量 注意关于冻结持仓的约定：空头持仓的_frozen应为0，只有多头持仓收到影响 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#af629f0fe2a984d47e2364cdd1b664d37">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01371">1371</a> 行定义.</p>

</div>
</div>
<a id="a7f4206d6b38801282bae1a8fdf7337f2" name="a7f4206d6b38801282bae1a8fdf7337f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4206d6b38801282bae1a8fdf7337f2">&#9670;&#160;</a></span>stra_get_position_avgpx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double HftMocker::stra_get_position_avgpx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约持仓均价 </p>
<p>获取指定合约的持仓平均价格</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>持仓均价</dd></dl>
<p>实现IHftStraCtx接口的获取持仓均价方法，返回指定合约的当前持仓均价 该均价用于计算持仓盈亏和平仓盈亏</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前持仓的平均成本价，如果无持仓则返回0</dd></dl>
<p>计算指定合约当前持仓的平均成本价 计算流程：</p><ol type="1">
<li>从持仓映射表中查找指定合约的持仓信息</li>
<li>如果找不到或持仓量为0，则返回0</li>
<li>遍历所有持仓明细，将每笔持仓的价格*数量累计</li>
<li>将总金额除以总持仓量得到平均价格 这个函数对于分析持仓的盈亏状况和正确设置止损价非常重要 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a3eeaa742392cc815e71164b0e3279c54">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01415">1415</a> 行定义.</p>

</div>
</div>
<a id="a272f622b0771d2e3265f5045ac284197" name="a272f622b0771d2e3265f5045ac284197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272f622b0771d2e3265f5045ac284197">&#9670;&#160;</a></span>stra_get_position_profit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double HftMocker::stra_get_position_profit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约持仓盈亏 </p>
<p>获取指定合约的持仓动态盈亏</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>持仓浮动盈亏</dd></dl>
<p>实现IHftStraCtx接口的获取持仓盈亏方法，返回指定合约的当前持仓浮动盈亏 根据当前市场价格和持仓均价计算浮动盈亏</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前持仓的浮动盈亏，如果无持仓则返回0</dd></dl>
<p>查询指定合约当前持仓的浮动盈亏情况 首先从持仓映射表中查找指定合约的持仓信息 如果找到则返回其动态盈亏值，否则返回0 此值在update_dyn_profit函数中更新，每次收到新Tick时计算 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a114a12ae7a708a7adb001c4ee5ba7bde">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01393">1393</a> 行定义.</p>

</div>
</div>
<a id="a10c43361df8fb23f77d8a3dad1f73acc" name="a10c43361df8fb23f77d8a3dad1f73acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c43361df8fb23f77d8a3dad1f73acc">&#9670;&#160;</a></span>stra_get_price()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double HftMocker::stra_get_price </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约当前价格 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前市场价格</dd></dl>
<p>实现IHftStraCtx接口的获取当前价格方法，返回指定合约的当前最新成交价格 通常使用最新Tick数据中的最新成交价格作为当前价格</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合约当前价格</dd></dl>
<p>从回放器中获取指定合约的当前价格 这个函数在计算盈亏和执行交易决策时经常使用 当前价格通常是指最新成交价 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#ae506ba2d2019ca33d1d11e53ce1527ad">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01443">1443</a> 行定义.</p>

</div>
</div>
<a id="abca80698bf51efbf2a919584ee156f05" name="abca80698bf51efbf2a919584ee156f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca80698bf51efbf2a919584ee156f05">&#9670;&#160;</a></span>stra_get_rawcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string HftMocker::stra_get_rawcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取分月合约代码 </p>
<p>获取合约的原始代码</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>原始分月合约代码</dd></dl>
<p>实现IHftStraCtx接口的获取原始合约代码方法，将标准化后的代码转换回原始的分月合约代码 如将SHFE.rb.HOT转换为SHFE.rb2101等实际的合约月份</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的原始合约代码</dd></dl>
<p>从标准化的合约代码获取原始的合约代码 在WonderTrader中，所有合约都会标准化为统一格式，而原始代码是各交易所原始的合约代码 此功能在需要与外部系统对接或显示原始代码时非常有用 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a85066e4946d077793190aceafe4a9a7a">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01250">1250</a> 行定义.</p>

</div>
</div>
<a id="adb712ae4d243e7f83f7e689144734471" name="adb712ae4d243e7f83f7e689144734471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb712ae4d243e7f83f7e689144734471">&#9670;&#160;</a></span>stra_get_secs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HftMocker::stra_get_secs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前交易时间（秒） </p>
<p>获取当前的秒数</p>
<dl class="section return"><dt>返回</dt><dd>当前时间秒数，格式为从0点开始的秒数</dd></dl>
<p>实现IHftStraCtx接口的获取当前时间秒数方法，返回当前回测系统中的时间秒数 可以用来计算时间差或更精细的时间判断</p>
<dl class="section return"><dt>返回</dt><dd>当前秒数，范围0-59</dd></dl>
<p>从回放器中获取当前回测的秒数 与get_time函数配合使用，可以获取更精细的时间信息 特别适用于高频交易中需要精确秒级时间的场景 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a8fffe54b21483529bc8a1e59941a4710">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01479">1479</a> 行定义.</p>

</div>
</div>
<a id="a4eb17f55bae6202f4337043eb70ce0c7" name="a4eb17f55bae6202f4337043eb70ce0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb17f55bae6202f4337043eb70ce0c7">&#9670;&#160;</a></span>stra_get_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTickSlice.html">WTSTickSlice</a> * HftMocker::stra_get_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取Tick序列数据 </p>
<p>获取Tick历史数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>要请求的Tick数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Tick序列数据指针</dd></dl>
<p>实现IHftStraCtx接口的获取Tick序列方法，返回指定合约的历史Tick数据 并根据请求的数量返回最近的count条Tick数据记录</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的Tick数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Tick切片数据指针，包含指定数量的最新Tick数据</dd></dl>
<p>从回放器中获取指定合约的Tick历史数据 Tick数据包含买一价、卖一价、最新价、成交量等实时行情信息 高频策略可以基于Tick数据进行快速响应和大量交易决策 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a212baacd0af3e3d343ffa15669f94e46">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01286">1286</a> 行定义.</p>

</div>
</div>
<a id="a1b342d9b678ce0031b419f50fbdd06f2" name="a1b342d9b678ce0031b419f50fbdd06f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b342d9b678ce0031b419f50fbdd06f2">&#9670;&#160;</a></span>stra_get_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HftMocker::stra_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前交易时间 </p>
<dl class="section return"><dt>返回</dt><dd>当前交易时间，格式为HHMMSS（小时分秒）</dd></dl>
<p>实现IHftStraCtx接口的获取当前时间方法，返回当前回测系统中的交易时间 该时间根据数据回放的进度实时更新</p>
<dl class="section return"><dt>返回</dt><dd>当前交易时间，格式HHMMSS</dd></dl>
<p>从回放器中获取当前回测的原始交易时间 策略可以使用此函数获取时间信息进行交易决策 比如判断是否在开盘、收盘或中午休市时段 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a60301a241ea1eb1d8fcacab2e52b5049">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01467">1467</a> 行定义.</p>

</div>
</div>
<a id="aea26718c2a4bf32771db39d2431e6320" name="aea26718c2a4bf32771db39d2431e6320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea26718c2a4bf32771db39d2431e6320">&#9670;&#160;</a></span>stra_get_transaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTransSlice.html">WTSTransSlice</a> * HftMocker::stra_get_transaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取逐笔成交序列数据 </p>
<p>获取逐笔成交历史数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>要请求的逐笔成交数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>逐笔成交序列数据指针</dd></dl>
<p>实现IHftStraCtx接口的获取逐笔成交序列方法，返回指定合约的历史逐笔成交数据 并根据请求的数量返回最近的count条逐笔成交数据记录</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的逐笔成交数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>逐笔成交切片数据指针，包含指定数量的逐笔成交数据</dd></dl>
<p>从回放器中获取指定合约的逐笔成交历史数据 逐笔成交数据包含每笔成交的价格、数量、方向、时间等详细信息 高频策略可以通过逐笔成交数据分析市场的短期趋势和交易活跃度 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#ab1e713b4cec11888626c3da547f27257">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01328">1328</a> 行定义.</p>

</div>
</div>
<a id="ae53421109f10c732a70d27d540aaa9d6" name="ae53421109f10c732a70d27d540aaa9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53421109f10c732a70d27d540aaa9d6">&#9670;&#160;</a></span>stra_get_undone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double HftMocker::stra_get_undone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取合约未完成数量 </p>
<p>获取指定合约的未完成委托数量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>未完成委托数量，正数表示买入未完成，负数表示卖出未完成</dd></dl>
<p>实现IHftStraCtx接口的获取未完成数量方法，返回指定合约的未完成订单数量 未完成委托包括未成交和部分成交的订单剩余数量</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>未完成的买卖委托净数量，买单为正，卖单为负</dd></dl>
<p>遍历当前订单表，统计指定合约的所有未完成订单数量 计算方式是将所有买单的未成交数量取正，卖单的未成交数量取负，然后相加 返回的数值可用于人工智能策略中估计当前的总体委托方向和数量 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a703c6ba6ce99e4531a47f62e1a8a858c">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l00797">797</a> 行定义.</p>

</div>
</div>
<a id="a2b4415991a646c0581534effbaa2c4fc" name="a2b4415991a646c0581534effbaa2c4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4415991a646c0581534effbaa2c4fc">&#9670;&#160;</a></span>stra_load_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * HftMocker::stra_load_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>defVal</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>读取用户自定义数据 </p>
<p>加载用户自定义数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据键名 </td></tr>
    <tr><td class="paramname">defVal</td><td>默认值，当指定键不存在时返回的值，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>键对应的值，如果键不存在则返回默认值</dd></dl>
<p>实现IHftStraCtx接口的读取用户数据方法，读取先前通过save_user_data保存的数据 用于策略中恢复保存的状态、配置或其他定制数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据的键名 </td></tr>
    <tr><td class="paramname">defVal</td><td>默认值，当键不存在时返回此值，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>与键关联的值，如果键不存在则返回默认值</dd></dl>
<p>从用户数据映射中获取指定键对应的值 用户数据是策略在不同运行周期之间保存状态的重要机制 例如可以保存上一次交易的价格、数量或其他需要持久化的信息 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#a73d816fe80abc2ea07c8297ca63baf76">IHftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01601">1601</a> 行定义.</p>

</div>
</div>
<a id="ae826802cdc50af57e7a83fb53e562484" name="ae826802cdc50af57e7a83fb53e562484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826802cdc50af57e7a83fb53e562484">&#9670;&#160;</a></span>stra_log_debug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_log_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录调试级别日志 </p>
<p>记录调试级别的日志</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的调试日志记录方法，记录并输出策略的调试级别日志 用于策略中记录详细的调试信息，如数据处理过程、中间计算结果等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>要记录的调试消息</td></tr>
  </table>
  </dd>
</dl>
<p>将指定的消息以DEBUG级别记录到策略日志中 调试日志通常用于记录策略运行过程中的详细信息 这些信息对于调试策略问题非常有用 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a41df4053c2b9203119117f70363f64dc">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01563">1563</a> 行定义.</p>

</div>
</div>
<a id="a2a640ca3f4a39103892f18b56a613310" name="a2a640ca3f4a39103892f18b56a613310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a640ca3f4a39103892f18b56a613310">&#9670;&#160;</a></span>stra_log_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_log_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录错误级别日志 </p>
<p>记录错误级别的日志</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的错误日志记录方法，记录并输出策略的错误级别日志 用于策略中记录严重的错误情况，如交易失败、数据异常等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>要记录的错误消息</td></tr>
  </table>
  </dd>
</dl>
<p>将指定的消息以ERROR级别记录到策略日志中 错误日志用于记录可能导致策略无法正常运行的严重问题 例如下单失败、持仓计算错误等 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#aac1cb364003d0d52862a026c81d9f0a5">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01587">1587</a> 行定义.</p>

</div>
</div>
<a id="a2bca8aab086a650ad2f83c53a4ac63a8" name="a2bca8aab086a650ad2f83c53a4ac63a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bca8aab086a650ad2f83c53a4ac63a8">&#9670;&#160;</a></span>stra_log_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_log_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录信息级别日志 </p>
<p>记录信息级别的日志</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的信息日志记录方法，记录并输出策略的信息级别日志 用于策略中记录一般性的信息，如交易信号、状态变化等</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>要记录的日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>将指定的消息以INFO级别记录到策略日志中 使用策略名称作为日志标签，便于区分不同策略的日志 这是策略中记录一般信息的标准方法 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#ae9fa04de5ab6ed777fd966113ce8e342">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01551">1551</a> 行定义.</p>

</div>
</div>
<a id="aeb6589c1b6e29ecd9352f470155733f1" name="aeb6589c1b6e29ecd9352f470155733f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6589c1b6e29ecd9352f470155733f1">&#9670;&#160;</a></span>stra_log_warn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_log_warn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录警告级别日志 </p>
<p>记录警告级别的日志</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的警告日志记录方法，记录并输出策略的警告级别日志 用于策略中记录需要关注的警告信息，如可能导致问题的异常状况</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>要记录的警告消息</td></tr>
  </table>
  </dd>
</dl>
<p>将指定的消息以WARN级别记录到策略日志中 警告日志用于记录可能影响策略正常运行但不会导致策略失败的情况 例如参数设置不合理、市场数据异常等 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#a3fdaad097dbca2b62b7c0e4579320c7b">IHftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01575">1575</a> 行定义.</p>

</div>
</div>
<a id="a278328a822b80c2d64ad1f046f8f6d2f" name="a278328a822b80c2d64ad1f046f8f6d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278328a822b80c2d64ad1f046f8f6d2f">&#9670;&#160;</a></span>stra_save_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_save_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>保存用户自定义数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据键名 </td></tr>
    <tr><td class="paramname">val</td><td>数据值</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的保存用户数据方法，存储策略自定义的数据 允许策略保存状态或配置信息，为键值对形式，可在后续使用load_user_data读取</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据的键名 </td></tr>
    <tr><td class="paramname">val</td><td>要保存的值</td></tr>
  </table>
  </dd>
</dl>
<p>将指定的键值对保存到用户数据映射中 同时标记用户数据已被修改，确保在回测结束时将数据写入文件 这是策略在不同运行周期之间传递信息的标准方法 </p>

<p>重载 <a class="el" href="classIHftStraCtx.html#ae3d11ec5a59a8e505c825ab5fd5ff7a5">IHftStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01618">1618</a> 行定义.</p>

</div>
</div>
<a id="a9e0a504cadbeeb05d9d3bfc6ffe991c1" name="a9e0a504cadbeeb05d9d3bfc6ffe991c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0a504cadbeeb05d9d3bfc6ffe991c1">&#9670;&#160;</a></span>stra_sell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ExecuteDefs_8h.html#a5956353808ff4eea2def6475db30bc0d">OrderIDs</a> HftMocker::stra_sell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForceClose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>发送卖出订单 </p>
<p>策略卖出下单接口</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>卖出价格 </td></tr>
    <tr><td class="paramname">qty</td><td>卖出数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标签，用于订单跟踪和识别 </td></tr>
    <tr><td class="paramname">flag</td><td>标志，用于指定下单类型，默认为0 </td></tr>
    <tr><td class="paramname">bForceClose</td><td>是否强制平仓，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>新创建的订单ID列表</dd></dl>
<p>实现IHftStraCtx接口的卖出方法，发送卖出订单并返回订单ID 在回测中模拟下单流程，创建新订单并根据回测环境中的行情数据进行撤单成交处理</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>委托价格，如果为0则表示市价单 </td></tr>
    <tr><td class="paramname">qty</td><td>委托数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，可用于订单跟踪 </td></tr>
    <tr><td class="paramname">flag</td><td>标志，默认为0 </td></tr>
    <tr><td class="paramname">bForceClose</td><td>是否强制平仓，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>订单ID列表，包含新下单的本地ID</dd></dl>
<p>处理策略的卖出请求，实现流程：</p><ol type="1">
<li>验证合约信息和下单数量</li>
<li>对于不能做空的合约，检查是否有足够的可用持仓</li>
<li>生成本地订单ID并创建订单信息</li>
<li>将订单信息添加到订单列表中</li>
<li>异步发送下单确认通知</li>
<li>返回订单ID列表 该函数与stra_buy类似，但增加了对不可做空合约的持仓检查 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#aec4d197396238cfb42acd2ed72a19286">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01177">1177</a> 行定义.</p>

</div>
</div>
<a id="a5e9ed8d695da919910b8dd00456c3083" name="a5e9ed8d695da919910b8dd00456c3083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9ed8d695da919910b8dd00456c3083">&#9670;&#160;</a></span>stra_sub_order_details()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_sub_order_details </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅逐笔委托数据 </p>
<p>订阅合约的逆序明细数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的订阅逐笔委托数据方法，订阅指定合约的逐笔委托数据 订阅后，当该合约有新的逐笔委托数据到来时，会触发on_order_detail回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的逆序明细数据 通知回放器订阅该合约的逆序明细数据 逆序明细包含的是交易所发布的逻辑时间排序的委托数据 高频策略可以基于这些数据进行市场微观结构分析 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a049d82127f1fe417269571aebdb5e344">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01526">1526</a> 行定义.</p>

</div>
</div>
<a id="ab0723b5832e9acc3d2ef0e6c431b80c9" name="ab0723b5832e9acc3d2ef0e6c431b80c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0723b5832e9acc3d2ef0e6c431b80c9">&#9670;&#160;</a></span>stra_sub_order_queues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_sub_order_queues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅委托队列数据 </p>
<p>订阅合约的委托队列数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的订阅委托队列数据方法，订阅指定合约的委托队列数据 订阅后，当该合约有新的委托队列数据到来时，会触发on_order_queue回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的委托队列数据 通知回放器订阅该合约的委托队列数据 委托队列数据包含各个价位的委托排队情况，在高频策略中可用于分析市场深度 查看各价位的流动性和供需关系 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#abbf9a1b434975aa563340cd4e6e0fc1a">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01513">1513</a> 行定义.</p>

</div>
</div>
<a id="a57e235606406214513cc6348795cce58" name="a57e235606406214513cc6348795cce58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e235606406214513cc6348795cce58">&#9670;&#160;</a></span>stra_sub_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_sub_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅Tick行情数据 </p>
<p>订阅合约的Tick数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的订阅Tick数据方法，订阅指定合约的Tick行情数据 订阅后，当该合约有新的Tick数据到来时，会触发on_tick回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的Tick数据，包含两个操作：</p><ol type="1">
<li>将合约代码插入到本地的订阅集合中记录</li>
<li>通知回放器订阅该合约的Tick数据 当收到Tick数据时，on_tick_updated函数会先检查该合约是否在订阅列表中 这是策略获取实时行情数据的必要步骤 </li>
</ol>

<p>实现了 <a class="el" href="classIHftStraCtx.html#a377e3170ccd2bdba66a81a660d731f65">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01493">1493</a> 行定义.</p>

</div>
</div>
<a id="a9467db36278bb1aea6262e94cf64d1c2" name="a9467db36278bb1aea6262e94cf64d1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9467db36278bb1aea6262e94cf64d1c2">&#9670;&#160;</a></span>stra_sub_transactions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::stra_sub_transactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅逐笔成交数据 </p>
<p>订阅合约的逐笔成交数据</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>实现IHftStraCtx接口的订阅逐笔成交数据方法，订阅指定合约的逐笔成交数据 订阅后，当该合约有新的逐笔成交数据到来时，会触发on_transaction回调</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>订阅指定合约的逐笔成交数据 通知回放器订阅该合约的逐笔成交数据 逐笔成交数据包含市场上实际成交的每笔详细信息 高频策略可以基于这些数据分析市场的交易方向和活跃度 </p>

<p>实现了 <a class="el" href="classIHftStraCtx.html#ac730682f0b452538c00abbd7b4981a92">IHftStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01539">1539</a> 行定义.</p>

</div>
</div>
<a id="ac325172459209a198edc4788896f1cf9" name="ac325172459209a198edc4788896f1cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac325172459209a198edc4788896f1cf9">&#9670;&#160;</a></span>update_dyn_profit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void HftMocker::update_dyn_profit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>更新动态持仓盈亏 </p>
<p>更新持仓的动态盈亏</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化的合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>最新的Tick数据指针</td></tr>
  </table>
  </dd>
</dl>
<p>根据最新的价格数据更新指定合约的浮动盈亏 当收到新的Tick数据时，使用最新价格重新计算当前持仓的浮动盈亏</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>最新的Tick行情数据</td></tr>
  </table>
  </dd>
</dl>
<p>根据最新的行情数据计算并更新指定合约的浮动盈亏 首先查找合约的持仓信息，如果持仓量为0则盈亏为0 否则根据持仓方向选择对应的价格（多头用买一价，空头用卖一价） 遍历所有持仓明细，计算每一笔持仓的当前盈亏，并累计总动态盈亏 同时记录每笔持仓的最大盈利和最大亏损 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a> 第 <a class="el" href="HftMocker_8cpp_source.html#l01025">1025</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="aa741b64e5e856dab86f182f8bc1077ad" name="aa741b64e5e856dab86f182f8bc1077ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa741b64e5e856dab86f182f8bc1077ad">&#9670;&#160;</a></span>_close_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream HftMocker::_close_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平仓日志流 </p>
<p>记录所有平仓操作的详细日志流，包括每笔平仓的具体信息 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01155">1155</a> 行定义.</p>

</div>
</div>
<a id="a1441a736663deba894ad6d999c5e4c3e" name="a1441a736663deba894ad6d999c5e4c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1441a736663deba894ad6d999c5e4c3e">&#9670;&#160;</a></span>_commodities</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#a819ce31204edca9060fcaecec75b0152">CommodityMap</a>* HftMocker::_commodities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>商品映射对象 </p>
<p>存储所有可交易商品的信息，包括合约规格、手续费等 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00990">990</a> 行定义.</p>

</div>
</div>
<a id="a7e836b7def332c4ca8c905b1e2df71ff" name="a7e836b7def332c4ca8c905b1e2df71ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e836b7def332c4ca8c905b1e2df71ff">&#9670;&#160;</a></span>_cond_calc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gafaa630f2eecc6c68bc508cb484fcd3a3">StdCondVariable</a> HftMocker::_cond_calc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算条件变量 </p>
<p>用于线程同步的条件变量，协调计算线程的等待和唇醒 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01233">1233</a> 行定义.</p>

</div>
</div>
<a id="abdfad05d029695eb56523e8bc7ba8438" name="abdfad05d029695eb56523e8bc7ba8438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfad05d029695eb56523e8bc7ba8438">&#9670;&#160;</a></span>_context_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HftMocker::_context_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>上下文ID </p>
<p>策略实例的唯一标识ID，用于区分不同的策略实例 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01221">1221</a> 行定义.</p>

</div>
</div>
<a id="a8d03810863dd82f208aa557bc74d9b26" name="a8d03810863dd82f208aa557bc74d9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d03810863dd82f208aa557bc74d9b26">&#9670;&#160;</a></span>_error_rate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t HftMocker::_error_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>错误率 </p>
<p>模拟交易中的错误概率，用于模拟实际交易中可能出现的失败情况 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00763">763</a> 行定义.</p>

</div>
</div>
<a id="a99dd4502da42c899f1f9bb27deaa66ce" name="a99dd4502da42c899f1f9bb27deaa66ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dd4502da42c899f1f9bb27deaa66ce">&#9670;&#160;</a></span>_factory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#ab276208bb5da43beec85694b843d811b">StraFactInfo</a> HftMocker::_factory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略工厂信息 </p>
<p>存储当前使用的策略工厂相关信息 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00844">844</a> 行定义.</p>

</div>
</div>
<a id="ac759fad8fa9d68ef015d654daf232a03" name="ac759fad8fa9d68ef015d654daf232a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac759fad8fa9d68ef015d654daf232a03">&#9670;&#160;</a></span>_fund_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#a1d85fa0e6d19557b48c7b19aef519d9c">StraFundInfo</a> HftMocker::_fund_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略资金信息 </p>
<p>存储当前策略的资金状况，用于跟踪和计算策略绩效 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01214">1214</a> 行定义.</p>

</div>
</div>
<a id="a336b49ced236d6d0ad2629c48c99507b" name="a336b49ced236d6d0ad2629c48c99507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336b49ced236d6d0ad2629c48c99507b">&#9670;&#160;</a></span>_fund_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream HftMocker::_fund_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>资金日志流 </p>
<p>记录资金变动情况的日志流，包括盈亏、手续费等 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01161">1161</a> 行定义.</p>

</div>
</div>
<a id="a5fa8b2faf7f19ba168344d0de752defc" name="a5fa8b2faf7f19ba168344d0de752defc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa8b2faf7f19ba168344d0de752defc">&#9670;&#160;</a></span>_has_hook</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::_has_hook</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否启用钩子 </p>
<p>人为控制是否启用策略钩子函数，可通过enable_hook方法设置 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01239">1239</a> 行定义.</p>

</div>
</div>
<a id="ae3c1d3f8020e88636e92163653b4709a" name="ae3c1d3f8020e88636e92163653b4709a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c1d3f8020e88636e92163653b4709a">&#9670;&#160;</a></span>_hook_valid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::_hook_valid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>钩子是否有效 </p>
<p>根据是否是异步回测模式自动确定钩子是否可用 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01245">1245</a> 行定义.</p>

</div>
</div>
<a id="a933aca33d2ad168cdabcdf22314ff227" name="a933aca33d2ad168cdabcdf22314ff227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933aca33d2ad168cdabcdf22314ff227">&#9670;&#160;</a></span>_match_this_tick</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::_match_this_tick</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否在当前Tick撤单 </p>
<p>控制订单模拟撤单是否在当前Tick数据到来时立即执行 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00769">769</a> 行定义.</p>

</div>
</div>
<a id="af0f95b18e413ac45773b41156a06eda6" name="af0f95b18e413ac45773b41156a06eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f95b18e413ac45773b41156a06eda6">&#9670;&#160;</a></span>_mtx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a> HftMocker::_mtx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>任务队列互斥锁 </p>
<p>保护任务队列的互斥锁，确保多线程环境下对任务队列的安全访问 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00856">856</a> 行定义.</p>

</div>
</div>
<a id="aa9dfcbde27d69ab31bb18b8819832344" name="aa9dfcbde27d69ab31bb18b8819832344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dfcbde27d69ab31bb18b8819832344">&#9670;&#160;</a></span>_mtx_calc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a> HftMocker::_mtx_calc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算互斥锁 </p>
<p>保护计算相关操作的互斥锁，确保多线程环境下计算的线程安全 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01227">1227</a> 行定义.</p>

</div>
</div>
<a id="a53620bc3724f505128af4719ea86bcc0" name="a53620bc3724f505128af4719ea86bcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53620bc3724f505128af4719ea86bcc0">&#9670;&#160;</a></span>_mtx_control</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a> HftMocker::_mtx_control</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>控制互斥锁 </p>
<p>用于保护对策略控制相关操作的线程安全性 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00868">868</a> 行定义.</p>

</div>
</div>
<a id="a2d9eb5d31ed1659235e2ef9dfc076923" name="a2d9eb5d31ed1659235e2ef9dfc076923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9eb5d31ed1659235e2ef9dfc076923">&#9670;&#160;</a></span>_mtx_ords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaefc042c4e34f92133d0f14ed45c1b6fc">StdRecurMutex</a> HftMocker::_mtx_ords</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单管理互斥锁 </p>
<p>保护订单管理相关操作的互斥锁，确保多线程环境下对订单的安全访问 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00972">972</a> 行定义.</p>

</div>
</div>
<a id="a60eff986515334f2199145699b308eba" name="a60eff986515334f2199145699b308eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60eff986515334f2199145699b308eba">&#9670;&#160;</a></span>_orders</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#a5a7a6ca7ddb642eb7b290d6622f6b66c">Orders</a> HftMocker::_orders</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订单容器 </p>
<p>存储所有当前活跃的订单，使用本地订单ID作为键 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00978">978</a> 行定义.</p>

</div>
</div>
<a id="ae1aa2ae02207525e03d669d6a5f03726" name="ae1aa2ae02207525e03d669d6a5f03726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aa2ae02207525e03d669d6a5f03726">&#9670;&#160;</a></span>_pos_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream HftMocker::_pos_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓日志流 </p>
<p>记录持仓变动情况的日志流，用于跟踪持仓变化 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01173">1173</a> 行定义.</p>

</div>
</div>
<a id="a4da18408ff15aa119798a49a98f16bd2" name="a4da18408ff15aa119798a49a98f16bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da18408ff15aa119798a49a98f16bd2">&#9670;&#160;</a></span>_pos_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#aff87a9e5c69c4f0363ad6e3cd5d202ab">PositionMap</a> HftMocker::_pos_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓映射容器 </p>
<p>存储所有合约的持仓信息，键为合约代码，值为相应的持仓信息 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01143">1143</a> 行定义.</p>

</div>
</div>
<a id="ac126d2a5570a0a4701d3c8c0a3dfcc2c" name="ac126d2a5570a0a4701d3c8c0a3dfcc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac126d2a5570a0a4701d3c8c0a3dfcc2c">&#9670;&#160;</a></span>_price_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#a69f6f54ea67cef5accfe4b1d2e981a06">PriceMap</a> HftMocker::_price_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>合约价格映射表 </p>
<p>存储各个合约当前的价格信息，键为合约代码，值为当前价格 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00781">781</a> 行定义.</p>

</div>
</div>
<a id="ae9412786a0ff069aff7e500d4e142797" name="ae9412786a0ff069aff7e500d4e142797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9412786a0ff069aff7e500d4e142797">&#9670;&#160;</a></span>_replayer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a>* HftMocker::_replayer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>历史数据回放器指针 </p>
<p>用于提供回测所需的历史行情数据，包括各种Tick数据、K线数据等 并负责数据的时间控制和回放过程的管理 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00751">751</a> 行定义.</p>

</div>
</div>
<a id="a9cd7701d0e543c7675f90c57095fe450" name="a9cd7701d0e543c7675f90c57095fe450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd7701d0e543c7675f90c57095fe450">&#9670;&#160;</a></span>_resumed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; HftMocker::_resumed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否已恢复标志 </p>
<p>原子变量，标记策略是否已从暂停状态恢复，用于控制状态转换 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01251">1251</a> 行定义.</p>

</div>
</div>
<a id="a82e871d564410cd643ef330c8746f437" name="a82e871d564410cd643ef330c8746f437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e871d564410cd643ef330c8746f437">&#9670;&#160;</a></span>_sig_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream HftMocker::_sig_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>信号日志流 </p>
<p>记录交易信号相关的日志流，用于分析信号质量 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01167">1167</a> 行定义.</p>

</div>
</div>
<a id="ab7e14fa9ef3761aa3a6526f791d23c46" name="ab7e14fa9ef3761aa3a6526f791d23c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e14fa9ef3761aa3a6526f791d23c46">&#9670;&#160;</a></span>_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftStrategy.html">HftStrategy</a>* HftMocker::_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>高频策略实例指针 </p>
<p>指向当前使用的高频策略实例，由策略工厂创建 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00850">850</a> 行定义.</p>

</div>
</div>
<a id="acc16df1355f76244a99d7c4270557321" name="acc16df1355f76244a99d7c4270557321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc16df1355f76244a99d7c4270557321">&#9670;&#160;</a></span>_tasks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::queue&lt;<a class="el" href="classHftMocker.html#aaee83663162e7bbf8d80043cb7796408">Task</a>&gt; HftMocker::_tasks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>任务队列 </p>
<p>存储等待执行的任务，这些任务通过postTask添加，由procTask处理 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00862">862</a> 行定义.</p>

</div>
</div>
<a id="afdd99f6733f42971519f3ffef4576cad" name="afdd99f6733f42971519f3ffef4576cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd99f6733f42971519f3ffef4576cad">&#9670;&#160;</a></span>_tick_subs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwt__hashset.html">wt_hashset</a>&lt;std::string&gt; HftMocker::_tick_subs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick数据订阅列表 </p>
<p>存储当前策略订阅的所有合约代码，用于管理订阅关系 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01258">1258</a> 行定义.</p>

</div>
</div>
<a id="a49b286f55446e699340d8cf116cd7fae" name="a49b286f55446e699340d8cf116cd7fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b286f55446e699340d8cf116cd7fae">&#9670;&#160;</a></span>_ticks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#a7ededf4904cc4767a9b13909ca0b1759">TickCache</a>* HftMocker::_ticks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick缓存 </p>
<p>存储最新的Tick数据缓存，提供快速访问 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01270">1270</a> 行定义.</p>

</div>
</div>
<a id="aab46e2cc84e56a7a99c830bd843dbd29" name="aab46e2cc84e56a7a99c830bd843dbd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab46e2cc84e56a7a99c830bd843dbd29">&#9670;&#160;</a></span>_trade_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream HftMocker::_trade_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日志流 </p>
<p>记录所有交易操作的日志流，包括开仓和平仓操作 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01149">1149</a> 行定义.</p>

</div>
</div>
<a id="aac5d630cea48dec8f7996bc305a429ea" name="aac5d630cea48dec8f7996bc305a429ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5d630cea48dec8f7996bc305a429ea">&#9670;&#160;</a></span>_ud_modified</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::_ud_modified</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01004">1004</a> 行定义.</p>

</div>
</div>
<a id="aef6a528bc6c85a3c9f7d3a364f7ab688" name="aef6a528bc6c85a3c9f7d3a364f7ab688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6a528bc6c85a3c9f7d3a364f7ab688">&#9670;&#160;</a></span>_use_newpx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HftMocker::_use_newpx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否使用新价格 </p>
<p>控制订单成交是否使用最新的价格进行模拟成交 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l00757">757</a> 行定义.</p>

</div>
</div>
<a id="a84331281febce3bf1092d6518d0288e9" name="a84331281febce3bf1092d6518d0288e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84331281febce3bf1092d6518d0288e9">&#9670;&#160;</a></span>_user_datas</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHftMocker.html#a6fa7628a81e6f43a303036e080890fe6">StringHashMap</a> HftMocker::_user_datas</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>用户自定义数据存储 </p>
<p>存储策略自定义的数据，允许策略在运行过程中保存状态信息 </p>

<p class="definition">在文件 <a class="el" href="HftMocker_8h_source.html">HftMocker.h</a> 第 <a class="el" href="HftMocker_8h_source.html#l01003">1003</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/WtBtCore/<a class="el" href="HftMocker_8h_source.html">HftMocker.h</a></li>
<li>src/WtBtCore/<a class="el" href="HftMocker_8cpp_source.html">HftMocker.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classHftMocker.html">HftMocker</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
