<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WonderTrader: CtaMocker类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WonderTrader<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">高性能量化交易平台</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classCtaMocker.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-types">Protected 类型</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pri-methods">Private 成员函数</a> &#124;
<a href="classCtaMocker-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">CtaMocker类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>CTA策略回测模拟器类  
 <a href="classCtaMocker.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__ChartIndex.html">_ChartIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表指标结构体  <a href="structCtaMocker_1_1__ChartIndex.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__ChartLine.html">_ChartLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表线结构体  <a href="structCtaMocker_1_1__ChartLine.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__DetailInfo.html">_DetailInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易详情结构体  <a href="structCtaMocker_1_1__DetailInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__KlineTag.html">_KlineTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线标记结构体  <a href="structCtaMocker_1_1__KlineTag.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__PosInfo.html">_PosInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓信息结构体  <a href="structCtaMocker_1_1__PosInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__SigInfo.html">_SigInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">信号信息结构体  <a href="structCtaMocker_1_1__SigInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__StraFactInfo.html">_StraFactInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息结构体  <a href="structCtaMocker_1_1__StraFactInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCtaMocker_1_1__StraFundInfo.html">_StraFundInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息结构体  <a href="structCtaMocker_1_1__StraFundInfo.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a50dd853c3e942ceb1d2cdd75f6cbbd14" id="r_a50dd853c3e942ceb1d2cdd75f6cbbd14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a50dd853c3e942ceb1d2cdd75f6cbbd14">CtaMocker</a> (<a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *replayer, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classICtaStraCtx.html#a5204938d188c461217d7d7069760e331">name</a>, int32_t slippage=0, bool persistData=true, <a class="el" href="classEventNotifier.html">EventNotifier</a> *notifier=<a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, bool isRatioSlp=false)</td></tr>
<tr class="memdesc:a50dd853c3e942ceb1d2cdd75f6cbbd14"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="separator:a50dd853c3e942ceb1d2cdd75f6cbbd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e13c934118cf25b0e16109f441e5089" id="r_a2e13c934118cf25b0e16109f441e5089"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a2e13c934118cf25b0e16109f441e5089">~CtaMocker</a> ()</td></tr>
<tr class="memdesc:a2e13c934118cf25b0e16109f441e5089"><td class="mdescLeft">&#160;</td><td class="mdescRight">析构函数  <br /></td></tr>
<tr class="separator:a2e13c934118cf25b0e16109f441e5089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6ad6721e46a6963d5c2e8475151c5" id="r_aabc6ad6721e46a6963d5c2e8475151c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aabc6ad6721e46a6963d5c2e8475151c5">init_cta_factory</a> (<a class="el" href="classWTSVariant.html">WTSVariant</a> *cfg)</td></tr>
<tr class="memdesc:aabc6ad6721e46a6963d5c2e8475151c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化CTA策略工厂  <br /></td></tr>
<tr class="separator:aabc6ad6721e46a6963d5c2e8475151c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c1b688e418610c3b829a2e282f277" id="r_a585c1b688e418610c3b829a2e282f277"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a585c1b688e418610c3b829a2e282f277">load_incremental_data</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *lastBacktestName)</td></tr>
<tr class="memdesc:a585c1b688e418610c3b829a2e282f277"><td class="mdescLeft">&#160;</td><td class="mdescRight">加载增量回测数据  <br /></td></tr>
<tr class="separator:a585c1b688e418610c3b829a2e282f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bf0f1487e76b1f7696c87d444a3da4" id="r_a72bf0f1487e76b1f7696c87d444a3da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a72bf0f1487e76b1f7696c87d444a3da4">install_hook</a> ()</td></tr>
<tr class="memdesc:a72bf0f1487e76b1f7696c87d444a3da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">安装钩子  <br /></td></tr>
<tr class="separator:a72bf0f1487e76b1f7696c87d444a3da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc8663664126a6413cdc39f6285012" id="r_abcfc8663664126a6413cdc39f6285012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#abcfc8663664126a6413cdc39f6285012">enable_hook</a> (bool bEnabled=true)</td></tr>
<tr class="memdesc:abcfc8663664126a6413cdc39f6285012"><td class="mdescLeft">&#160;</td><td class="mdescRight">启用或禁用钩子  <br /></td></tr>
<tr class="separator:abcfc8663664126a6413cdc39f6285012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ba7881936d96ed1f52922d00b57d0" id="r_a385ba7881936d96ed1f52922d00b57d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a385ba7881936d96ed1f52922d00b57d0">step_calc</a> ()</td></tr>
<tr class="memdesc:a385ba7881936d96ed1f52922d00b57d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">单步计算  <br /></td></tr>
<tr class="separator:a385ba7881936d96ed1f52922d00b57d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d146399844e3a212623042682a66f0" id="r_a25d146399844e3a212623042682a66f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a25d146399844e3a212623042682a66f0">handle_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *curTick, uint32_t pxType=0) override</td></tr>
<tr class="memdesc:a25d146399844e3a212623042682a66f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理Tick数据  <br /></td></tr>
<tr class="separator:a25d146399844e3a212623042682a66f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeecff95f38049ea695f93b637c968bf" id="r_aaeecff95f38049ea695f93b637c968bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aaeecff95f38049ea695f93b637c968bf">handle_bar_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t times, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:aaeecff95f38049ea695f93b637c968bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理K线关闭  <br /></td></tr>
<tr class="separator:aaeecff95f38049ea695f93b637c968bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4e4a7638b0239a861673e43a7a7038" id="r_a1d4e4a7638b0239a861673e43a7a7038"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a1d4e4a7638b0239a861673e43a7a7038">handle_schedule</a> (uint32_t uDate, uint32_t uTime) override</td></tr>
<tr class="memdesc:a1d4e4a7638b0239a861673e43a7a7038"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理调度事件  <br /></td></tr>
<tr class="separator:a1d4e4a7638b0239a861673e43a7a7038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6da3819230342327805aa435ae69d7" id="r_a6e6da3819230342327805aa435ae69d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a6e6da3819230342327805aa435ae69d7">handle_init</a> () override</td></tr>
<tr class="memdesc:a6e6da3819230342327805aa435ae69d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理初始化  <br /></td></tr>
<tr class="separator:a6e6da3819230342327805aa435ae69d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b78d796d70c20b2c0609e6fa43bc708" id="r_a2b78d796d70c20b2c0609e6fa43bc708"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a2b78d796d70c20b2c0609e6fa43bc708">handle_session_begin</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:a2b78d796d70c20b2c0609e6fa43bc708"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易日开始  <br /></td></tr>
<tr class="separator:a2b78d796d70c20b2c0609e6fa43bc708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69304e304883666400973a2f70c68455" id="r_a69304e304883666400973a2f70c68455"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a69304e304883666400973a2f70c68455">handle_session_end</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:a69304e304883666400973a2f70c68455"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易日结束  <br /></td></tr>
<tr class="separator:a69304e304883666400973a2f70c68455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf3d36e182ec784cac99877f6d5f5c4" id="r_aaaf3d36e182ec784cac99877f6d5f5c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aaaf3d36e182ec784cac99877f6d5f5c4">handle_section_end</a> (uint32_t curTDate, uint32_t curTime) override</td></tr>
<tr class="memdesc:aaaf3d36e182ec784cac99877f6d5f5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理交易时段结束  <br /></td></tr>
<tr class="separator:aaaf3d36e182ec784cac99877f6d5f5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3378ca58a307aa37163f1e822902a159" id="r_a3378ca58a307aa37163f1e822902a159"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a3378ca58a307aa37163f1e822902a159">handle_replay_done</a> () override</td></tr>
<tr class="memdesc:a3378ca58a307aa37163f1e822902a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理回放完成  <br /></td></tr>
<tr class="separator:a3378ca58a307aa37163f1e822902a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f85dbad629ef629d8190985d2edef5" id="r_ab8f85dbad629ef629d8190985d2edef5"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ab8f85dbad629ef629d8190985d2edef5">id</a> ()</td></tr>
<tr class="memdesc:ab8f85dbad629ef629d8190985d2edef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取策略上下文ID  <br /></td></tr>
<tr class="separator:ab8f85dbad629ef629d8190985d2edef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107ca2e682729b1ab51db4eecd40dad" id="r_aa107ca2e682729b1ab51db4eecd40dad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa107ca2e682729b1ab51db4eecd40dad">on_init</a> () override</td></tr>
<tr class="memdesc:aa107ca2e682729b1ab51db4eecd40dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">初始化回调  <br /></td></tr>
<tr class="separator:aa107ca2e682729b1ab51db4eecd40dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefd08688ebc435d349710ecbc4939ed" id="r_abefd08688ebc435d349710ecbc4939ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#abefd08688ebc435d349710ecbc4939ed">on_session_begin</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:abefd08688ebc435d349710ecbc4939ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日开始回调  <br /></td></tr>
<tr class="separator:abefd08688ebc435d349710ecbc4939ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c50839206c3c9f52a8d92e5eb4ed12" id="r_a90c50839206c3c9f52a8d92e5eb4ed12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a90c50839206c3c9f52a8d92e5eb4ed12">on_session_end</a> (uint32_t curTDate) override</td></tr>
<tr class="memdesc:a90c50839206c3c9f52a8d92e5eb4ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日结束回调  <br /></td></tr>
<tr class="separator:a90c50839206c3c9f52a8d92e5eb4ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71df70ff014ab1ba65a0bbd9b3543881" id="r_a71df70ff014ab1ba65a0bbd9b3543881"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a71df70ff014ab1ba65a0bbd9b3543881">on_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick, bool bEmitStrategy=true) override</td></tr>
<tr class="memdesc:a71df70ff014ab1ba65a0bbd9b3543881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick数据回调  <br /></td></tr>
<tr class="separator:a71df70ff014ab1ba65a0bbd9b3543881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9e32eb93635cc9da7c285ff6806b68" id="r_a6a9e32eb93635cc9da7c285ff6806b68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a6a9e32eb93635cc9da7c285ff6806b68">on_bar</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t times, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:a6a9e32eb93635cc9da7c285ff6806b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线数据回调  <br /></td></tr>
<tr class="separator:a6a9e32eb93635cc9da7c285ff6806b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fae10edb81dd7a6cce9228ecd16866" id="r_a24fae10edb81dd7a6cce9228ecd16866"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a24fae10edb81dd7a6cce9228ecd16866">on_schedule</a> (uint32_t curDate, uint32_t curTime) override</td></tr>
<tr class="memdesc:a24fae10edb81dd7a6cce9228ecd16866"><td class="mdescLeft">&#160;</td><td class="mdescRight">定时调度回调  <br /></td></tr>
<tr class="separator:a24fae10edb81dd7a6cce9228ecd16866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd8f0c6ea285dfebf728bb642919ec6" id="r_aacd8f0c6ea285dfebf728bb642919ec6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aacd8f0c6ea285dfebf728bb642919ec6">enum_position</a> (<a class="el" href="ICtaStraCtx_8h.html#ae91c21a4f808e56c0dcf692873157a9e">FuncEnumCtaPosCallBack</a> cb, bool bForExecute) override</td></tr>
<tr class="memdesc:aacd8f0c6ea285dfebf728bb642919ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">枚举持仓回调  <br /></td></tr>
<tr class="separator:aacd8f0c6ea285dfebf728bb642919ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab720557f7a5d17cb9e4b0a76cc22c45f" id="r_ab720557f7a5d17cb9e4b0a76cc22c45f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ab720557f7a5d17cb9e4b0a76cc22c45f">on_tick_updated</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTickData.html">WTSTickData</a> *newTick) override</td></tr>
<tr class="memdesc:ab720557f7a5d17cb9e4b0a76cc22c45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick数据更新回调  <br /></td></tr>
<tr class="separator:ab720557f7a5d17cb9e4b0a76cc22c45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344c481d4f657b7e2c35a8566f055fe7" id="r_a344c481d4f657b7e2c35a8566f055fe7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a344c481d4f657b7e2c35a8566f055fe7">on_bar_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, <a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *newBar) override</td></tr>
<tr class="memdesc:a344c481d4f657b7e2c35a8566f055fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线关闭回调  <br /></td></tr>
<tr class="separator:a344c481d4f657b7e2c35a8566f055fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a957a84fbe7f105a768b54fe713b87a" id="r_a9a957a84fbe7f105a768b54fe713b87a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9a957a84fbe7f105a768b54fe713b87a">on_calculate</a> (uint32_t curDate, uint32_t curTime) override</td></tr>
<tr class="memdesc:a9a957a84fbe7f105a768b54fe713b87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算回调  <br /></td></tr>
<tr class="separator:a9a957a84fbe7f105a768b54fe713b87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017edf9c5cac0a09194e73769c2e02b0" id="r_a017edf9c5cac0a09194e73769c2e02b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a017edf9c5cac0a09194e73769c2e02b0">stra_enter_long</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;, double limitprice=0.0, double stopprice=0.0) override</td></tr>
<tr class="memdesc:a017edf9c5cac0a09194e73769c2e02b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">开多仓接口  <br /></td></tr>
<tr class="separator:a017edf9c5cac0a09194e73769c2e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5320b6458dafc391c76b064ded9af181" id="r_a5320b6458dafc391c76b064ded9af181"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a5320b6458dafc391c76b064ded9af181">stra_enter_short</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;, double limitprice=0.0, double stopprice=0.0) override</td></tr>
<tr class="memdesc:a5320b6458dafc391c76b064ded9af181"><td class="mdescLeft">&#160;</td><td class="mdescRight">开空仓接口  <br /></td></tr>
<tr class="separator:a5320b6458dafc391c76b064ded9af181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7ac26f273a037e4c091290c010c101" id="r_ada7ac26f273a037e4c091290c010c101"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ada7ac26f273a037e4c091290c010c101">stra_exit_long</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;, double limitprice=0.0, double stopprice=0.0) override</td></tr>
<tr class="memdesc:ada7ac26f273a037e4c091290c010c101"><td class="mdescLeft">&#160;</td><td class="mdescRight">平多仓接口  <br /></td></tr>
<tr class="separator:ada7ac26f273a037e4c091290c010c101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfd93cb52b7aed2744ce89f165e7441" id="r_a6bfd93cb52b7aed2744ce89f165e7441"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a6bfd93cb52b7aed2744ce89f165e7441">stra_exit_short</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;, double limitprice=0.0, double stopprice=0.0) override</td></tr>
<tr class="memdesc:a6bfd93cb52b7aed2744ce89f165e7441"><td class="mdescLeft">&#160;</td><td class="mdescRight">平空仓接口  <br /></td></tr>
<tr class="separator:a6bfd93cb52b7aed2744ce89f165e7441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d014397a980ebb1ccd3844de0a001a9" id="r_a9d014397a980ebb1ccd3844de0a001a9"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9d014397a980ebb1ccd3844de0a001a9">stra_get_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool bOnlyValid=false, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;) override</td></tr>
<tr class="memdesc:a9d014397a980ebb1ccd3844de0a001a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取仓位接口  <br /></td></tr>
<tr class="separator:a9d014397a980ebb1ccd3844de0a001a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae822bae83c859d67a729865e44cef8" id="r_a9ae822bae83c859d67a729865e44cef8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9ae822bae83c859d67a729865e44cef8">stra_set_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;, double limitprice=0.0, double stopprice=0.0) override</td></tr>
<tr class="memdesc:a9ae822bae83c859d67a729865e44cef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置仓位接口  <br /></td></tr>
<tr class="separator:a9ae822bae83c859d67a729865e44cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c54a2f806b69b2207689308a91ce94f" id="r_a3c54a2f806b69b2207689308a91ce94f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a3c54a2f806b69b2207689308a91ce94f">stra_get_price</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a3c54a2f806b69b2207689308a91ce94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前价格接口  <br /></td></tr>
<tr class="separator:a3c54a2f806b69b2207689308a91ce94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8400b42c0684f4d305ccfc7f074807c0" id="r_a8400b42c0684f4d305ccfc7f074807c0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a8400b42c0684f4d305ccfc7f074807c0">stra_get_day_price</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, int flag=0) override</td></tr>
<tr class="memdesc:a8400b42c0684f4d305ccfc7f074807c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当日价格接口  <br /></td></tr>
<tr class="separator:a8400b42c0684f4d305ccfc7f074807c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e59b1bc274339781952a11221384385" id="r_a4e59b1bc274339781952a11221384385"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a4e59b1bc274339781952a11221384385">stra_get_tdate</a> () override</td></tr>
<tr class="memdesc:a4e59b1bc274339781952a11221384385"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前交易日接口  <br /></td></tr>
<tr class="separator:a4e59b1bc274339781952a11221384385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab080a3a984a9f88836d15ad82767d10a" id="r_ab080a3a984a9f88836d15ad82767d10a"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ab080a3a984a9f88836d15ad82767d10a">stra_get_date</a> () override</td></tr>
<tr class="memdesc:ab080a3a984a9f88836d15ad82767d10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前日期接口  <br /></td></tr>
<tr class="separator:ab080a3a984a9f88836d15ad82767d10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c5e2d22211e6e9975177476e0e2364" id="r_a07c5e2d22211e6e9975177476e0e2364"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a07c5e2d22211e6e9975177476e0e2364">stra_get_time</a> () override</td></tr>
<tr class="memdesc:a07c5e2d22211e6e9975177476e0e2364"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前时间接口  <br /></td></tr>
<tr class="separator:a07c5e2d22211e6e9975177476e0e2364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc433563a858a7818bf875eadab14c" id="r_a38cc433563a858a7818bf875eadab14c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a38cc433563a858a7818bf875eadab14c">stra_get_fund_data</a> (int flag=0) override</td></tr>
<tr class="memdesc:a38cc433563a858a7818bf875eadab14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取资金数据接口  <br /></td></tr>
<tr class="separator:a38cc433563a858a7818bf875eadab14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d09ae73d992e230679627897f48d142" id="r_a9d09ae73d992e230679627897f48d142"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9d09ae73d992e230679627897f48d142">stra_get_first_entertime</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a9d09ae73d992e230679627897f48d142"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取首次开仓时间接口  <br /></td></tr>
<tr class="separator:a9d09ae73d992e230679627897f48d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22db2228875bf38e774e3cab3732f648" id="r_a22db2228875bf38e774e3cab3732f648"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a22db2228875bf38e774e3cab3732f648">stra_get_last_entertime</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a22db2228875bf38e774e3cab3732f648"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最近开仓时间接口  <br /></td></tr>
<tr class="separator:a22db2228875bf38e774e3cab3732f648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3dce5566a3bc53d65cc15a62fae7bd" id="r_a5f3dce5566a3bc53d65cc15a62fae7bd"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a5f3dce5566a3bc53d65cc15a62fae7bd">stra_get_last_exittime</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a5f3dce5566a3bc53d65cc15a62fae7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最近平仓时间接口  <br /></td></tr>
<tr class="separator:a5f3dce5566a3bc53d65cc15a62fae7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc9e9d86db9f1cba6ebaecd495166b" id="r_a44fc9e9d86db9f1cba6ebaecd495166b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a44fc9e9d86db9f1cba6ebaecd495166b">stra_get_last_enterprice</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a44fc9e9d86db9f1cba6ebaecd495166b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最近开仓价格接口  <br /></td></tr>
<tr class="separator:a44fc9e9d86db9f1cba6ebaecd495166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dd1d1e4be89358a790cbc4bd9efe48" id="r_a88dd1d1e4be89358a790cbc4bd9efe48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a88dd1d1e4be89358a790cbc4bd9efe48">stra_get_last_entertag</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a88dd1d1e4be89358a790cbc4bd9efe48"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最近开仓标记接口  <br /></td></tr>
<tr class="separator:a88dd1d1e4be89358a790cbc4bd9efe48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070a89f9aa526ad24dc8a48619a18185" id="r_a070a89f9aa526ad24dc8a48619a18185"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a070a89f9aa526ad24dc8a48619a18185">stra_get_position_avgpx</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a070a89f9aa526ad24dc8a48619a18185"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取持仓均价接口  <br /></td></tr>
<tr class="separator:a070a89f9aa526ad24dc8a48619a18185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2083a28dda923242144bfecc4a677be" id="r_ab2083a28dda923242144bfecc4a677be"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ab2083a28dda923242144bfecc4a677be">stra_get_position_profit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:ab2083a28dda923242144bfecc4a677be"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取持仓盈亏接口  <br /></td></tr>
<tr class="separator:ab2083a28dda923242144bfecc4a677be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fa5daaf6894d98ec41a2437f80090c" id="r_ae6fa5daaf6894d98ec41a2437f80090c"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ae6fa5daaf6894d98ec41a2437f80090c">stra_get_detail_entertime</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag) override</td></tr>
<tr class="memdesc:ae6fa5daaf6894d98ec41a2437f80090c"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取详细开仓时间接口  <br /></td></tr>
<tr class="separator:ae6fa5daaf6894d98ec41a2437f80090c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc55a17b3939ca6d3f832e36f69bdb70" id="r_abc55a17b3939ca6d3f832e36f69bdb70"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#abc55a17b3939ca6d3f832e36f69bdb70">stra_get_detail_cost</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag) override</td></tr>
<tr class="memdesc:abc55a17b3939ca6d3f832e36f69bdb70"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取详细开仓成本接口  <br /></td></tr>
<tr class="separator:abc55a17b3939ca6d3f832e36f69bdb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88032d30a6a140b0a6932076348b5962" id="r_a88032d30a6a140b0a6932076348b5962"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a88032d30a6a140b0a6932076348b5962">stra_get_detail_profit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, int flag=0) override</td></tr>
<tr class="memdesc:a88032d30a6a140b0a6932076348b5962"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取详细盈亏接口  <br /></td></tr>
<tr class="separator:a88032d30a6a140b0a6932076348b5962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28cc8413611185bcc6797776452fe6b" id="r_af28cc8413611185bcc6797776452fe6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSCommodityInfo.html">WTSCommodityInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#af28cc8413611185bcc6797776452fe6b">stra_get_comminfo</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:af28cc8413611185bcc6797776452fe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取品种信息接口  <br /></td></tr>
<tr class="separator:af28cc8413611185bcc6797776452fe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea08684bf163c866887ad05ccd4421" id="r_a73ea08684bf163c866887ad05ccd4421"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSKlineSlice.html">WTSKlineSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a73ea08684bf163c866887ad05ccd4421">stra_get_bars</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period, uint32_t count, bool isMain=false) override</td></tr>
<tr class="memdesc:a73ea08684bf163c866887ad05ccd4421"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取K线切片接口  <br /></td></tr>
<tr class="separator:a73ea08684bf163c866887ad05ccd4421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af779b88b6bb26f659170a7fc52e1be00" id="r_af779b88b6bb26f659170a7fc52e1be00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTickSlice.html">WTSTickSlice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#af779b88b6bb26f659170a7fc52e1be00">stra_get_ticks</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, uint32_t count) override</td></tr>
<tr class="memdesc:af779b88b6bb26f659170a7fc52e1be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取Tick切片接口  <br /></td></tr>
<tr class="separator:af779b88b6bb26f659170a7fc52e1be00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfafbc192125086ef451abc655361ff" id="r_a3cfafbc192125086ef451abc655361ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a3cfafbc192125086ef451abc655361ff">stra_get_last_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a3cfafbc192125086ef451abc655361ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取最新Tick接口  <br /></td></tr>
<tr class="separator:a3cfafbc192125086ef451abc655361ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719a5fd852ce1c57e3e7c49319f4b155" id="r_a719a5fd852ce1c57e3e7c49319f4b155"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a719a5fd852ce1c57e3e7c49319f4b155">stra_sub_ticks</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:a719a5fd852ce1c57e3e7c49319f4b155"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅Tick数据接口  <br /></td></tr>
<tr class="separator:a719a5fd852ce1c57e3e7c49319f4b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819e1ff81585820db0c64901f377aac3" id="r_a819e1ff81585820db0c64901f377aac3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a819e1ff81585820db0c64901f377aac3">stra_sub_bar_events</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period) override</td></tr>
<tr class="memdesc:a819e1ff81585820db0c64901f377aac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">订阅K线事件接口  <br /></td></tr>
<tr class="separator:a819e1ff81585820db0c64901f377aac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9e3ac7c4e78fe43788d01c7ef008ff" id="r_aae9e3ac7c4e78fe43788d01c7ef008ff"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aae9e3ac7c4e78fe43788d01c7ef008ff">stra_get_rawcode</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode) override</td></tr>
<tr class="memdesc:aae9e3ac7c4e78fe43788d01c7ef008ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取原始合约代码接口  <br /></td></tr>
<tr class="separator:aae9e3ac7c4e78fe43788d01c7ef008ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9bfe4ccac679bd6278fa979aeb410d" id="r_abb9bfe4ccac679bd6278fa979aeb410d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#abb9bfe4ccac679bd6278fa979aeb410d">stra_log_info</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:abb9bfe4ccac679bd6278fa979aeb410d"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录信息日志接口  <br /></td></tr>
<tr class="separator:abb9bfe4ccac679bd6278fa979aeb410d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1200a5cb925e247e7d7d90127efe2bd2" id="r_a1200a5cb925e247e7d7d90127efe2bd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a1200a5cb925e247e7d7d90127efe2bd2">stra_log_debug</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:a1200a5cb925e247e7d7d90127efe2bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录调试日志接口  <br /></td></tr>
<tr class="separator:a1200a5cb925e247e7d7d90127efe2bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa187f636b44136b97910adc7cc09344b" id="r_aa187f636b44136b97910adc7cc09344b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa187f636b44136b97910adc7cc09344b">stra_log_warn</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:aa187f636b44136b97910adc7cc09344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录警告日志接口  <br /></td></tr>
<tr class="separator:aa187f636b44136b97910adc7cc09344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7693915ffc0e5aee6cf7dd9f8f99170c" id="r_a7693915ffc0e5aee6cf7dd9f8f99170c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a7693915ffc0e5aee6cf7dd9f8f99170c">stra_log_error</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *message) override</td></tr>
<tr class="memdesc:a7693915ffc0e5aee6cf7dd9f8f99170c"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录错误日志接口  <br /></td></tr>
<tr class="separator:a7693915ffc0e5aee6cf7dd9f8f99170c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa637c47ce66e6982f23cf9810472b870" id="r_aa637c47ce66e6982f23cf9810472b870"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa637c47ce66e6982f23cf9810472b870">stra_save_user_data</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *key, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *val) override</td></tr>
<tr class="memdesc:aa637c47ce66e6982f23cf9810472b870"><td class="mdescLeft">&#160;</td><td class="mdescRight">保存用户数据接口  <br /></td></tr>
<tr class="separator:aa637c47ce66e6982f23cf9810472b870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653786dcd9ecbb9d4723396668c8dabc" id="r_a653786dcd9ecbb9d4723396668c8dabc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a653786dcd9ecbb9d4723396668c8dabc">stra_load_user_data</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *key, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *defVal=&quot;&quot;) override</td></tr>
<tr class="memdesc:a653786dcd9ecbb9d4723396668c8dabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">加载用户数据接口  <br /></td></tr>
<tr class="separator:a653786dcd9ecbb9d4723396668c8dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e0d562c13ad93b1603d0f749e7682" id="r_ae72e0d562c13ad93b1603d0f749e7682"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ae72e0d562c13ad93b1603d0f749e7682">set_chart_kline</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *period) override</td></tr>
<tr class="memdesc:ae72e0d562c13ad93b1603d0f749e7682"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置图表K线接口  <br /></td></tr>
<tr class="separator:ae72e0d562c13ad93b1603d0f749e7682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d55ebca2ad26a2dc1a2a93965b84435" id="r_a8d55ebca2ad26a2dc1a2a93965b84435"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a8d55ebca2ad26a2dc1a2a93965b84435">add_chart_mark</a> (double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *icon, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *tag) override</td></tr>
<tr class="memdesc:a8d55ebca2ad26a2dc1a2a93965b84435"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加图表标记接口  <br /></td></tr>
<tr class="separator:a8d55ebca2ad26a2dc1a2a93965b84435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde7808a9ecd363da5e7bc35295f9920" id="r_acde7808a9ecd363da5e7bc35295f9920"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#acde7808a9ecd363da5e7bc35295f9920">register_index</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *idxName, uint32_t indexType) override</td></tr>
<tr class="memdesc:acde7808a9ecd363da5e7bc35295f9920"><td class="mdescLeft">&#160;</td><td class="mdescRight">注册图表指标接口  <br /></td></tr>
<tr class="separator:acde7808a9ecd363da5e7bc35295f9920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad238a2fb0263572adb75c70f72530ac2" id="r_ad238a2fb0263572adb75c70f72530ac2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ad238a2fb0263572adb75c70f72530ac2">register_index_line</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *idxName, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *lineName, uint32_t lineType) override</td></tr>
<tr class="memdesc:ad238a2fb0263572adb75c70f72530ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">注册指标线接口  <br /></td></tr>
<tr class="separator:ad238a2fb0263572adb75c70f72530ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4f546fbcb4540cf25760ffc1034f47" id="r_aad4f546fbcb4540cf25760ffc1034f47"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aad4f546fbcb4540cf25760ffc1034f47">add_index_baseline</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *idxName, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *lineName, double val) override</td></tr>
<tr class="memdesc:aad4f546fbcb4540cf25760ffc1034f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加指标基准线接口  <br /></td></tr>
<tr class="separator:aad4f546fbcb4540cf25760ffc1034f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e109dc3a6723024cfb77a7ece700a0" id="r_a87e109dc3a6723024cfb77a7ece700a0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a87e109dc3a6723024cfb77a7ece700a0">set_index_value</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *idxName, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *lineName, double val) override</td></tr>
<tr class="memdesc:a87e109dc3a6723024cfb77a7ece700a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置指标值接口  <br /></td></tr>
<tr class="separator:a87e109dc3a6723024cfb77a7ece700a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classICtaStraCtx"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classICtaStraCtx')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classICtaStraCtx.html">ICtaStraCtx</a></td></tr>
<tr class="memitem:ae5ba7d8eefc9766bedb28186f9517ef5 inherit pub_methods_classICtaStraCtx" id="r_ae5ba7d8eefc9766bedb28186f9517ef5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#ae5ba7d8eefc9766bedb28186f9517ef5">ICtaStraCtx</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="classICtaStraCtx.html#a5204938d188c461217d7d7069760e331">name</a>)</td></tr>
<tr class="memdesc:ae5ba7d8eefc9766bedb28186f9517ef5 inherit pub_methods_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">构造函数  <br /></td></tr>
<tr class="separator:ae5ba7d8eefc9766bedb28186f9517ef5 inherit pub_methods_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967fc24a67690b92a4dbbfb9001f8234 inherit pub_methods_classICtaStraCtx" id="r_a967fc24a67690b92a4dbbfb9001f8234"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#a967fc24a67690b92a4dbbfb9001f8234">~ICtaStraCtx</a> ()</td></tr>
<tr class="memdesc:a967fc24a67690b92a4dbbfb9001f8234 inherit pub_methods_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">虚析构函数  <br /></td></tr>
<tr class="separator:a967fc24a67690b92a4dbbfb9001f8234 inherit pub_methods_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5204938d188c461217d7d7069760e331 inherit pub_methods_classICtaStraCtx" id="r_a5204938d188c461217d7d7069760e331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#a5204938d188c461217d7d7069760e331">name</a> () <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a></td></tr>
<tr class="memdesc:a5204938d188c461217d7d7069760e331 inherit pub_methods_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取策略名称  <br /></td></tr>
<tr class="separator:a5204938d188c461217d7d7069760e331 inherit pub_methods_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492949ccaba9af4a54fcbaaa1b187a70 inherit pub_methods_classICtaStraCtx" id="r_a492949ccaba9af4a54fcbaaa1b187a70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#a492949ccaba9af4a54fcbaaa1b187a70">on_bactest_end</a> ()</td></tr>
<tr class="memdesc:a492949ccaba9af4a54fcbaaa1b187a70 inherit pub_methods_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">回测结束事件  <br /></td></tr>
<tr class="separator:a492949ccaba9af4a54fcbaaa1b187a70 inherit pub_methods_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a853c7591a03f3879802ccff759c3c0 inherit pub_methods_classICtaStraCtx" id="r_a2a853c7591a03f3879802ccff759c3c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#a2a853c7591a03f3879802ccff759c3c0">on_calculate_done</a> (uint32_t curDate, uint32_t curTime)</td></tr>
<tr class="memdesc:a2a853c7591a03f3879802ccff759c3c0 inherit pub_methods_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">重算结束事件  <br /></td></tr>
<tr class="separator:a2a853c7591a03f3879802ccff759c3c0 inherit pub_methods_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315ff16a763b101a043f57ea5921a517 inherit pub_methods_classICtaStraCtx" id="r_a315ff16a763b101a043f57ea5921a517"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#a315ff16a763b101a043f57ea5921a517">on_condition_triggered</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double target, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *usertag)</td></tr>
<tr class="memdesc:a315ff16a763b101a043f57ea5921a517 inherit pub_methods_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">条件触发事件  <br /></td></tr>
<tr class="separator:a315ff16a763b101a043f57ea5921a517 inherit pub_methods_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIDataSink"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIDataSink')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classIDataSink.html">IDataSink</a></td></tr>
<tr class="memitem:ac0ac665e5f5e9330b4847393a8d5a253 inherit pub_methods_classIDataSink" id="r_ac0ac665e5f5e9330b4847393a8d5a253"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDataSink.html#ac0ac665e5f5e9330b4847393a8d5a253">handle_order_queue</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdQueData.html">WTSOrdQueData</a> *curOrdQue)</td></tr>
<tr class="memdesc:ac0ac665e5f5e9330b4847393a8d5a253 inherit pub_methods_classIDataSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理委托队列数据  <br /></td></tr>
<tr class="separator:ac0ac665e5f5e9330b4847393a8d5a253 inherit pub_methods_classIDataSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab181668bb73591a42e322dbc4a32ff8a inherit pub_methods_classIDataSink" id="r_ab181668bb73591a42e322dbc4a32ff8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDataSink.html#ab181668bb73591a42e322dbc4a32ff8a">handle_order_detail</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSOrdDtlData.html">WTSOrdDtlData</a> *curOrdDtl)</td></tr>
<tr class="memdesc:ab181668bb73591a42e322dbc4a32ff8a inherit pub_methods_classIDataSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理委托明细数据  <br /></td></tr>
<tr class="separator:ab181668bb73591a42e322dbc4a32ff8a inherit pub_methods_classIDataSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdeadd1cef35b1976dfb8dcb8b82aab inherit pub_methods_classIDataSink" id="r_a1bdeadd1cef35b1976dfb8dcb8b82aab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIDataSink.html#a1bdeadd1cef35b1976dfb8dcb8b82aab">handle_transaction</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, <a class="el" href="classWTSTransData.html">WTSTransData</a> *curTrans)</td></tr>
<tr class="memdesc:a1bdeadd1cef35b1976dfb8dcb8b82aab inherit pub_methods_classIDataSink"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理逐笔成交数据  <br /></td></tr>
<tr class="separator:a1bdeadd1cef35b1976dfb8dcb8b82aab inherit pub_methods_classIDataSink"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-types" name="pro-types"></a>
Protected 类型</h2></td></tr>
<tr class="memitem:a90d7d5606401b1b4a9f124759f9cde69" id="r_a90d7d5606401b1b4a9f124759f9cde69"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__KlineTag.html">CtaMocker::_KlineTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a90d7d5606401b1b4a9f124759f9cde69">KlineTag</a></td></tr>
<tr class="memdesc:a90d7d5606401b1b4a9f124759f9cde69"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线标记结构体  <br /></td></tr>
<tr class="separator:a90d7d5606401b1b4a9f124759f9cde69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0766982fe9521f3ec9afafd83df7b7f8" id="r_a0766982fe9521f3ec9afafd83df7b7f8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, <a class="el" href="classCtaMocker.html#a90d7d5606401b1b4a9f124759f9cde69">KlineTag</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a0766982fe9521f3ec9afafd83df7b7f8">KlineTags</a></td></tr>
<tr class="memdesc:a0766982fe9521f3ec9afafd83df7b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">K线标记映射类型  <br /></td></tr>
<tr class="separator:a0766982fe9521f3ec9afafd83df7b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578f5d7d25d9854dd58cde8aad11078" id="r_ac578f5d7d25d9854dd58cde8aad11078"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ac578f5d7d25d9854dd58cde8aad11078">PriceMap</a></td></tr>
<tr class="memdesc:ac578f5d7d25d9854dd58cde8aad11078"><td class="mdescLeft">&#160;</td><td class="mdescRight">价格映射类型  <br /></td></tr>
<tr class="separator:ac578f5d7d25d9854dd58cde8aad11078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace46338636637236841a2893fffa93f8" id="r_ace46338636637236841a2893fffa93f8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__DetailInfo.html">CtaMocker::_DetailInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ace46338636637236841a2893fffa93f8">DetailInfo</a></td></tr>
<tr class="memdesc:ace46338636637236841a2893fffa93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易详情结构体  <br /></td></tr>
<tr class="separator:ace46338636637236841a2893fffa93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835efe4b428ccad0a28891db697ac0f0" id="r_a835efe4b428ccad0a28891db697ac0f0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__PosInfo.html">CtaMocker::_PosInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a835efe4b428ccad0a28891db697ac0f0">PosInfo</a></td></tr>
<tr class="memdesc:a835efe4b428ccad0a28891db697ac0f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓信息结构体  <br /></td></tr>
<tr class="separator:a835efe4b428ccad0a28891db697ac0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c333945310f2dea8d646e176a7943f8" id="r_a4c333945310f2dea8d646e176a7943f8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, <a class="el" href="classCtaMocker.html#a835efe4b428ccad0a28891db697ac0f0">PosInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a4c333945310f2dea8d646e176a7943f8">PositionMap</a></td></tr>
<tr class="memdesc:a4c333945310f2dea8d646e176a7943f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓映射类型  <br /></td></tr>
<tr class="separator:a4c333945310f2dea8d646e176a7943f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd60df10691b15396594e07b5ed5fafa" id="r_acd60df10691b15396594e07b5ed5fafa"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__SigInfo.html">CtaMocker::_SigInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#acd60df10691b15396594e07b5ed5fafa">SigInfo</a></td></tr>
<tr class="memdesc:acd60df10691b15396594e07b5ed5fafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">信号信息结构体  <br /></td></tr>
<tr class="separator:acd60df10691b15396594e07b5ed5fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893cd4399b7a826330d8410115732a6" id="r_a1893cd4399b7a826330d8410115732a6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, <a class="el" href="classCtaMocker.html#acd60df10691b15396594e07b5ed5fafa">SigInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a1893cd4399b7a826330d8410115732a6">SignalMap</a></td></tr>
<tr class="memdesc:a1893cd4399b7a826330d8410115732a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">信号映射类型  <br /></td></tr>
<tr class="separator:a1893cd4399b7a826330d8410115732a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7ef58a183d7574fc9f4ddda1e06b64" id="r_a3d7ef58a183d7574fc9f4ddda1e06b64"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a3d7ef58a183d7574fc9f4ddda1e06b64">StringHashMap</a></td></tr>
<tr class="memdesc:a3d7ef58a183d7574fc9f4ddda1e06b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户数据相关  <br /></td></tr>
<tr class="separator:a3d7ef58a183d7574fc9f4ddda1e06b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bbaf8e935f00f08040d8ce239f1611" id="r_a36bbaf8e935f00f08040d8ce239f1611"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__StraFundInfo.html">CtaMocker::_StraFundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a36bbaf8e935f00f08040d8ce239f1611">StraFundInfo</a></td></tr>
<tr class="memdesc:a36bbaf8e935f00f08040d8ce239f1611"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息结构体  <br /></td></tr>
<tr class="separator:a36bbaf8e935f00f08040d8ce239f1611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a18d658ae4f719289fdf03fbe9630b" id="r_a67a18d658ae4f719289fdf03fbe9630b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__StraFactInfo.html">CtaMocker::_StraFactInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a67a18d658ae4f719289fdf03fbe9630b">StraFactInfo</a></td></tr>
<tr class="memdesc:a67a18d658ae4f719289fdf03fbe9630b"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息结构体  <br /></td></tr>
<tr class="separator:a67a18d658ae4f719289fdf03fbe9630b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdf1f30007df7abd9e8a18c8ce784cd" id="r_a6fdf1f30007df7abd9e8a18c8ce784cd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__ChartLine.html">CtaMocker::_ChartLine</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a6fdf1f30007df7abd9e8a18c8ce784cd">ChartLine</a></td></tr>
<tr class="memdesc:a6fdf1f30007df7abd9e8a18c8ce784cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表线结构体  <br /></td></tr>
<tr class="separator:a6fdf1f30007df7abd9e8a18c8ce784cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39569986e35ad1307b12488e9b94781" id="r_ab39569986e35ad1307b12488e9b94781"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structCtaMocker_1_1__ChartIndex.html">CtaMocker::_ChartIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ab39569986e35ad1307b12488e9b94781">ChartIndex</a></td></tr>
<tr class="memdesc:ab39569986e35ad1307b12488e9b94781"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表指标结构体  <br /></td></tr>
<tr class="separator:ab39569986e35ad1307b12488e9b94781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9227a7402c399bd1e8072d2d56dbc751" id="r_a9227a7402c399bd1e8072d2d56dbc751"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt; std::string, <a class="el" href="structWTSTickStruct.html">WTSTickStruct</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9227a7402c399bd1e8072d2d56dbc751">TickCache</a></td></tr>
<tr class="memdesc:a9227a7402c399bd1e8072d2d56dbc751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick缓存类型  <br /></td></tr>
<tr class="separator:a9227a7402c399bd1e8072d2d56dbc751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:af59ec7e8021dbaa6cce7a92e197172ab" id="r_af59ec7e8021dbaa6cce7a92e197172ab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#af59ec7e8021dbaa6cce7a92e197172ab">_context_id</a></td></tr>
<tr class="memdesc:af59ec7e8021dbaa6cce7a92e197172ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略上下文ID，策略实例的唯一标识符  <br /></td></tr>
<tr class="separator:af59ec7e8021dbaa6cce7a92e197172ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c583c09c23f47248ae0ddef73b486a" id="r_a48c583c09c23f47248ae0ddef73b486a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a48c583c09c23f47248ae0ddef73b486a">_replayer</a></td></tr>
<tr class="memdesc:a48c583c09c23f47248ae0ddef73b486a"><td class="mdescLeft">&#160;</td><td class="mdescRight">历史数据回放器，用于提供回测所需的历史数据  <br /></td></tr>
<tr class="separator:a48c583c09c23f47248ae0ddef73b486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000079dd98dbd539a3f7929dc27c8fa1" id="r_a000079dd98dbd539a3f7929dc27c8fa1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a000079dd98dbd539a3f7929dc27c8fa1">_total_calc_time</a></td></tr>
<tr class="separator:a000079dd98dbd539a3f7929dc27c8fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ed8ba7b589e116f914792a278dc2b5" id="r_af6ed8ba7b589e116f914792a278dc2b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#af6ed8ba7b589e116f914792a278dc2b5">_emit_times</a></td></tr>
<tr class="separator:af6ed8ba7b589e116f914792a278dc2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4de9106ac4cbf84d61af7a4f8efbb6" id="r_a9a4de9106ac4cbf84d61af7a4f8efbb6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9a4de9106ac4cbf84d61af7a4f8efbb6">_slippage</a></td></tr>
<tr class="memdesc:a9a4de9106ac4cbf84d61af7a4f8efbb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">成交滑点，如果是比例滑点，则为万分比  <br /></td></tr>
<tr class="separator:a9a4de9106ac4cbf84d61af7a4f8efbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd947fedd7280b658c9cc18bd968c3f4" id="r_afd947fedd7280b658c9cc18bd968c3f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#afd947fedd7280b658c9cc18bd968c3f4">_ratio_slippage</a></td></tr>
<tr class="memdesc:afd947fedd7280b658c9cc18bd968c3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否比例滑点，标记滑点是固定点数还是按比例计算  <br /></td></tr>
<tr class="separator:afd947fedd7280b658c9cc18bd968c3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e04fd161ad84e22623fb4fa6b1c58c" id="r_a27e04fd161ad84e22623fb4fa6b1c58c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a27e04fd161ad84e22623fb4fa6b1c58c">_schedule_times</a></td></tr>
<tr class="memdesc:a27e04fd161ad84e22623fb4fa6b1c58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">调度次数，记录策略被调度的次数  <br /></td></tr>
<tr class="separator:a27e04fd161ad84e22623fb4fa6b1c58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be2e0a10ba8d123b4269fca90c3c36e" id="r_a2be2e0a10ba8d123b4269fca90c3c36e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a2be2e0a10ba8d123b4269fca90c3c36e">_main_key</a></td></tr>
<tr class="memdesc:a2be2e0a10ba8d123b4269fca90c3c36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">主要合约的唯一键，由合约代码和周期组成  <br /></td></tr>
<tr class="separator:a2be2e0a10ba8d123b4269fca90c3c36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82b4f5ae4a71d3888aebff7100c9739" id="r_ad82b4f5ae4a71d3888aebff7100c9739"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ad82b4f5ae4a71d3888aebff7100c9739">_main_code</a></td></tr>
<tr class="memdesc:ad82b4f5ae4a71d3888aebff7100c9739"><td class="mdescLeft">&#160;</td><td class="mdescRight">主要合约代码  <br /></td></tr>
<tr class="separator:ad82b4f5ae4a71d3888aebff7100c9739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d823ff9e5164b94082df481c4665ab" id="r_aa5d823ff9e5164b94082df481c4665ab"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa5d823ff9e5164b94082df481c4665ab">_main_period</a></td></tr>
<tr class="memdesc:aa5d823ff9e5164b94082df481c4665ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">主要周期  <br /></td></tr>
<tr class="separator:aa5d823ff9e5164b94082df481c4665ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66f37a56d7c22ad3eb20e7dcb4ec567" id="r_af66f37a56d7c22ad3eb20e7dcb4ec567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a0766982fe9521f3ec9afafd83df7b7f8">KlineTags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#af66f37a56d7c22ad3eb20e7dcb4ec567">_kline_tags</a></td></tr>
<tr class="separator:af66f37a56d7c22ad3eb20e7dcb4ec567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a664df41d933e8653f193e3a1f5f195" id="r_a7a664df41d933e8653f193e3a1f5f195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#ac578f5d7d25d9854dd58cde8aad11078">PriceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a7a664df41d933e8653f193e3a1f5f195">_price_map</a></td></tr>
<tr class="separator:a7a664df41d933e8653f193e3a1f5f195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f48deb3ba64b5e6e2ffc4ea79f1ead" id="r_ad7f48deb3ba64b5e6e2ffc4ea79f1ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a4c333945310f2dea8d646e176a7943f8">PositionMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ad7f48deb3ba64b5e6e2ffc4ea79f1ead">_pos_map</a></td></tr>
<tr class="separator:ad7f48deb3ba64b5e6e2ffc4ea79f1ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac007131bf6cb32eb88056b6ab952803f" id="r_ac007131bf6cb32eb88056b6ab952803f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ac007131bf6cb32eb88056b6ab952803f">_total_closeprofit</a></td></tr>
<tr class="memdesc:ac007131bf6cb32eb88056b6ab952803f"><td class="mdescLeft">&#160;</td><td class="mdescRight">总平仓盈亏，记录所有平仓交易的盈亏总和  <br /></td></tr>
<tr class="separator:ac007131bf6cb32eb88056b6ab952803f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f1a466ed5e94110e8476eedc0913d" id="r_a464f1a466ed5e94110e8476eedc0913d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a1893cd4399b7a826330d8410115732a6">SignalMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a464f1a466ed5e94110e8476eedc0913d">_sig_map</a></td></tr>
<tr class="separator:a464f1a466ed5e94110e8476eedc0913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e4da25a9a9b94ee87f205dcbc0bf73" id="r_a42e4da25a9a9b94ee87f205dcbc0bf73"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a42e4da25a9a9b94ee87f205dcbc0bf73">_trade_logs</a></td></tr>
<tr class="memdesc:a42e4da25a9a9b94ee87f205dcbc0bf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">交易日志流，用于记录所有交易操作  <br /></td></tr>
<tr class="separator:a42e4da25a9a9b94ee87f205dcbc0bf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8f945dc787fc3da2670f3b9c937788" id="r_a8b8f945dc787fc3da2670f3b9c937788"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a8b8f945dc787fc3da2670f3b9c937788">_close_logs</a></td></tr>
<tr class="memdesc:a8b8f945dc787fc3da2670f3b9c937788"><td class="mdescLeft">&#160;</td><td class="mdescRight">平仓日志流，用于记录平仓操作及其盈亏  <br /></td></tr>
<tr class="separator:a8b8f945dc787fc3da2670f3b9c937788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95c90526aaeeaca9675ee8beb93a6af" id="r_ae95c90526aaeeaca9675ee8beb93a6af"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ae95c90526aaeeaca9675ee8beb93a6af">_fund_logs</a></td></tr>
<tr class="memdesc:ae95c90526aaeeaca9675ee8beb93a6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">资金日志流，用于记录资金变化  <br /></td></tr>
<tr class="separator:ae95c90526aaeeaca9675ee8beb93a6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296978ec7961baf0e4d31700fa1fdc78" id="r_a296978ec7961baf0e4d31700fa1fdc78"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a296978ec7961baf0e4d31700fa1fdc78">_sig_logs</a></td></tr>
<tr class="memdesc:a296978ec7961baf0e4d31700fa1fdc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">信号日志流，用于记录策略产生的信号  <br /></td></tr>
<tr class="separator:a296978ec7961baf0e4d31700fa1fdc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67399c60b1479257ec032c7adaf4bc0" id="r_aa67399c60b1479257ec032c7adaf4bc0"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa67399c60b1479257ec032c7adaf4bc0">_pos_logs</a></td></tr>
<tr class="memdesc:aa67399c60b1479257ec032c7adaf4bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">持仓日志流，用于记录持仓变化  <br /></td></tr>
<tr class="separator:aa67399c60b1479257ec032c7adaf4bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fba06703fe16f7db1c3611ed276dfbb" id="r_a4fba06703fe16f7db1c3611ed276dfbb"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a4fba06703fe16f7db1c3611ed276dfbb">_index_logs</a></td></tr>
<tr class="memdesc:a4fba06703fe16f7db1c3611ed276dfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">指标日志流，用于记录策略指标数据  <br /></td></tr>
<tr class="separator:a4fba06703fe16f7db1c3611ed276dfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0a513033492e94a0031bd831ca408a" id="r_a7a0a513033492e94a0031bd831ca408a"><td class="memItemLeft" align="right" valign="top">std::stringstream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a7a0a513033492e94a0031bd831ca408a">_mark_logs</a></td></tr>
<tr class="memdesc:a7a0a513033492e94a0031bd831ca408a"><td class="mdescLeft">&#160;</td><td class="mdescRight">标记日志流，用于记录特定标记点  <br /></td></tr>
<tr class="separator:a7a0a513033492e94a0031bd831ca408a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e21661fc57d08ddae277f16c37906b6" id="r_a2e21661fc57d08ddae277f16c37906b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CtaMocker_8h.html#a4f907939e222c805bb69004f7be6e6c6">CondEntrustMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a2e21661fc57d08ddae277f16c37906b6">_condtions</a></td></tr>
<tr class="memdesc:a2e21661fc57d08ddae277f16c37906b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">条件委托映射，用于管理各个合约的条件委托  <br /></td></tr>
<tr class="separator:a2e21661fc57d08ddae277f16c37906b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50eeace4a5362845c3b6260772d0a62" id="r_af50eeace4a5362845c3b6260772d0a62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#af50eeace4a5362845c3b6260772d0a62">_is_in_schedule</a></td></tr>
<tr class="memdesc:af50eeace4a5362845c3b6260772d0a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">调度标记  <br /></td></tr>
<tr class="separator:af50eeace4a5362845c3b6260772d0a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991bba9de2eb616e9951f22f65ea1d70" id="r_a991bba9de2eb616e9951f22f65ea1d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a3d7ef58a183d7574fc9f4ddda1e06b64">StringHashMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a991bba9de2eb616e9951f22f65ea1d70">_user_datas</a></td></tr>
<tr class="memdesc:a991bba9de2eb616e9951f22f65ea1d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户数据映射，键值对形式存储  <br /></td></tr>
<tr class="separator:a991bba9de2eb616e9951f22f65ea1d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d76dbce2c43b3a0c86c24031beafdba" id="r_a9d76dbce2c43b3a0c86c24031beafdba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9d76dbce2c43b3a0c86c24031beafdba">_ud_modified</a></td></tr>
<tr class="memdesc:a9d76dbce2c43b3a0c86c24031beafdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">用户数据是否已修改，用于标记是否需要持久化  <br /></td></tr>
<tr class="separator:a9d76dbce2c43b3a0c86c24031beafdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061cadab7aec2f857ccc5ea3d8ebf284" id="r_a061cadab7aec2f857ccc5ea3d8ebf284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a36bbaf8e935f00f08040d8ce239f1611">StraFundInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a061cadab7aec2f857ccc5ea3d8ebf284">_fund_info</a></td></tr>
<tr class="memdesc:a061cadab7aec2f857ccc5ea3d8ebf284"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略资金信息，记录策略账户的资金状况  <br /></td></tr>
<tr class="separator:a061cadab7aec2f857ccc5ea3d8ebf284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047b58be23b1b8e8dab9fb0fd5cd2ec3" id="r_a047b58be23b1b8e8dab9fb0fd5cd2ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a67a18d658ae4f719289fdf03fbe9630b">StraFactInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a047b58be23b1b8e8dab9fb0fd5cd2ec3">_factory</a></td></tr>
<tr class="memdesc:a047b58be23b1b8e8dab9fb0fd5cd2ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略工厂信息，管理策略工厂的加载和创建  <br /></td></tr>
<tr class="separator:a047b58be23b1b8e8dab9fb0fd5cd2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e597fe25efe6ab6035c17d8a8c0660" id="r_a49e597fe25efe6ab6035c17d8a8c0660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaStrategy.html">CtaStrategy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a49e597fe25efe6ab6035c17d8a8c0660">_strategy</a></td></tr>
<tr class="memdesc:a49e597fe25efe6ab6035c17d8a8c0660"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略对象指针，指向实际的CTA策略实例  <br /></td></tr>
<tr class="separator:a49e597fe25efe6ab6035c17d8a8c0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6cefe59a67ad0366ce9f0a85b5296" id="r_a85e6cefe59a67ad0366ce9f0a85b5296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventNotifier.html">EventNotifier</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a85e6cefe59a67ad0366ce9f0a85b5296">_notifier</a></td></tr>
<tr class="memdesc:a85e6cefe59a67ad0366ce9f0a85b5296"><td class="mdescLeft">&#160;</td><td class="mdescRight">事件通知器指针，用于发送事件通知  <br /></td></tr>
<tr class="separator:a85e6cefe59a67ad0366ce9f0a85b5296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3accace2c3491e8fbe8e43c9a169861" id="r_ae3accace2c3491e8fbe8e43c9a169861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ae3accace2c3491e8fbe8e43c9a169861">_mtx_calc</a></td></tr>
<tr class="memdesc:ae3accace2c3491e8fbe8e43c9a169861"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算锁，用于同步策略计算  <br /></td></tr>
<tr class="separator:ae3accace2c3491e8fbe8e43c9a169861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d1e0d80c4acf5870ae772d7694afd2" id="r_aa8d1e0d80c4acf5870ae772d7694afd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MutexUtils.html#gafaa630f2eecc6c68bc508cb484fcd3a3">StdCondVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa8d1e0d80c4acf5870ae772d7694afd2">_cond_calc</a></td></tr>
<tr class="memdesc:aa8d1e0d80c4acf5870ae772d7694afd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算条件变量，用于等待和通知计算完成  <br /></td></tr>
<tr class="separator:aa8d1e0d80c4acf5870ae772d7694afd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404a71dafc0eb023592cf0cdbca61361" id="r_a404a71dafc0eb023592cf0cdbca61361"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a404a71dafc0eb023592cf0cdbca61361">_has_hook</a></td></tr>
<tr class="memdesc:a404a71dafc0eb023592cf0cdbca61361"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否有钩子，这是人为控制是否启用钩子  <br /></td></tr>
<tr class="separator:a404a71dafc0eb023592cf0cdbca61361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6118fd8fa36a0d72b3009114696699a4" id="r_a6118fd8fa36a0d72b3009114696699a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a6118fd8fa36a0d72b3009114696699a4">_hook_valid</a></td></tr>
<tr class="memdesc:a6118fd8fa36a0d72b3009114696699a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">钩子是否有效，这是根据是否是异步回测模式而确定钩子是否可用  <br /></td></tr>
<tr class="separator:a6118fd8fa36a0d72b3009114696699a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5466d8f84a0e8bdef8bd91751ef9f7f" id="r_ac5466d8f84a0e8bdef8bd91751ef9f7f"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ac5466d8f84a0e8bdef8bd91751ef9f7f">_cur_step</a></td></tr>
<tr class="memdesc:ac5466d8f84a0e8bdef8bd91751ef9f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前步骤，临时变量，用于控制状态  <br /></td></tr>
<tr class="separator:ac5466d8f84a0e8bdef8bd91751ef9f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4fbd4ffc4d8693621d58db7263a0fa" id="r_a3d4fbd4ffc4d8693621d58db7263a0fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a3d4fbd4ffc4d8693621d58db7263a0fa">_in_backtest</a></td></tr>
<tr class="memdesc:a3d4fbd4ffc4d8693621d58db7263a0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否在回测中，标记当前是否处于回测过程中  <br /></td></tr>
<tr class="separator:a3d4fbd4ffc4d8693621d58db7263a0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c812953d3e41b46b1656c81b216db60" id="r_a7c812953d3e41b46b1656c81b216db60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a7c812953d3e41b46b1656c81b216db60">_wait_calc</a></td></tr>
<tr class="memdesc:a7c812953d3e41b46b1656c81b216db60"><td class="mdescLeft">&#160;</td><td class="mdescRight">是否等待计算，标记是否需要等待策略计算完成  <br /></td></tr>
<tr class="separator:a7c812953d3e41b46b1656c81b216db60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3583b1368ac02b33b81fcf6829abe7" id="r_acf3583b1368ac02b33b81fcf6829abe7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#acf3583b1368ac02b33b81fcf6829abe7">_persist_data</a></td></tr>
<tr class="memdesc:acf3583b1368ac02b33b81fcf6829abe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">持久化标记  <br /></td></tr>
<tr class="separator:acf3583b1368ac02b33b81fcf6829abe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154caeae6198f776f95f881d9bd1ad3e" id="r_a154caeae6198f776f95f881d9bd1ad3e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a154caeae6198f776f95f881d9bd1ad3e">_cur_tdate</a></td></tr>
<tr class="memdesc:a154caeae6198f776f95f881d9bd1ad3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前交易日，格式为YYYYMMDD  <br /></td></tr>
<tr class="separator:a154caeae6198f776f95f881d9bd1ad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b01e991c9a3bdceff260ca3fe03cd59" id="r_a8b01e991c9a3bdceff260ca3fe03cd59"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a8b01e991c9a3bdceff260ca3fe03cd59">_cur_bartime</a></td></tr>
<tr class="memdesc:a8b01e991c9a3bdceff260ca3fe03cd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">当前K线时间，格式为HHMMSS  <br /></td></tr>
<tr class="separator:a8b01e991c9a3bdceff260ca3fe03cd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0997ceb8e4ee04c8d0210511f27c52" id="r_acd0997ceb8e4ee04c8d0210511f27c52"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#acd0997ceb8e4ee04c8d0210511f27c52">_last_cond_min</a></td></tr>
<tr class="memdesc:acd0997ceb8e4ee04c8d0210511f27c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">最近条件检查时间，以分钟为单位  <br /></td></tr>
<tr class="separator:acd0997ceb8e4ee04c8d0210511f27c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beacb93ceab5ccefdd29015e0ad30d9" id="r_a7beacb93ceab5ccefdd29015e0ad30d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwt__hashset.html">wt_hashset</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a7beacb93ceab5ccefdd29015e0ad30d9">_tick_subs</a></td></tr>
<tr class="memdesc:a7beacb93ceab5ccefdd29015e0ad30d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick订阅列表  <br /></td></tr>
<tr class="separator:a7beacb93ceab5ccefdd29015e0ad30d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fe88edf5e4fa18ebf1afd128b17da1" id="r_a07fe88edf5e4fa18ebf1afd128b17da1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a07fe88edf5e4fa18ebf1afd128b17da1">_chart_code</a></td></tr>
<tr class="memdesc:a07fe88edf5e4fa18ebf1afd128b17da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表合约代码，用于图表展示的合约  <br /></td></tr>
<tr class="separator:a07fe88edf5e4fa18ebf1afd128b17da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384eb95010a16bcbbb79b52afb0da683" id="r_a384eb95010a16bcbbb79b52afb0da683"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a384eb95010a16bcbbb79b52afb0da683">_chart_period</a></td></tr>
<tr class="memdesc:a384eb95010a16bcbbb79b52afb0da683"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表周期，用于图表展示的K线周期  <br /></td></tr>
<tr class="separator:a384eb95010a16bcbbb79b52afb0da683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bddf67064613a992d5dae146f40a3ee" id="r_a4bddf67064613a992d5dae146f40a3ee"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="classCtaMocker.html#ab39569986e35ad1307b12488e9b94781">ChartIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a4bddf67064613a992d5dae146f40a3ee">_chart_indice</a></td></tr>
<tr class="memdesc:a4bddf67064613a992d5dae146f40a3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">图表指标映射，键为指标名称  <br /></td></tr>
<tr class="separator:a4bddf67064613a992d5dae146f40a3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5701fde49703aba706fa8a07441162" id="r_a3c5701fde49703aba706fa8a07441162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCtaMocker.html#a9227a7402c399bd1e8072d2d56dbc751">TickCache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a3c5701fde49703aba706fa8a07441162">_ticks</a></td></tr>
<tr class="memdesc:a3c5701fde49703aba706fa8a07441162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick缓存，存储最新的Tick数据  <br /></td></tr>
<tr class="separator:a3c5701fde49703aba706fa8a07441162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classICtaStraCtx"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classICtaStraCtx')"><img src="closed.png" alt="-"/>&#160;Protected 属性 继承自 <a class="el" href="classICtaStraCtx.html">ICtaStraCtx</a></td></tr>
<tr class="memitem:a6517c64cce7027b4d79e0503bbc36baf inherit pro_attribs_classICtaStraCtx" id="r_a6517c64cce7027b4d79e0503bbc36baf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classICtaStraCtx.html#a6517c64cce7027b4d79e0503bbc36baf">_name</a></td></tr>
<tr class="memdesc:a6517c64cce7027b4d79e0503bbc36baf inherit pro_attribs_classICtaStraCtx"><td class="mdescLeft">&#160;</td><td class="mdescRight">策略名称  <br /></td></tr>
<tr class="separator:a6517c64cce7027b4d79e0503bbc36baf inherit pro_attribs_classICtaStraCtx"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private 成员函数</h2></td></tr>
<tr class="memitem:a7452d88f0bdfdb409a84917997baf6f2" id="r_a7452d88f0bdfdb409a84917997baf6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a7452d88f0bdfdb409a84917997baf6f2">dump_outputs</a> ()</td></tr>
<tr class="memdesc:a7452d88f0bdfdb409a84917997baf6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">输出回测结果  <br /></td></tr>
<tr class="separator:a7452d88f0bdfdb409a84917997baf6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9504b0cd3d780642006ea7efee13b479" id="r_a9504b0cd3d780642006ea7efee13b479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9504b0cd3d780642006ea7efee13b479">dump_stradata</a> ()</td></tr>
<tr class="memdesc:a9504b0cd3d780642006ea7efee13b479"><td class="mdescLeft">&#160;</td><td class="mdescRight">导出策略数据  <br /></td></tr>
<tr class="separator:a9504b0cd3d780642006ea7efee13b479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f9ef41babf5d070e46e81d51f67540" id="r_a51f9ef41babf5d070e46e81d51f67540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a51f9ef41babf5d070e46e81d51f67540">dump_chartdata</a> ()</td></tr>
<tr class="memdesc:a51f9ef41babf5d070e46e81d51f67540"><td class="mdescLeft">&#160;</td><td class="mdescRight">导出图表数据  <br /></td></tr>
<tr class="separator:a51f9ef41babf5d070e46e81d51f67540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0635d16462242feb1142d6baeef3a" id="r_a43e0635d16462242feb1142d6baeef3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a43e0635d16462242feb1142d6baeef3a">log_signal</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double target, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, uint64_t gentime, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *usertag=&quot;&quot;)</td></tr>
<tr class="memdesc:a43e0635d16462242feb1142d6baeef3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录信号  <br /></td></tr>
<tr class="separator:a43e0635d16462242feb1142d6baeef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac906fa4766546a782b7065134608974c" id="r_ac906fa4766546a782b7065134608974c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ac906fa4766546a782b7065134608974c">log_trade</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, bool isOpen, uint64_t curTime, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;, double fee=0.0, uint32_t barNo=0)</td></tr>
<tr class="memdesc:ac906fa4766546a782b7065134608974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录交易  <br /></td></tr>
<tr class="separator:ac906fa4766546a782b7065134608974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3029d436c270b03f2586cbebf3d07e5" id="r_ae3029d436c270b03f2586cbebf3d07e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ae3029d436c270b03f2586cbebf3d07e5">log_close</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, bool isLong, uint64_t openTime, double openpx, uint64_t closeTime, double closepx, double qty, double profit, double maxprofit, double maxloss, double totalprofit=0, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *enterTag=&quot;&quot;, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *exitTag=&quot;&quot;, uint32_t openBarNo=0, uint32_t closeBarNo=0)</td></tr>
<tr class="memdesc:ae3029d436c270b03f2586cbebf3d07e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">记录平仓  <br /></td></tr>
<tr class="separator:ae3029d436c270b03f2586cbebf3d07e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914a40e13ed8a98fb684771d1ff12fc9" id="r_a914a40e13ed8a98fb684771d1ff12fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a914a40e13ed8a98fb684771d1ff12fc9">update_dyn_profit</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>)</td></tr>
<tr class="memdesc:a914a40e13ed8a98fb684771d1ff12fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">更新动态盈亏  <br /></td></tr>
<tr class="separator:a914a40e13ed8a98fb684771d1ff12fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52067867a3df6a6b32b1d92969945627" id="r_a52067867a3df6a6b32b1d92969945627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a52067867a3df6a6b32b1d92969945627">do_set_position</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>=0.0, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag=&quot;&quot;)</td></tr>
<tr class="memdesc:a52067867a3df6a6b32b1d92969945627"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置仓位  <br /></td></tr>
<tr class="separator:a52067867a3df6a6b32b1d92969945627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b19c768397f4a548aaa9fc80cbd7015" id="r_a9b19c768397f4a548aaa9fc80cbd7015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a9b19c768397f4a548aaa9fc80cbd7015">append_signal</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double qty, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *userTag, double <a class="el" href="demo__send__order_8cpp.html#a04f887fc8800d4727971dbb8eb550132">price</a>, uint32_t sigType)</td></tr>
<tr class="memdesc:a9b19c768397f4a548aaa9fc80cbd7015"><td class="mdescLeft">&#160;</td><td class="mdescRight">添加信号  <br /></td></tr>
<tr class="separator:a9b19c768397f4a548aaa9fc80cbd7015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ab6828f30fbccca75abf9e0cfe702" id="r_aa76ab6828f30fbccca75abf9e0cfe702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CtaMocker_8h.html#a554586e84eb02c2dd968b6cbb4af59ef">CondList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#aa76ab6828f30fbccca75abf9e0cfe702">get_cond_entrusts</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode)</td></tr>
<tr class="memdesc:aa76ab6828f30fbccca75abf9e0cfe702"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取条件委托列表  <br /></td></tr>
<tr class="separator:aa76ab6828f30fbccca75abf9e0cfe702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b32fb38361c6fd778c668ebeb85774" id="r_ab8b32fb38361c6fd778c668ebeb85774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ab8b32fb38361c6fd778c668ebeb85774">proc_tick</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *stdCode, double last_px, double cur_px)</td></tr>
<tr class="memdesc:ab8b32fb38361c6fd778c668ebeb85774"><td class="mdescLeft">&#160;</td><td class="mdescRight">处理Tick数据  <br /></td></tr>
<tr class="separator:ab8b32fb38361c6fd778c668ebeb85774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fa5a70a85d6124182340870ea66d22" id="r_ae4fa5a70a85d6124182340870ea66d22"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae4fa5a70a85d6124182340870ea66d22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#ae4fa5a70a85d6124182340870ea66d22">log_debug</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:ae4fa5a70a85d6124182340870ea66d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">调试日志辅助函数  <br /></td></tr>
<tr class="separator:ae4fa5a70a85d6124182340870ea66d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefa327470a483e7c7c16e54fc6f6748" id="r_acefa327470a483e7c7c16e54fc6f6748"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acefa327470a483e7c7c16e54fc6f6748"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#acefa327470a483e7c7c16e54fc6f6748">log_info</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:acefa327470a483e7c7c16e54fc6f6748"><td class="mdescLeft">&#160;</td><td class="mdescRight">信息日志辅助函数  <br /></td></tr>
<tr class="separator:acefa327470a483e7c7c16e54fc6f6748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563dde9ee9ab1060af6f25dd4db60b4f" id="r_a563dde9ee9ab1060af6f25dd4db60b4f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a563dde9ee9ab1060af6f25dd4db60b4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCtaMocker.html#a563dde9ee9ab1060af6f25dd4db60b4f">log_error</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *format, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...args)</td></tr>
<tr class="memdesc:a563dde9ee9ab1060af6f25dd4db60b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">错误日志辅助函数  <br /></td></tr>
<tr class="separator:a563dde9ee9ab1060af6f25dd4db60b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>CTA策略回测模拟器类 </p>
<p>实现了ICtaStraCtx和IDataSink接口，用于模拟策略在历史数据上的运行过程。 该类是CTA策略回测的核心组件，负责处理历史数据、执行策略逻辑、模拟交易和记录回测结果。 通过该类，可以对CTA策略进行全面的回测、调试和优化。 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00108">108</a> 行定义.</p>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="ab39569986e35ad1307b12488e9b94781" name="ab39569986e35ad1307b12488e9b94781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39569986e35ad1307b12488e9b94781">&#9670;&#160;</a></span>ChartIndex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__ChartIndex.html">CtaMocker::_ChartIndex</a> <a class="el" href="classCtaMocker.html#ab39569986e35ad1307b12488e9b94781">CtaMocker::ChartIndex</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>图表指标结构体 </p>
<p>用于定义图表中的指标信息，包括名称、类型和线条等 </p>

</div>
</div>
<a id="a6fdf1f30007df7abd9e8a18c8ce784cd" name="a6fdf1f30007df7abd9e8a18c8ce784cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdf1f30007df7abd9e8a18c8ce784cd">&#9670;&#160;</a></span>ChartLine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__ChartLine.html">CtaMocker::_ChartLine</a> <a class="el" href="classCtaMocker.html#a6fdf1f30007df7abd9e8a18c8ce784cd">CtaMocker::ChartLine</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>图表线结构体 </p>
<p>用于定义图表中的线条信息，包括名称和类型 </p>

</div>
</div>
<a id="ace46338636637236841a2893fffa93f8" name="ace46338636637236841a2893fffa93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace46338636637236841a2893fffa93f8">&#9670;&#160;</a></span>DetailInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__DetailInfo.html">CtaMocker::_DetailInfo</a> <a class="el" href="classCtaMocker.html#ace46338636637236841a2893fffa93f8">CtaMocker::DetailInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易详情结构体 </p>
<p>用于记录每笔交易的详细信息，包括方向、价格、数量、时间和盈亏等 </p>

</div>
</div>
<a id="a90d7d5606401b1b4a9f124759f9cde69" name="a90d7d5606401b1b4a9f124759f9cde69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d7d5606401b1b4a9f124759f9cde69">&#9670;&#160;</a></span>KlineTag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__KlineTag.html">CtaMocker::_KlineTag</a> <a class="el" href="classCtaMocker.html#a90d7d5606401b1b4a9f124759f9cde69">CtaMocker::KlineTag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K线标记结构体 </p>
<p>用于记录K线的状态信息，包括是否已关闭和是否已通知 </p>

</div>
</div>
<a id="a0766982fe9521f3ec9afafd83df7b7f8" name="a0766982fe9521f3ec9afafd83df7b7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0766982fe9521f3ec9afafd83df7b7f8">&#9670;&#160;</a></span>KlineTags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, <a class="el" href="classCtaMocker.html#a90d7d5606401b1b4a9f124759f9cde69">KlineTag</a>&gt; <a class="el" href="classCtaMocker.html#a0766982fe9521f3ec9afafd83df7b7f8">CtaMocker::KlineTags</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K线标记映射类型 </p>
<p>定义了从合约代码到K线标记的映射，用于管理不同合约的K线状态 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00823">823</a> 行定义.</p>

</div>
</div>
<a id="a835efe4b428ccad0a28891db697ac0f0" name="a835efe4b428ccad0a28891db697ac0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835efe4b428ccad0a28891db697ac0f0">&#9670;&#160;</a></span>PosInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__PosInfo.html">CtaMocker::_PosInfo</a> <a class="el" href="classCtaMocker.html#a835efe4b428ccad0a28891db697ac0f0">CtaMocker::PosInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓信息结构体 </p>
<p>用于记录合约的持仓情况，包括持仓量、盈亏、时间等信息 </p>

</div>
</div>
<a id="a4c333945310f2dea8d646e176a7943f8" name="a4c333945310f2dea8d646e176a7943f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c333945310f2dea8d646e176a7943f8">&#9670;&#160;</a></span>PositionMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, <a class="el" href="classCtaMocker.html#a835efe4b428ccad0a28891db697ac0f0">PosInfo</a>&gt; <a class="el" href="classCtaMocker.html#a4c333945310f2dea8d646e176a7943f8">CtaMocker::PositionMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓映射类型 </p>
<p>定义了从合约代码到持仓信息的映射，用于管理不同合约的持仓情况 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00902">902</a> 行定义.</p>

</div>
</div>
<a id="ac578f5d7d25d9854dd58cde8aad11078" name="ac578f5d7d25d9854dd58cde8aad11078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac578f5d7d25d9854dd58cde8aad11078">&#9670;&#160;</a></span>PriceMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, double&gt; <a class="el" href="classCtaMocker.html#ac578f5d7d25d9854dd58cde8aad11078">CtaMocker::PriceMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>价格映射类型 </p>
<p>定义了从合约代码到价格的映射，用于管理不同合约的当前价格 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00830">830</a> 行定义.</p>

</div>
</div>
<a id="acd60df10691b15396594e07b5ed5fafa" name="acd60df10691b15396594e07b5ed5fafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd60df10691b15396594e07b5ed5fafa">&#9670;&#160;</a></span>SigInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__SigInfo.html">CtaMocker::_SigInfo</a> <a class="el" href="classCtaMocker.html#acd60df10691b15396594e07b5ed5fafa">CtaMocker::SigInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>信号信息结构体 </p>
<p>用于记录策略生成的交易信号信息，包括数量、价格、类型等 </p>

</div>
</div>
<a id="a1893cd4399b7a826330d8410115732a6" name="a1893cd4399b7a826330d8410115732a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1893cd4399b7a826330d8410115732a6">&#9670;&#160;</a></span>SignalMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, <a class="el" href="classCtaMocker.html#acd60df10691b15396594e07b5ed5fafa">SigInfo</a>&gt; <a class="el" href="classCtaMocker.html#a1893cd4399b7a826330d8410115732a6">CtaMocker::SignalMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>信号映射类型 </p>
<p>定义了从合约代码到信号信息的映射，用于管理不同合约的信号 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00936">936</a> 行定义.</p>

</div>
</div>
<a id="a67a18d658ae4f719289fdf03fbe9630b" name="a67a18d658ae4f719289fdf03fbe9630b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a18d658ae4f719289fdf03fbe9630b">&#9670;&#160;</a></span>StraFactInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__StraFactInfo.html">CtaMocker::_StraFactInfo</a> <a class="el" href="classCtaMocker.html#a67a18d658ae4f719289fdf03fbe9630b">CtaMocker::StraFactInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略工厂信息结构体 </p>
<p>用于管理CTA策略工厂的动态库加载和实例创建 </p>

</div>
</div>
<a id="a36bbaf8e935f00f08040d8ce239f1611" name="a36bbaf8e935f00f08040d8ce239f1611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bbaf8e935f00f08040d8ce239f1611">&#9670;&#160;</a></span>StraFundInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structCtaMocker_1_1__StraFundInfo.html">CtaMocker::_StraFundInfo</a> <a class="el" href="classCtaMocker.html#a36bbaf8e935f00f08040d8ce239f1611">CtaMocker::StraFundInfo</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略资金信息结构体 </p>
<p>用于记录策略账户的资金状况，包括盈亏和手续费等 </p>

</div>
</div>
<a id="a3d7ef58a183d7574fc9f4ddda1e06b64" name="a3d7ef58a183d7574fc9f4ddda1e06b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7ef58a183d7574fc9f4ddda1e06b64">&#9670;&#160;</a></span>StringHashMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, std::string&gt; <a class="el" href="classCtaMocker.html#a3d7ef58a183d7574fc9f4ddda1e06b64">CtaMocker::StringHashMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>用户数据相关 </p>
<p>用于存储和管理用户自定义数据 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00959">959</a> 行定义.</p>

</div>
</div>
<a id="a9227a7402c399bd1e8072d2d56dbc751" name="a9227a7402c399bd1e8072d2d56dbc751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9227a7402c399bd1e8072d2d56dbc751">&#9670;&#160;</a></span>TickCache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classwt__hashmap.html">wt_hashmap</a>&lt;std::string, <a class="el" href="structWTSTickStruct.html">WTSTickStruct</a>&gt; <a class="el" href="classCtaMocker.html#a9227a7402c399bd1e8072d2d56dbc751">CtaMocker::TickCache</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick缓存类型 </p>
<p>定义了从合约代码到Tick数据的映射，用于缓存最新的Tick数据 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01078">1078</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a50dd853c3e942ceb1d2cdd75f6cbbd14" name="a50dd853c3e942ceb1d2cdd75f6cbbd14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50dd853c3e942ceb1d2cdd75f6cbbd14">&#9670;&#160;</a></span>CtaMocker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CtaMocker::CtaMocker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a> *&#160;</td>
          <td class="paramname"><em>replayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>slippage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>persistData</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEventNotifier.html">EventNotifier</a> *&#160;</td>
          <td class="paramname"><em>notifier</em> = <code><a class="el" href="types_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRatioSlp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>构造函数 </p>
<p>CtaMocker类构造函数</p>
<p>创建一个CTA策略回测模拟器实例 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">replayer</td><td>历史数据回放器，用于提供回测所需的历史数据 </td></tr>
    <tr><td class="paramname">name</td><td>策略名称，用于标识不同的策略实例 </td></tr>
    <tr><td class="paramname">slippage</td><td>滑点设置，用于模拟实际交易中的滑点影响，默认为0 </td></tr>
    <tr><td class="paramname">persistData</td><td>是否持久化数据，如果为true则会保存回测结果，默认为true </td></tr>
    <tr><td class="paramname">notifier</td><td>事件通知器，用于通知外部系统回测过程中的事件，默认为NULL </td></tr>
    <tr><td class="paramname">isRatioSlp</td><td>是否使用比例滑点，如果为true则slippage表示万分比，默认为false</td></tr>
  </table>
  </dd>
</dl>
<p>初始化CTA策略回测模拟器，设置各种参数和初始状态 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">replayer</td><td>历史数据回放器指针，用于提供回测所需的历史数据 </td></tr>
    <tr><td class="paramname">name</td><td>策略名称，用于标识策略 </td></tr>
    <tr><td class="paramname">slippage</td><td>滑点设置，用于模拟实际交易中的滑点影响，默认为0 </td></tr>
    <tr><td class="paramname">persistData</td><td>是否持久化数据，如果为true则会保存回测结果，默认为true </td></tr>
    <tr><td class="paramname">notifier</td><td>事件通知器指针，用于发送事件通知，默认为NULL </td></tr>
    <tr><td class="paramname">isRatioSlp</td><td>是否为比例滑点，如果为true则slippage为万分比，默认为false </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00079">79</a> 行定义.</p>

</div>
</div>
<a id="a2e13c934118cf25b0e16109f441e5089" name="a2e13c934118cf25b0e16109f441e5089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e13c934118cf25b0e16109f441e5089">&#9670;&#160;</a></span>~CtaMocker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CtaMocker::~CtaMocker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>析构函数 </p>
<p>CtaMocker类析构函数</p>
<p>释放CTA策略回测模拟器占用的资源</p>
<p>清理CtaMocker实例占用的资源 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00107">107</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a8d55ebca2ad26a2dc1a2a93965b84435" name="a8d55ebca2ad26a2dc1a2a93965b84435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d55ebca2ad26a2dc1a2a93965b84435">&#9670;&#160;</a></span>add_chart_mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::add_chart_mark </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>icon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加图表标记接口 </p>
<p>添加图表标记</p>
<p>实现ICtaStraCtx接口的方法，用于在图表上添加标记点 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">price</td><td>标记价格，标记点的纵坐标位置 </td></tr>
    <tr><td class="paramname">icon</td><td>标记图标，用于指定标记的图标样式 </td></tr>
    <tr><td class="paramname">tag</td><td>标记标签，用于描述标记的含义</td></tr>
  </table>
  </dd>
</dl>
<p>在图表上添加标记，用于标记特定事件或信号 只能在定时调度期间添加标记 标记会记录当前时间、价格、图标和标签信息 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">price</td><td>标记价格，标记在图表上的垂直位置 </td></tr>
    <tr><td class="paramname">icon</td><td>图标名称，用于指定标记的图标样式 </td></tr>
    <tr><td class="paramname">tag</td><td>标签文本，用于描述标记的含义 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a0029d75010d81f47ddcd54372536d315">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02627">2627</a> 行定义.</p>

</div>
</div>
<a id="aad4f546fbcb4540cf25760ffc1034f47" name="aad4f546fbcb4540cf25760ffc1034f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4f546fbcb4540cf25760ffc1034f47">&#9670;&#160;</a></span>add_index_baseline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::add_index_baseline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>idxName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>lineName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加指标基准线接口 </p>
<p>添加指标基准线</p>
<p>实现ICtaStraCtx接口的方法，用于在指定指标上添加基准线 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，指定要添加基准线的指标 </td></tr>
    <tr><td class="paramname">lineName</td><td>线条名称，用于唯一标识基准线 </td></tr>
    <tr><td class="paramname">val</td><td>基准线数值，基准线的固定值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回添加是否成功</dd></dl>
<p>为已注册的指标添加一条基准线，基准线是一条固定值的水平线 用于在图表上显示参考线，如零线、超买超卖线等 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，必须是已经注册过的指标 </td></tr>
    <tr><td class="paramname">lineName</td><td>基准线名称，用于标识不同的基准线 </td></tr>
    <tr><td class="paramname">val</td><td>基准线的数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>添加成功返回true，失败返回false </dd></dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#abcf761d0278047286538d9075dda8be1">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02689">2689</a> 行定义.</p>

</div>
</div>
<a id="a9b19c768397f4a548aaa9fc80cbd7015" name="a9b19c768397f4a548aaa9fc80cbd7015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b19c768397f4a548aaa9fc80cbd7015">&#9670;&#160;</a></span>append_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::append_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sigType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>添加信号 </p>
<p>添加交易信号</p>
<p>添加交易信号到信号列表中 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量，正数表示多头，负数表示空头 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记 </td></tr>
    <tr><td class="paramname">price</td><td>信号价格 </td></tr>
    <tr><td class="paramname">sigType</td><td>信号类型</td></tr>
  </table>
  </dd>
</dl>
<p>将交易信号添加到信号队列中，并记录信号日志 信号将在下一个Tick到来时被处理并执行对应的交易 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>目标仓位，正数表示多头仓位，负数表示空头仓位 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，用于标记信号的特殊含义，默认为空字符串 </td></tr>
    <tr><td class="paramname">price</td><td>期望交易价格，默认为0.0，表示使用当前市场价格 </td></tr>
    <tr><td class="paramname">sigType</td><td>信号类型，0表示普通信号，2表示条件单触发信号，默认为0 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01861">1861</a> 行定义.</p>

</div>
</div>
<a id="a52067867a3df6a6b32b1d92969945627" name="a52067867a3df6a6b32b1d92969945627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52067867a3df6a6b32b1d92969945627">&#9670;&#160;</a></span>do_set_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::do_set_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置仓位 </p>
<p>直接设置指定合约的目标仓位，系统会自动计算需要交易的数量 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>目标仓位数量，正数表示多头，负数表示空头 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格，默认为0.0（市价单） </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>根据目标仓位和当前仓位计算需要调整的仓位，并执行相应的开仓或平仓操作 处理了滑点、手续费、冻结仓位等因素，并记录交易日志和平仓日志 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>目标仓位，正数表示多头仓位，负数表示空头仓位 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格，默认为0.0，表示使用当前市场价格 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，用于标记交易的特殊含义，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01887">1887</a> 行定义.</p>

</div>
</div>
<a id="a51f9ef41babf5d070e46e81d51f67540" name="a51f9ef41babf5d070e46e81d51f67540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f9ef41babf5d070e46e81d51f67540">&#9670;&#160;</a></span>dump_chartdata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::dump_chartdata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>导出图表数据 </p>
<p>将策略图表数据导出到JSON文件，用于回测结果可视化</p>
<p>将回测过程中生成的图表数据导出到JSON和CSV文件中，便于后续分析和可视化展示 主要导出以下几类数据：</p><ol type="1">
<li>K线数据：包括合约代码和周期信息</li>
<li>指标数据：包括各指标的名称、类型、线条和基准线等</li>
<li>标记数据：包括交易标记点的时间、价格、图标和标签等 </li>
</ol>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00267">267</a> 行定义.</p>

</div>
</div>
<a id="a7452d88f0bdfdb409a84917997baf6f2" name="a7452d88f0bdfdb409a84917997baf6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7452d88f0bdfdb409a84917997baf6f2">&#9670;&#160;</a></span>dump_outputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::dump_outputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>输出回测结果 </p>
<p>导出回测输出数据</p>
<p>将回测结果写入到输出文件中，包括交易日志、平仓日志、资金日志等</p>
<p>将回测过程中生成的各类日志数据导出到CSV文件中，便于后续分析 主要导出以下几类数据：</p><ol type="1">
<li>交易日志：记录每笔交易的合约、时间、方向、价格、数量等</li>
<li>平仓日志：记录每笔平仓的详细信息，包括开仓时间、平仓时间、盈亏等</li>
<li>资金日志：记录每日资金变化情况</li>
<li>信号日志：记录策略生成的交易信号</li>
<li>持仓日志：记录每日持仓情况</li>
<li>用户数据：将用户自定义数据导出到JSON文件 </li>
</ol>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00391">391</a> 行定义.</p>

</div>
</div>
<a id="a9504b0cd3d780642006ea7efee13b479" name="a9504b0cd3d780642006ea7efee13b479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9504b0cd3d780642006ea7efee13b479">&#9670;&#160;</a></span>dump_stradata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::dump_stradata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>导出策略数据 </p>
<p>将策略数据导出到JSON文件，包括仓位、资金、信号等信息</p>
<p>将策略的持仓、资金、信号等数据导出到JSON文件中，便于后续分析和展示 主要导出以下几类数据：</p><ol type="1">
<li>持仓数据：包括各合约的持仓量、平仓盈亏、浮动盈亏等</li>
<li>资金数据：包括总盈亏、总浮动盈亏、总手续费等</li>
<li>信号数据：包括各合约的交易信号 </li>
</ol>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00119">119</a> 行定义.</p>

</div>
</div>
<a id="abcfc8663664126a6413cdc39f6285012" name="abcfc8663664126a6413cdc39f6285012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfc8663664126a6413cdc39f6285012">&#9670;&#160;</a></span>enable_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::enable_hook </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnabled</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>启用或禁用钩子 </p>
<p>控制是否启用回测钩子函数 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnabled</td><td>是否启用钩子，默认为true </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01249">1249</a> 行定义.</p>

</div>
</div>
<a id="aacd8f0c6ea285dfebf728bb642919ec6" name="aacd8f0c6ea285dfebf728bb642919ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd8f0c6ea285dfebf728bb642919ec6">&#9670;&#160;</a></span>enum_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::enum_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ICtaStraCtx_8h.html#ae91c21a4f808e56c0dcf692873157a9e">FuncEnumCtaPosCallBack</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForExecute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>枚举持仓回调 </p>
<p>实现ICtaStraCtx接口的方法，用于枚举当前所有持仓信息 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>持仓回调函数 </td></tr>
    <tr><td class="paramname">bForExecute</td><td>是否为执行目的而枚举 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#af10b2727d379ab6abfa7a73099f3db08">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01454">1454</a> 行定义.</p>

</div>
</div>
<a id="aa76ab6828f30fbccca75abf9e0cfe702" name="aa76ab6828f30fbccca75abf9e0cfe702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76ab6828f30fbccca75abf9e0cfe702">&#9670;&#160;</a></span>get_cond_entrusts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CtaMocker_8h.html#a554586e84eb02c2dd968b6cbb4af59ef">CondList</a> &amp; CtaMocker::get_cond_entrusts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取条件委托列表 </p>
<p>获取指定合约的条件委托列表，如果不存在则创建新的列表 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回条件委托列表的引用</dd></dl>
<p>获取指定合约的条件委托列表，如果不存在则创建新的列表 条件委托用于实现条件单功能，当满足特定条件时触发交易 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>条件委托列表的引用 </dd></dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01524">1524</a> 行定义.</p>

</div>
</div>
<a id="aaeecff95f38049ea695f93b637c968bf" name="aaeecff95f38049ea695f93b637c968bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeecff95f38049ea695f93b637c968bf">&#9670;&#160;</a></span>handle_bar_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_bar_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理K线关闭 </p>
<p>处理K线关闭事件</p>
<p>实现IDataSink接口的方法，处理K线关闭事件，触发策略的on_bar_close回调 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"/"m5"/"d1"等 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的handle_bar_close方法，在新的K线完成时调用 调用策略的on_bar方法，将新的K线数据传递给策略进行处理 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"、"d1"等 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数，如对应的周期是分钟线，则表示多少分钟 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据结构指针 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classIDataSink.html#a7b32410de4629a8ea22ff8f9547f9f4d">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00748">748</a> 行定义.</p>

</div>
</div>
<a id="a6e6da3819230342327805aa435ae69d7" name="a6e6da3819230342327805aa435ae69d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6da3819230342327805aa435ae69d7">&#9670;&#160;</a></span>handle_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理初始化 </p>
<p>处理初始化事件</p>
<p>实现IDataSink接口的方法，处理初始化事件，触发策略的on_init回调</p>
<p>实现IDataSink接口的handle_init方法，在回测引擎初始化时调用 调用策略的on_init方法，允许策略进行初始化操作 </p>

<p>实现了 <a class="el" href="classIDataSink.html#aad99745d3af1e228d167db17730e755c">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00734">734</a> 行定义.</p>

</div>
</div>
<a id="a3378ca58a307aa37163f1e822902a159" name="a3378ca58a307aa37163f1e822902a159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3378ca58a307aa37163f1e822902a159">&#9670;&#160;</a></span>handle_replay_done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_replay_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理回放完成 </p>
<p>处理回放完成事件</p>
<p>实现IDataSink接口的方法，处理历史数据回放完成事件，输出回测结果</p>
<p>实现IDataSink接口的handle_replay_done方法，在历史数据回放完成时调用 导出策略数据、图表数据和输出数据，完成回测结果的保存 </p>

<p>重载 <a class="el" href="classIDataSink.html#a449d6fee677ebdce5747ec8db2cb1afc">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00809">809</a> 行定义.</p>

</div>
</div>
<a id="a1d4e4a7638b0239a861673e43a7a7038" name="a1d4e4a7638b0239a861673e43a7a7038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4e4a7638b0239a861673e43a7a7038">&#9670;&#160;</a></span>handle_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_schedule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uDate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>uTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理调度事件 </p>
<p>处理定时事件</p>
<p>实现IDataSink接口的方法，处理定时调度事件，触发策略的on_schedule回调 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uDate</td><td>当前日期，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">uTime</td><td>当前时间，格式为HHMMSS</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的handle_schedule方法，在定时器触发时调用 调用策略的on_schedule方法，允许策略执行定时任务 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uDate</td><td>当前日期，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">uTime</td><td>当前时间，格式为HHMMSS或HHMMSS000 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classIDataSink.html#a2e95899a2f5e48dd47cdb89eef7af3d7">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00760">760</a> 行定义.</p>

</div>
</div>
<a id="aaaf3d36e182ec784cac99877f6d5f5c4" name="aaaf3d36e182ec784cac99877f6d5f5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf3d36e182ec784cac99877f6d5f5c4">&#9670;&#160;</a></span>handle_section_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_section_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易时段结束 </p>
<p>处理交易小节结束事件</p>
<p>实现IDataSink接口的方法，处理交易时段结束事件，清理价格缓存 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间，格式为HHMMSS</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的handle_section_end方法，在交易小节结束时调用 清理价格缓存数据，防止小节之间的跳空引起计算错误，主要针对夜盘交易 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间，格式为HHMMSS或HHMMSS000 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classIDataSink.html#a484f5ab1b9ea855ddbc56cfedf324312">IDataSink</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00794">794</a> 行定义.</p>

</div>
</div>
<a id="a2b78d796d70c20b2c0609e6fa43bc708" name="a2b78d796d70c20b2c0609e6fa43bc708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b78d796d70c20b2c0609e6fa43bc708">&#9670;&#160;</a></span>handle_session_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_session_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易日开始 </p>
<p>处理交易日开始事件</p>
<p>实现IDataSink接口的方法，处理交易日开始事件，触发策略的on_session_begin回调 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的handle_session_begin方法，在每个交易日开始时调用 调用策略的on_session_begin方法，允许策略执行交易日开始时的初始化操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classIDataSink.html#a7518e7f54d3c02334d5bf8039d998ea1">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00771">771</a> 行定义.</p>

</div>
</div>
<a id="a69304e304883666400973a2f70c68455" name="a69304e304883666400973a2f70c68455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69304e304883666400973a2f70c68455">&#9670;&#160;</a></span>handle_session_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_session_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理交易日结束 </p>
<p>处理交易日结束事件</p>
<p>实现IDataSink接口的方法，处理交易日结束事件，触发策略的on_session_end回调 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的handle_session_end方法，在每个交易日结束时调用 调用策略的on_session_end方法，允许策略执行交易日结束时的清理操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classIDataSink.html#a3a8c562237bfa38cf0a789d2156e7f83">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00782">782</a> 行定义.</p>

</div>
</div>
<a id="a25d146399844e3a212623042682a66f0" name="a25d146399844e3a212623042682a66f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d146399844e3a212623042682a66f0">&#9670;&#160;</a></span>handle_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::handle_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pxType</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理Tick数据 </p>
<p>处理Tick数据事件</p>
<p>实现IDataSink接口的方法，处理历史数据回放器提供的Tick数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">curTick</td><td>当前Tick数据对象 </td></tr>
    <tr><td class="paramname">pxType</td><td>价格类型，默认为0</td></tr>
  </table>
  </dd>
</dl>
<p>实现IDataSink接口的handle_tick方法，在收到新的Tick数据时调用 记录当前价格并调用proc_tick函数处理Tick数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据结构指针 </td></tr>
    <tr><td class="paramname">pxType</td><td>价格类型，默认为0，表示使用最新价 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classIDataSink.html#a49f916a6431df8140564afd06bf20158">IDataSink</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01064">1064</a> 行定义.</p>

</div>
</div>
<a id="ab8f85dbad629ef629d8190985d2edef5" name="ab8f85dbad629ef629d8190985d2edef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f85dbad629ef629d8190985d2edef5">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t CtaMocker::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取策略上下文ID </p>
<p>实现ICtaStraCtx接口的方法，返回策略上下文的唯一标识符 </p><dl class="section return"><dt>返回</dt><dd>返回策略上下文ID </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a8a04e679ed9ef8719dd3c6419be6ce9b">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00334">334</a> 行定义.</p>

</div>
</div>
<a id="aabc6ad6721e46a6963d5c2e8475151c5" name="aabc6ad6721e46a6963d5c2e8475151c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc6ad6721e46a6963d5c2e8475151c5">&#9670;&#160;</a></span>init_cta_factory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::init_cta_factory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWTSVariant.html">WTSVariant</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>初始化CTA策略工厂 </p>
<p>根据配置初始化CTA策略工厂，并加载策略模块 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>策略配置，包含策略模块路径等信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回初始化是否成功</dd></dl>
<p>加载策略工厂动态库，并初始化策略工厂实例，为后续创建和管理策略做准备 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>配置项，包含策略工厂动态库路径等信息 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回初始化是否成功，true表示成功，false表示失败 </dd></dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00512">512</a> 行定义.</p>

</div>
</div>
<a id="a72bf0f1487e76b1f7696c87d444a3da4" name="a72bf0f1487e76b1f7696c87d444a3da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bf0f1487e76b1f7696c87d444a3da4">&#9670;&#160;</a></span>install_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::install_hook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>安装钩子 </p>
<p>安装用于控制回测过程的钩子函数，使得回测可以暂停和步进 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01256">1256</a> 行定义.</p>

</div>
</div>
<a id="a585c1b688e418610c3b829a2e282f277" name="a585c1b688e418610c3b829a2e282f277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585c1b688e418610c3b829a2e282f277">&#9670;&#160;</a></span>load_incremental_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::load_incremental_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>incremental_backtest_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>加载增量回测数据 </p>
<p>从指定的上一次回测结果中加载增量数据，用于继续回测 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastBacktestName</td><td>上一次回测的名称，用于定位数据文件</td></tr>
  </table>
  </dd>
</dl>
<p>从指定目录加载增量回测数据，包括交易日志、平仓日志、资金日志、信号日志、持仓日志等 增量回测允许继续之前的回测结果，而不需要重新计算所有历史数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">incremental_backtest_base</td><td>增量回测数据的基础目录名 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00557">557</a> 行定义.</p>

</div>
</div>
<a id="ae3029d436c270b03f2586cbebf3d07e5" name="ae3029d436c270b03f2586cbebf3d07e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3029d436c270b03f2586cbebf3d07e5">&#9670;&#160;</a></span>log_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::log_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>openTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>openpx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>closeTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>closepx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>profit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxprofit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxloss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>totalprofit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>enterTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>exitTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>openBarNo</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>closeBarNo</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录平仓 </p>
<p>记录平仓信息</p>
<p>记录策略平仓的详细信息，包括开仓时间、平仓时间、价格、盈亏等 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头交易 </td></tr>
    <tr><td class="paramname">openTime</td><td>开仓时间 </td></tr>
    <tr><td class="paramname">openpx</td><td>开仓价格 </td></tr>
    <tr><td class="paramname">closeTime</td><td>平仓时间 </td></tr>
    <tr><td class="paramname">closepx</td><td>平仓价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">profit</td><td>交易盈亏 </td></tr>
    <tr><td class="paramname">maxprofit</td><td>最大盈利 </td></tr>
    <tr><td class="paramname">maxloss</td><td>最大亏损 </td></tr>
    <tr><td class="paramname">totalprofit</td><td>总盈亏，默认为0 </td></tr>
    <tr><td class="paramname">enterTag</td><td>开仓标记，默认为空字符串 </td></tr>
    <tr><td class="paramname">exitTag</td><td>平仓标记，默认为空字符串 </td></tr>
    <tr><td class="paramname">openBarNo</td><td>开仓K线序号，默认为0 </td></tr>
    <tr><td class="paramname">closeBarNo</td><td>平仓K线序号，默认为0</td></tr>
  </table>
  </dd>
</dl>
<p>将策略执行过程中的平仓信息记录到平仓日志中，包含开仓和平仓的完整过程数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头交易，true表示多头，false表示空头 </td></tr>
    <tr><td class="paramname">openTime</td><td>开仓时间 </td></tr>
    <tr><td class="paramname">openpx</td><td>开仓价格 </td></tr>
    <tr><td class="paramname">closeTime</td><td>平仓时间 </td></tr>
    <tr><td class="paramname">closepx</td><td>平仓价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">profit</td><td>平仓盈亏 </td></tr>
    <tr><td class="paramname">maxprofit</td><td>最大浮盈 </td></tr>
    <tr><td class="paramname">maxloss</td><td>最大浮亏 </td></tr>
    <tr><td class="paramname">totalprofit</td><td>累计盈亏，默认为0 </td></tr>
    <tr><td class="paramname">enterTag</td><td>开仓标签，默认为空字符串 </td></tr>
    <tr><td class="paramname">exitTag</td><td>平仓标签，默认为空字符串 </td></tr>
    <tr><td class="paramname">openBarNo</td><td>开仓K线序号，默认为0 </td></tr>
    <tr><td class="paramname">closeBarNo</td><td>平仓K线序号，默认为0 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00498">498</a> 行定义.</p>

</div>
</div>
<a id="ae4fa5a70a85d6124182340870ea66d22" name="ae4fa5a70a85d6124182340870ea66d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fa5a70a85d6124182340870ea66d22">&#9670;&#160;</a></span>log_debug()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::log_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>调试日志辅助函数 </p>
<p>用于格式化并输出调试日志，支持参数格式化 </p><dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>参数类型包，可变参数模板 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>格式化字符串，类似printf的格式 </td></tr>
    <tr><td class="paramname">args</td><td>可变参数列表，用于填充格式化字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00752">752</a> 行定义.</p>

</div>
</div>
<a id="a563dde9ee9ab1060af6f25dd4db60b4f" name="a563dde9ee9ab1060af6f25dd4db60b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563dde9ee9ab1060af6f25dd4db60b4f">&#9670;&#160;</a></span>log_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::log_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>错误日志辅助函数 </p>
<p>用于格式化并输出错误日志，支持参数格式化 </p><dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>参数类型包，可变参数模板 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>格式化字符串，类似printf的格式 </td></tr>
    <tr><td class="paramname">args</td><td>可变参数列表，用于填充格式化字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00780">780</a> 行定义.</p>

</div>
</div>
<a id="acefa327470a483e7c7c16e54fc6f6748" name="acefa327470a483e7c7c16e54fc6f6748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefa327470a483e7c7c16e54fc6f6748">&#9670;&#160;</a></span>log_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::log_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>信息日志辅助函数 </p>
<p>用于格式化并输出信息日志，支持参数格式化 </p><dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>参数类型包，可变参数模板 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>格式化字符串，类似printf的格式 </td></tr>
    <tr><td class="paramname">args</td><td>可变参数列表，用于填充格式化字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00766">766</a> 行定义.</p>

</div>
</div>
<a id="a43e0635d16462242feb1142d6baeef3a" name="a43e0635d16462242feb1142d6baeef3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e0635d16462242feb1142d6baeef3a">&#9670;&#160;</a></span>log_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::log_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>gentime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>usertag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录信号 </p>
<p>记录交易信号</p>
<p>记录策略生成的交易信号，包括目标仓位、价格、生成时间等 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">target</td><td>目标仓位 </td></tr>
    <tr><td class="paramname">price</td><td>信号价格 </td></tr>
    <tr><td class="paramname">gentime</td><td>信号生成时间 </td></tr>
    <tr><td class="paramname">usertag</td><td>用户标记，默认为空字符串</td></tr>
  </table>
  </dd>
</dl>
<p>将策略生成的交易信号记录到信号日志中，便于后续分析和展示 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">target</td><td>目标仓位，正数表示多头仓位，负数表示空头仓位 </td></tr>
    <tr><td class="paramname">price</td><td>信号价格，即信号产生时的参考价格 </td></tr>
    <tr><td class="paramname">gentime</td><td>信号产生时间 </td></tr>
    <tr><td class="paramname">usertag</td><td>用户自定义标签，用于标记信号的特殊含义，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00455">455</a> 行定义.</p>

</div>
</div>
<a id="ac906fa4766546a782b7065134608974c" name="ac906fa4766546a782b7065134608974c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac906fa4766546a782b7065134608974c">&#9670;&#160;</a></span>log_trade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::log_trade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLong</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isOpen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>curTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fee</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>barNo</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录交易 </p>
<p>记录交易明细</p>
<p>记录策略执行的交易详情，包括合约、方向、开平仓、价格、数量等 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头交易 </td></tr>
    <tr><td class="paramname">isOpen</td><td>是否为开仓交易 </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，默认为空字符串 </td></tr>
    <tr><td class="paramname">fee</td><td>交易手续费，默认为0.0 </td></tr>
    <tr><td class="paramname">barNo</td><td>K线序号，默认为0</td></tr>
  </table>
  </dd>
</dl>
<p>将策略执行过程中的交易明细记录到交易日志中，便于后续分析和回测评估 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">isLong</td><td>是否为多头交易，true表示多头，false表示空头 </td></tr>
    <tr><td class="paramname">isOpen</td><td>是否为开仓交易，true表示开仓，false表示平仓 </td></tr>
    <tr><td class="paramname">curTime</td><td>交易发生时间 </td></tr>
    <tr><td class="paramname">price</td><td>交易价格 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，用于标记交易的特殊含义 </td></tr>
    <tr><td class="paramname">fee</td><td>交易手续费 </td></tr>
    <tr><td class="paramname">barNo</td><td>K线序号，标记交易发生在哪一根K线上 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00473">473</a> 行定义.</p>

</div>
</div>
<a id="a6a9e32eb93635cc9da7c285ff6806b68" name="a6a9e32eb93635cc9da7c285ff6806b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9e32eb93635cc9da7c285ff6806b68">&#9670;&#160;</a></span>on_bar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_bar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K线数据回调 </p>
<p>K线数据回调函数</p>
<p>实现ICtaStraCtx接口的方法，在接收到K线数据时调用，用于处理K线数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"/"m5"/"d1"等 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>当新的K线数据生成时，该函数被调用 用于处理K线闭合事件，并在需要时触发策略的on_bar回调 通过_kline_tags记录K线状态，标记K线是否已闭合 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m"(分钟)、"d"(日)等 </td></tr>
    <tr><td class="paramname">times</td><td>周期倍数，如5表示5分钟K线 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据指针 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a0db3d0c845ff482452adb6941487282d">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01121">1121</a> 行定义.</p>

</div>
</div>
<a id="a344c481d4f657b7e2c35a8566f055fe7" name="a344c481d4f657b7e2c35a8566f055fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344c481d4f657b7e2c35a8566f055fe7">&#9670;&#160;</a></span>on_bar_close()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_bar_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structWTSBarStruct.html">WTSBarStruct</a> *&#160;</td>
          <td class="paramname"><em>newBar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>K线关闭回调 </p>
<p>K线闭合回调函数</p>
<p>实现ICtaStraCtx接口的方法，在K线关闭时调用，用于处理K线关闭事件 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"/"m5"/"d1"等 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据</td></tr>
  </table>
  </dd>
</dl>
<p>当K线闭合时，该函数被调用 该函数会将K线数据传递给策略的on_bar回调函数 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"(一分钟)、"d1"(日线)等 </td></tr>
    <tr><td class="paramname">newBar</td><td>新的K线数据指针 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a8f3f06688e59e7cdce455af9692ea05a">ICtaStraCtx</a>.</p>

<p>被 <a class="el" href="classExpCtaMocker.html#ade845b5f75f9163482fa037117918872">ExpCtaMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01220">1220</a> 行定义.</p>

</div>
</div>
<a id="a9a957a84fbe7f105a768b54fe713b87a" name="a9a957a84fbe7f105a768b54fe713b87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a957a84fbe7f105a768b54fe713b87a">&#9670;&#160;</a></span>on_calculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_calculate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curDate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算回调 </p>
<p>实现ICtaStraCtx接口的方法，在需要进行策略计算时调用 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curDate</td><td>当前日期，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间，格式为HHMMSS </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#acc148348095e40c77aa2ef7651b8261d">ICtaStraCtx</a>.</p>

<p>被 <a class="el" href="classExpCtaMocker.html#accb50771487b989b208597150259ffcd">ExpCtaMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01243">1243</a> 行定义.</p>

</div>
</div>
<a id="aa107ca2e682729b1ab51db4eecd40dad" name="aa107ca2e682729b1ab51db4eecd40dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa107ca2e682729b1ab51db4eecd40dad">&#9670;&#160;</a></span>on_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>初始化回调 </p>
<p>实现ICtaStraCtx接口的方法，在策略初始化时调用，用于执行策略的初始化逻辑 </p>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a96eaee98050b938e210e8b663ca17637">ICtaStraCtx</a>.</p>

<p>被 <a class="el" href="classExpCtaMocker.html#a81456173a323232276c631cf4c090f41">ExpCtaMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01139">1139</a> 行定义.</p>

</div>
</div>
<a id="a24fae10edb81dd7a6cce9228ecd16866" name="a24fae10edb81dd7a6cce9228ecd16866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fae10edb81dd7a6cce9228ecd16866">&#9670;&#160;</a></span>on_schedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::on_schedule </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curDate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>定时调度回调 </p>
<p>实现ICtaStraCtx接口的方法，在定时调度时调用，用于执行定时任务 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curDate</td><td>当前日期，格式为YYYYMMDD </td></tr>
    <tr><td class="paramname">curTime</td><td>当前时间，格式为HHMMSS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回处理是否成功 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a250442db7706fbf3e2f3dd537b339ccb">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01302">1302</a> 行定义.</p>

</div>
</div>
<a id="abefd08688ebc435d349710ecbc4939ed" name="abefd08688ebc435d349710ecbc4939ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefd08688ebc435d349710ecbc4939ed">&#9670;&#160;</a></span>on_session_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_session_begin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日开始回调 </p>
<p>处理交易日开始事件</p>
<p>实现ICtaStraCtx接口的方法，在每个交易日开始时调用，用于执行策略在交易日开始时的逻辑 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日开始时调用，执行交易日初始化操作 包括重置冻结持仓、清空价格缓存等 并调用策略的on_session_begin方法 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a74c1b11d95c09d3c7b01df02b35fded2">ICtaStraCtx</a>.</p>

<p>被 <a class="el" href="classExpCtaMocker.html#a7f7a9a0d4c8139b6ec12f3d18e566dfe">ExpCtaMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01428">1428</a> 行定义.</p>

</div>
</div>
<a id="a90c50839206c3c9f52a8d92e5eb4ed12" name="a90c50839206c3c9f52a8d92e5eb4ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c50839206c3c9f52a8d92e5eb4ed12">&#9670;&#160;</a></span>on_session_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_session_end </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curTDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日结束回调 </p>
<p>处理交易日结束事件</p>
<p>实现ICtaStraCtx接口的方法，在每个交易日结束时调用，用于执行策略在交易日结束时的逻辑 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD</td></tr>
  </table>
  </dd>
</dl>
<p>在每个交易日结束时调用，执行交易日收尾操作 计算并记录当日的资金信息，包括总盈亏、浮动盈亏、手续费等 并调用策略的on_session_end方法 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">curTDate</td><td>当前交易日，格式为YYYYMMDD </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a4c2a9169e9d06ae31f0ba4cddb77ca2a">ICtaStraCtx</a>.</p>

<p>被 <a class="el" href="classExpCtaMocker.html#a2ceba7d3fd9bef4e5e695abea74bc94c">ExpCtaMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01484">1484</a> 行定义.</p>

</div>
</div>
<a id="a71df70ff014ab1ba65a0bbd9b3543881" name="a71df70ff014ab1ba65a0bbd9b3543881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71df70ff014ab1ba65a0bbd9b3543881">&#9670;&#160;</a></span>on_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEmitStrategy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick数据回调 </p>
<p>Tick数据处理函数</p>
<p>实现ICtaStraCtx接口的方法，在接收到Tick数据时调用，用于处理最新的市场行情数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据 </td></tr>
    <tr><td class="paramname">bEmitStrategy</td><td>是否触发策略计算，默认为true</td></tr>
  </table>
  </dd>
</dl>
<p>处理新到达的Tick数据 注意：此函数的逻辑已全部迁移到handle_tick函数中，此处仅保留函数接口 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据指针 </td></tr>
    <tr><td class="paramname">bEmitStrategy</td><td>是否触发策略回调，默认为true </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#aec9d3f6aa12765b3269b9bcec84455bd">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01207">1207</a> 行定义.</p>

</div>
</div>
<a id="ab720557f7a5d17cb9e4b0a76cc22c45f" name="ab720557f7a5d17cb9e4b0a76cc22c45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab720557f7a5d17cb9e4b0a76cc22c45f">&#9670;&#160;</a></span>on_tick_updated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::on_tick_updated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classWTSTickData.html">WTSTickData</a> *&#160;</td>
          <td class="paramname"><em>newTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick数据更新回调 </p>
<p>Tick数据更新回调函数</p>
<p>实现ICtaStraCtx接口的方法，在Tick数据更新时调用，与on_tick不同的是不触发策略计算 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据</td></tr>
  </table>
  </dd>
</dl>
<p>当合约的Tick数据更新时，该函数被调用 如果该合约已经被订阅，则将新的Tick数据传递给策略的on_tick回调 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>合约代码 </td></tr>
    <tr><td class="paramname">newTick</td><td>新的Tick数据指针 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a1ce99f9e6446e9e4d4120ae4d68ebd6b">ICtaStraCtx</a> .</p>

<p>被 <a class="el" href="classExpCtaMocker.html#afe9e608d8cc6c37da2e26a0d89094688">ExpCtaMocker</a> 重载.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01233">1233</a> 行定义.</p>

</div>
</div>
<a id="ab8b32fb38361c6fd778c668ebeb85774" name="ab8b32fb38361c6fd778c668ebeb85774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b32fb38361c6fd778c668ebeb85774">&#9670;&#160;</a></span>proc_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::proc_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>last_px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cur_px</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>处理Tick数据 </p>
<p>处理Tick数据并检查条件委托是否触发 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">last_px</td><td>上一次价格 </td></tr>
    <tr><td class="paramname">cur_px</td><td>当前价格</td></tr>
  </table>
  </dd>
</dl>
<p>处理合约的Tick数据，实现以下功能：</p><ol type="1">
<li>执行信号表中的交易信号</li>
<li>更新浮动盈亏</li>
<li>检查并触发满足条件的条件单 <dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">last_px</td><td>上一次的价格 </td></tr>
    <tr><td class="paramname">cur_px</td><td>当前最新价格 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l00853">853</a> 行定义.</p>

</div>
</div>
<a id="acde7808a9ecd363da5e7bc35295f9920" name="acde7808a9ecd363da5e7bc35295f9920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde7808a9ecd363da5e7bc35295f9920">&#9670;&#160;</a></span>register_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::register_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>idxName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>注册图表指标接口 </p>
<p>注册图表指标</p>
<p>实现ICtaStraCtx接口的方法，用于注册新的图表指标 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，用于唯一标识指标 </td></tr>
    <tr><td class="paramname">indexType</td><td>指标类型，用于指定指标的类型</td></tr>
  </table>
  </dd>
</dl>
<p>注册一个图表指标，用于在回测图表上显示自定义指标 指标可以是主图指标或副图指标，由indexType决定 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，用于标识不同的指标 </td></tr>
    <tr><td class="paramname">indexType</td><td>指标类型，0表示主图指标，1表示副图指标 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a86bae2d0ae1f599ba02176f5229d85a9">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02648">2648</a> 行定义.</p>

</div>
</div>
<a id="ad238a2fb0263572adb75c70f72530ac2" name="ad238a2fb0263572adb75c70f72530ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad238a2fb0263572adb75c70f72530ac2">&#9670;&#160;</a></span>register_index_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::register_index_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>idxName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>lineName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lineType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>注册指标线接口 </p>
<p>注册指标线</p>
<p>实现ICtaStraCtx接口的方法，用于在指定指标上注册新的线条 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，指定要添加线条的指标 </td></tr>
    <tr><td class="paramname">lineName</td><td>线条名称，用于唯一标识线条 </td></tr>
    <tr><td class="paramname">lineType</td><td>线条类型，用于指定线条的呈现方式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回注册是否成功</dd></dl>
<p>为已注册的指标添加一条指标线，用于在图表上显示指标的不同数据系列 指标线可以有不同的类型，如实线、虚线、柱状图等，由lineType决定 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，必须是已经注册过的指标 </td></tr>
    <tr><td class="paramname">lineName</td><td>指标线名称，用于标识同一指标下的不同数据系列 </td></tr>
    <tr><td class="paramname">lineType</td><td>指标线类型，如实线、虚线、柱状图等 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>注册成功返回true，失败返回false </dd></dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a63275beecb26f84bde19fc94717f5b66">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02664">2664</a> 行定义.</p>

</div>
</div>
<a id="ae72e0d562c13ad93b1603d0f749e7682" name="ae72e0d562c13ad93b1603d0f749e7682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e0d562c13ad93b1603d0f749e7682">&#9670;&#160;</a></span>set_chart_kline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::set_chart_kline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置图表K线接口 </p>
<p>设置图表K线</p>
<p>实现ICtaStraCtx接口的方法，用于设置图表展示的K线数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码，指定要展示的合约 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"/"m5"/"d1"等</td></tr>
  </table>
  </dd>
</dl>
<p>设置图表展示的合约和K线周期 用于确定回测图表的主图显示内容 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"、"d1"等 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a1b1f4bfc87d2fd5b60e9d9249d57ff16">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02612">2612</a> 行定义.</p>

</div>
</div>
<a id="a87e109dc3a6723024cfb77a7ece700a0" name="a87e109dc3a6723024cfb77a7ece700a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e109dc3a6723024cfb77a7ece700a0">&#9670;&#160;</a></span>set_index_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::set_index_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>idxName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>lineName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置指标值接口 </p>
<p>设置指标线数值</p>
<p>实现ICtaStraCtx接口的方法，用于设置指定指标线的当前值 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，指定要设置值的指标 </td></tr>
    <tr><td class="paramname">lineName</td><td>线条名称，指定要设置值的线条 </td></tr>
    <tr><td class="paramname">val</td><td>指标值，要设置的数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回设置是否成功</dd></dl>
<p>设置指定指标线的当前数值，用于更新图表上的指标数据 只能在定时调度期间调用该函数 指标数据会记录当前时间、指标名称、指标线名称和数值 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxName</td><td>指标名称，必须是已经注册过的指标 </td></tr>
    <tr><td class="paramname">lineName</td><td>指标线名称，必须是已经注册过的指标线 </td></tr>
    <tr><td class="paramname">val</td><td>指标线的数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>设置成功返回true，失败返回false </dd></dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a7221d1785964a788980b0624c711ec39">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02713">2713</a> 行定义.</p>

</div>
</div>
<a id="a385ba7881936d96ed1f52922d00b57d0" name="a385ba7881936d96ed1f52922d00b57d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ba7881936d96ed1f52922d00b57d0">&#9670;&#160;</a></span>step_calc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::step_calc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>单步计算 </p>
<p>执行一步回测计算，用于手动控制回测过程 </p><dl class="section return"><dt>返回</dt><dd>返回计算是否成功 </dd></dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01263">1263</a> 行定义.</p>

</div>
</div>
<a id="a017edf9c5cac0a09194e73769c2e02b0" name="a017edf9c5cac0a09194e73769c2e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017edf9c5cac0a09194e73769c2e02b0">&#9670;&#160;</a></span>stra_enter_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_enter_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitprice</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopprice</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>开多仓接口 </p>
<p>策略多头开仓接口</p>
<p>实现ICtaStraCtx接口的方法，用于执行多头开仓操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，用于标识交易来源，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，限定价格成交，默认为0.0（市价单） </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，止损价格，默认为0.0（不设置止损）</td></tr>
  </table>
  </dd>
</dl>
<p>策略调用此接口执行多头开仓操作，可以设置限价或止损价 如果设置了限价或止损价，则会生成条件单，否则直接执行市价单 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>开仓数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，用于标记交易的特殊含义，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，如果大于0，则表示以不高于该价格的价格成交 </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，如果大于0，则表示当价格不低于该价格时触发开仓 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#af68515a83993f84c3e97849282668a8a">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01542">1542</a> 行定义.</p>

</div>
</div>
<a id="a5320b6458dafc391c76b064ded9af181" name="a5320b6458dafc391c76b064ded9af181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5320b6458dafc391c76b064ded9af181">&#9670;&#160;</a></span>stra_enter_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_enter_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitprice</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopprice</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>开空仓接口 </p>
<p>策略空头开仓接口</p>
<p>实现ICtaStraCtx接口的方法，用于执行空头开仓操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，用于标识交易来源，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，限定价格成交，默认为0.0（市价单） </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，止损价格，默认为0.0（不设置止损）</td></tr>
  </table>
  </dd>
</dl>
<p>策略调用此接口执行空头开仓操作，可以设置限价或止损价 如果设置了限价或止损价，则会生成条件单，否则直接执行市价单 注意：只有允许做空的合约才能执行空头开仓 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>开仓数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，用于标记交易的特殊含义，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，如果大于0，则表示以不低于该价格的价格成交 </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，如果大于0，则表示当价格不高于该价格时触发开仓 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ade019a348a8bc12c37433d307e8addcf">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01598">1598</a> 行定义.</p>

</div>
</div>
<a id="ada7ac26f273a037e4c091290c010c101" name="ada7ac26f273a037e4c091290c010c101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7ac26f273a037e4c091290c010c101">&#9670;&#160;</a></span>stra_exit_long()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_exit_long </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitprice</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopprice</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平多仓接口 </p>
<p>策略多头平仓接口</p>
<p>实现ICtaStraCtx接口的方法，用于执行多头平仓操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，用于标识交易来源，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，限定价格成交，默认为0.0（市价单） </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，止损价格，默认为0.0（不设置止损）</td></tr>
  </table>
  </dd>
</dl>
<p>策略调用此接口执行多头平仓操作，可以设置限价或止损价 如果设置了限价或止损价，则会生成条件单，否则直接执行市价单 如果当前没有多头仓位，则不会执行任何操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>平仓数量，如果大于当前持仓量，则平仓全部 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签，用于标记交易的特殊含义，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，如果大于0，则表示以不低于该价格的价格成交 </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，如果大于0，则表示当价格不高于该价格时触发平仓 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a8c0dbf8d5f34e9bee4b2fec1e9d4432a">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01661">1661</a> 行定义.</p>

</div>
</div>
<a id="a6bfd93cb52b7aed2744ce89f165e7441" name="a6bfd93cb52b7aed2744ce89f165e7441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfd93cb52b7aed2744ce89f165e7441">&#9670;&#160;</a></span>stra_exit_short()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_exit_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitprice</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopprice</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平空仓接口 </p>
<p>实现ICtaStraCtx接口的方法，用于执行空头平仓操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>交易数量 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，用于标识交易来源，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，限定价格成交，默认为0.0（市价单） </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，止损价格，默认为0.0（不设置止损） </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#aa68e8703be6f3f48be70f3174f60f519">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01712">1712</a> 行定义.</p>

</div>
</div>
<a id="a73ea08684bf163c866887ad05ccd4421" name="a73ea08684bf163c866887ad05ccd4421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ea08684bf163c866887ad05ccd4421">&#9670;&#160;</a></span>stra_get_bars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSKlineSlice.html">WTSKlineSlice</a> * CtaMocker::stra_get_bars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMain</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取K线切片接口 </p>
<p>获取合约的K线数据</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的历史K线数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"/"m5"/"d1"等 </td></tr>
    <tr><td class="paramname">count</td><td>请求的K线数量 </td></tr>
    <tr><td class="paramname">isMain</td><td>是否为主功K线，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回K线切片对象指针，使用完毕需要释放</dd></dl>
<p>获取指定合约的指定周期的K线数据 可以指定是否作为主图指标，如果是主图指标，则会记录主图周期 返回的数据包含最新的count根K线 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如m1表示1分钟，d1表示日线 </td></tr>
    <tr><td class="paramname">count</td><td>要获取的K线数量 </td></tr>
    <tr><td class="paramname">isMain</td><td>是否作为主图指标，默认为false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>K线数据切片指针，调用者需要自行释放 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a1b69efd8750d6072993c6d259facb417">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02068">2068</a> 行定义.</p>

</div>
</div>
<a id="af28cc8413611185bcc6797776452fe6b" name="af28cc8413611185bcc6797776452fe6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28cc8413611185bcc6797776452fe6b">&#9670;&#160;</a></span>stra_get_comminfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSCommodityInfo.html">WTSCommodityInfo</a> * CtaMocker::stra_get_comminfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取品种信息接口 </p>
<p>获取合约品种信息</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的品种信息 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回品种信息对象指针，使用完毕需要释放</dd></dl>
<p>根据标准合约代码获取对应的品种信息 品种信息包含合约乘数、最小变动单位、手续费率等信息 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>合约品种信息指针 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a843b56d8d093a3cbe2f87f5ecab2bfa3">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02184">2184</a> 行定义.</p>

</div>
</div>
<a id="ab080a3a984a9f88836d15ad82767d10a" name="ab080a3a984a9f88836d15ad82767d10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab080a3a984a9f88836d15ad82767d10a">&#9670;&#160;</a></span>stra_get_date()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::stra_get_date </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前日期接口 </p>
<p>获取当前回测日期</p>
<p>实现ICtaStraCtx接口的方法，用于获取当前的自然日期 </p><dl class="section return"><dt>返回</dt><dd>返回当前日期，格式为YYYYMMDD</dd></dl>
<p>获取当前回测的日期，格式为YYYYMMDD，例妈20220101 </p><dl class="section return"><dt>返回</dt><dd>当前回测日期 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a4034c85351f5cba54561b7029869ab57">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02217">2217</a> 行定义.</p>

</div>
</div>
<a id="a8400b42c0684f4d305ccfc7f074807c0" name="a8400b42c0684f4d305ccfc7f074807c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8400b42c0684f4d305ccfc7f074807c0">&#9670;&#160;</a></span>stra_get_day_price()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_day_price </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当日价格接口 </p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约当日的开盘价、最高价、最低价或收盘价 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">flag</td><td>价格标记，0-开盘价，1-最高价，2-最低价，3-收盘价，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回当日价格 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a512e3a612d6149d537fa2410b972b4b6">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01777">1777</a> 行定义.</p>

</div>
</div>
<a id="abc55a17b3939ca6d3f832e36f69bdb70" name="abc55a17b3939ca6d3f832e36f69bdb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc55a17b3939ca6d3f832e36f69bdb70">&#9670;&#160;</a></span>stra_get_detail_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_detail_cost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取详细开仓成本接口 </p>
<p>获取指定标签的持仓明细开仓成本</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约和标记的开仓成本 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回开仓成本</dd></dl>
<p>获取指定合约和指定用户标签的持仓明细的开仓价格 如果没有找到对应标签的持仓明细，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>开仓价格，如果没有找到对应标签的持仓明细则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#af115aa96efe4e5f0caebd638251f5edd">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02545">2545</a> 行定义.</p>

</div>
</div>
<a id="ae6fa5daaf6894d98ec41a2437f80090c" name="ae6fa5daaf6894d98ec41a2437f80090c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fa5daaf6894d98ec41a2437f80090c">&#9670;&#160;</a></span>stra_get_detail_entertime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CtaMocker::stra_get_detail_entertime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取详细开仓时间接口 </p>
<p>获取指定标签的持仓明细入场时间</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约和标记的开仓时间 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回开仓时间，以时间戳形式表示</dd></dl>
<p>获取指定合约和指定用户标签的持仓明细的入场时间 如果没有找到对应标签的持仓明细，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>入场时间，格式为YYYYMMDDHHMMSS，如果没有找到对应标签的持仓明细则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ab8ab0f45ce66e3d65134da6a7ffb1084">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02518">2518</a> 行定义.</p>

</div>
</div>
<a id="a88032d30a6a140b0a6932076348b5962" name="a88032d30a6a140b0a6932076348b5962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88032d30a6a140b0a6932076348b5962">&#9670;&#160;</a></span>stra_get_detail_profit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_detail_profit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取详细盈亏接口 </p>
<p>获取指定标签的持仓明细的各种盈亏信息</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约和标记的盈亏情况 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记 </td></tr>
    <tr><td class="paramname">flag</td><td>盈亏标记，0-浮动盈亏，1-平仓盈亏，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回盈亏金额</dd></dl>
<p>获取指定合约和指定用户标签的持仓明细的盈亏相关信息 可以获取当前盈亏、最大盈利、最大亏损、最高价格和最低价格 如果没有找到对应标签的持仓明细，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户自定义标签 </td></tr>
    <tr><td class="paramname">flag</td><td>标记参数：0-当前盈亏，1-最大盈利，-1-最大亏损，2-最高价格，-2-最低价格，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的盈亏信息，如果没有找到对应标签的持仓明细则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ac7a516fcae5b5e9553dab599c68e9faa">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02574">2574</a> 行定义.</p>

</div>
</div>
<a id="a9d09ae73d992e230679627897f48d142" name="a9d09ae73d992e230679627897f48d142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d09ae73d992e230679627897f48d142">&#9670;&#160;</a></span>stra_get_first_entertime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CtaMocker::stra_get_first_entertime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取首次开仓时间接口 </p>
<p>获取合约的首次入场时间</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的首次开仓时间 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回首次开仓时间，以时间戳形式表示</dd></dl>
<p>获取指定合约的首次入场时间，即最早的一笔持仓明细的开仓时间 如果没有持仓，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>首次入场时间，格式为YYYYMMDDHHMMSS，如果没有持仓则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a6811685fdbd53f599f10b87ee8ed8bca">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02336">2336</a> 行定义.</p>

</div>
</div>
<a id="a38cc433563a858a7818bf875eadab14c" name="a38cc433563a858a7818bf875eadab14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cc433563a858a7818bf875eadab14c">&#9670;&#160;</a></span>stra_get_fund_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_fund_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取资金数据接口 </p>
<p>获取策略资金数据</p>
<p>实现ICtaStraCtx接口的方法，用于获取策略账户的资金数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>资金数据标记，0-动态权益，1-静态权益，2-可用资金，默认为0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回指定类型的资金数据</dd></dl>
<p>获取策略的资金相关数据，包括总盈亏、已实现盈亏、浮动盈亏和手续费 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>数据标志：0-总盈亏（已实现盈亏-手续费+浮动盈亏），1-已实现盈亏，2-浮动盈亏，3-手续费 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的资金数据值 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#af5238215f0855798f4bd10b0541cc33f">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02238">2238</a> 行定义.</p>

</div>
</div>
<a id="a44fc9e9d86db9f1cba6ebaecd495166b" name="a44fc9e9d86db9f1cba6ebaecd495166b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fc9e9d86db9f1cba6ebaecd495166b">&#9670;&#160;</a></span>stra_get_last_enterprice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_last_enterprice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最近开仓价格接口 </p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的最近开仓价格 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回最近开仓价格 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a995e3ed98aa7ca2ed1d23b259dafc47d">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02406">2406</a> 行定义.</p>

</div>
</div>
<a id="a88dd1d1e4be89358a790cbc4bd9efe48" name="a88dd1d1e4be89358a790cbc4bd9efe48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88dd1d1e4be89358a790cbc4bd9efe48">&#9670;&#160;</a></span>stra_get_last_entertag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * CtaMocker::stra_get_last_entertag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最近开仓标记接口 </p>
<p>获取合约的最后入场标签</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的最近开仓标记 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回最近开仓标记</dd></dl>
<p>获取指定合约的最后入场标签，即最新的一笔持仓明细的开仓标签 如果没有持仓，则返回空字符串 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最后入场标签，如果没有持仓则返回空字符串 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ab99559f4f57b32c6f9431c17a9bd3e52">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02376">2376</a> 行定义.</p>

</div>
</div>
<a id="a22db2228875bf38e774e3cab3732f648" name="a22db2228875bf38e774e3cab3732f648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22db2228875bf38e774e3cab3732f648">&#9670;&#160;</a></span>stra_get_last_entertime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CtaMocker::stra_get_last_entertime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最近开仓时间接口 </p>
<p>获取合约的最后入场时间</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的最近开仓时间 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回最近开仓时间，以时间戳形式表示</dd></dl>
<p>获取指定合约的最后入场时间，即最新的一笔持仓明细的开仓时间 如果没有持仓，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最后入场时间，格式为YYYYMMDDHHMMSS，如果没有持仓则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ad226dae9bed8fcd2bbc0b44e56e45ca7">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02356">2356</a> 行定义.</p>

</div>
</div>
<a id="a5f3dce5566a3bc53d65cc15a62fae7bd" name="a5f3dce5566a3bc53d65cc15a62fae7bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3dce5566a3bc53d65cc15a62fae7bd">&#9670;&#160;</a></span>stra_get_last_exittime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CtaMocker::stra_get_last_exittime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最近平仓时间接口 </p>
<p>获取合约的最后平仓时间</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的最近平仓时间 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回最近平仓时间，以时间戳形式表示</dd></dl>
<p>获取指定合约的最后平仓时间 如果没有平仓记录，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最后平仓时间，格式为YYYYMMDDHHMMSS，如果没有平仓记录则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a6e932c2ee9bc8331973bccc20b6c74bc">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02396">2396</a> 行定义.</p>

</div>
</div>
<a id="a3cfafbc192125086ef451abc655361ff" name="a3cfafbc192125086ef451abc655361ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfafbc192125086ef451abc655361ff">&#9670;&#160;</a></span>stra_get_last_tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTickData.html">WTSTickData</a> * CtaMocker::stra_get_last_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取最新Tick接口 </p>
<p>获取合约的最新Tick数据</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的最新Tick数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回最新Tick数据对象指针，使用完毕需要释放</dd></dl>
<p>获取指定合约的最新Tick数据 首先从本地缓存中查找，如果没有则从回放器中获取 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>最新的Tick数据指针，调用者需要自行释放 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a933e0662673baa997ace2a93f61035aa">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02137">2137</a> 行定义.</p>

</div>
</div>
<a id="a9d014397a980ebb1ccd3844de0a001a9" name="a9d014397a980ebb1ccd3844de0a001a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d014397a980ebb1ccd3844de0a001a9">&#9670;&#160;</a></span>stra_get_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOnlyValid</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取仓位接口 </p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的当前仓位 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">bOnlyValid</td><td>是否只返回有效仓位（不包括冻结仓位），默认为false </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，用于过滤特定标记的仓位，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回仓位数量，正数表示多头，负数表示空头 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a7cce56f329a7047c906edd5b891e53b8">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02419">2419</a> 行定义.</p>

</div>
</div>
<a id="a070a89f9aa526ad24dc8a48619a18185" name="a070a89f9aa526ad24dc8a48619a18185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070a89f9aa526ad24dc8a48619a18185">&#9670;&#160;</a></span>stra_get_position_avgpx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_position_avgpx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取持仓均价接口 </p>
<p>获取合约的持仓平均价格</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的持仓均价 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回持仓均价</dd></dl>
<p>获取指定合约的当前持仓平均价格 计算方式为将所有持仓明细的价格乘以数量的总和除以总数量 如果没有持仓，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前持仓平均价格，如果没有持仓则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ae0747e6c18e9b79777531ba80601eb33">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02472">2472</a> 行定义.</p>

</div>
</div>
<a id="ab2083a28dda923242144bfecc4a677be" name="ab2083a28dda923242144bfecc4a677be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2083a28dda923242144bfecc4a677be">&#9670;&#160;</a></span>stra_get_position_profit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_position_profit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取持仓盈亏接口 </p>
<p>获取合约的持仓浮动盈亏</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的持仓盈亏 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回持仓盈亏</dd></dl>
<p>获取指定合约的当前持仓浮动盈亏 浮动盈亏是根据当前市场价格计算的未实现盈亏 如果没有持仓，则返回0 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前持仓浮动盈亏，如果没有持仓则返回0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a727410a02fef842e0069160d9225de7d">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02500">2500</a> 行定义.</p>

</div>
</div>
<a id="a3c54a2f806b69b2207689308a91ce94f" name="a3c54a2f806b69b2207689308a91ce94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c54a2f806b69b2207689308a91ce94f">&#9670;&#160;</a></span>stra_get_price()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::stra_get_price </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前价格接口 </p>
<p>获取合约当前价格</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的当前市场价格 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回当前价格</dd></dl>
<p>获取指定合约的当前最新价格，由回放器提供 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>当前最新价格，如果回放器不可用则返回0.0 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ad823ea710a2e96a3edb35c3e9e4bdb20">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01769">1769</a> 行定义.</p>

</div>
</div>
<a id="aae9e3ac7c4e78fe43788d01c7ef008ff" name="aae9e3ac7c4e78fe43788d01c7ef008ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9e3ac7c4e78fe43788d01c7ef008ff">&#9670;&#160;</a></span>stra_get_rawcode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CtaMocker::stra_get_rawcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取原始合约代码接口 </p>
<p>获取合约原始代码</p>
<p>实现ICtaStraCtx接口的方法，用于获取标准化合约代码对应的原始合约代码 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回原始合约代码</dd></dl>
<p>根据标准合约代码获取原始交易所合约代码 标准合约代码是系统内部统一格式，原始代码是交易所实际使用的代码 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>原始交易所合约代码 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#aa7892eb2e1c5ebe19dd97d7087bfd2b0">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02196">2196</a> 行定义.</p>

</div>
</div>
<a id="a4e59b1bc274339781952a11221384385" name="a4e59b1bc274339781952a11221384385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e59b1bc274339781952a11221384385">&#9670;&#160;</a></span>stra_get_tdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::stra_get_tdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前交易日接口 </p>
<p>获取当前交易日期</p>
<p>实现ICtaStraCtx接口的方法，用于获取当前的交易日期 </p><dl class="section return"><dt>返回</dt><dd>返回当前交易日，格式为YYYYMMDD</dd></dl>
<p>获取当前回测的交易日期，格式为YYYYMMDD，例妈20220101 交易日期与自然日期不同，夜盘交易属于下一个交易日 </p><dl class="section return"><dt>返回</dt><dd>当前交易日期 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a870c9c5eb14afb0f56a20b59a04bcbac">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02207">2207</a> 行定义.</p>

</div>
</div>
<a id="af779b88b6bb26f659170a7fc52e1be00" name="af779b88b6bb26f659170a7fc52e1be00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af779b88b6bb26f659170a7fc52e1be00">&#9670;&#160;</a></span>stra_get_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWTSTickSlice.html">WTSTickSlice</a> * CtaMocker::stra_get_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取Tick切片接口 </p>
<p>获取合约的历史Tick数据切片</p>
<p>实现ICtaStraCtx接口的方法，用于获取指定合约的历史Tick数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>请求的Tick数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回Tick切片对象指针，使用完毕需要释放</dd></dl>
<p>获取指定合约的最新一定数量的Tick数据切片 返回的数据包含最新的count个Tick数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">count</td><td>要获取的Tick数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Tick数据切片指针，调用者需要自行释放 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a4d9d76e994c640ba13c4b8c750aa530f">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02125">2125</a> 行定义.</p>

</div>
</div>
<a id="a07c5e2d22211e6e9975177476e0e2364" name="a07c5e2d22211e6e9975177476e0e2364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c5e2d22211e6e9975177476e0e2364">&#9670;&#160;</a></span>stra_get_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::stra_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前时间接口 </p>
<p>获取当前回测时间</p>
<p>实现ICtaStraCtx接口的方法，用于获取当前的时间 </p><dl class="section return"><dt>返回</dt><dd>返回当前时间，格式为HHMMSS或HHMMSS.mmm</dd></dl>
<p>获取当前回测的时间，格式为HHMM，例如1430表示14点30分 </p><dl class="section return"><dt>返回</dt><dd>当前回测时间 </dd></dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a4d254c9380dd33229861c0f06f354ee3">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02227">2227</a> 行定义.</p>

</div>
</div>
<a id="a653786dcd9ecbb9d4723396668c8dabc" name="a653786dcd9ecbb9d4723396668c8dabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653786dcd9ecbb9d4723396668c8dabc">&#9670;&#160;</a></span>stra_load_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char * CtaMocker::stra_load_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>defVal</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>加载用户数据接口 </p>
<p>加载策略用户自定义数据</p>
<p>实现ICtaStraCtx接口的方法，用于加载策略用户数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据键 </td></tr>
    <tr><td class="paramname">defVal</td><td>默认值，当数据不存在时返回，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回数据值</dd></dl>
<p>从内部缓存中加载策略的用户自定义数据 如果指定键名的数据不存在，则返回默认值 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据键名 </td></tr>
    <tr><td class="paramname">defVal</td><td>默认值，当指定键名的数据不存在时返回，默认为空字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>数据值或默认值 </dd></dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a1e02fc194c971726949d4505f1423798">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02307">2307</a> 行定义.</p>

</div>
</div>
<a id="a1200a5cb925e247e7d7d90127efe2bd2" name="a1200a5cb925e247e7d7d90127efe2bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1200a5cb925e247e7d7d90127efe2bd2">&#9670;&#160;</a></span>stra_log_debug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_log_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录调试日志接口 </p>
<p>记录策略调试日志</p>
<p>实现ICtaStraCtx接口的方法，用于记录策略调试日志 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>记录调试级别的策略日志，用于记录策略运行过程中的详细调试信息 日志将以策略名称为标识记录到日志系统中 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a68271f9d0c5e82f1b431d302f156bcad">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02272">2272</a> 行定义.</p>

</div>
</div>
<a id="a7693915ffc0e5aee6cf7dd9f8f99170c" name="a7693915ffc0e5aee6cf7dd9f8f99170c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7693915ffc0e5aee6cf7dd9f8f99170c">&#9670;&#160;</a></span>stra_log_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_log_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录错误日志接口 </p>
<p>记录策略错误日志</p>
<p>实现ICtaStraCtx接口的方法，用于记录策略错误日志 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>记录错误级别的策略日志，用于记录策略运行过程中的错误信息 日志将以策略名称为标识记录到日志系统中 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a071b1c5a49b98e96423da9de8a0ce612">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02294">2294</a> 行定义.</p>

</div>
</div>
<a id="abb9bfe4ccac679bd6278fa979aeb410d" name="abb9bfe4ccac679bd6278fa979aeb410d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9bfe4ccac679bd6278fa979aeb410d">&#9670;&#160;</a></span>stra_log_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_log_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录信息日志接口 </p>
<p>记录策略信息日志</p>
<p>实现ICtaStraCtx接口的方法，用于记录策略信息日志 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>记录信息级别的策略日志，用于记录策略运行过程中的重要信息 日志将以策略名称为标识记录到日志系统中 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ab86a3f0613c6464c1776c17953356717">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02261">2261</a> 行定义.</p>

</div>
</div>
<a id="aa187f636b44136b97910adc7cc09344b" name="aa187f636b44136b97910adc7cc09344b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa187f636b44136b97910adc7cc09344b">&#9670;&#160;</a></span>stra_log_warn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_log_warn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>记录警告日志接口 </p>
<p>记录策略警告日志</p>
<p>实现ICtaStraCtx接口的方法，用于记录策略警告日志 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息</td></tr>
  </table>
  </dd>
</dl>
<p>记录警告级别的策略日志，用于记录策略运行过程中的警告信息 日志将以策略名称为标识记录到日志系统中 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>日志消息内容 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#a56b099d80e4d9bdd6ee6a804dbb524ba">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02283">2283</a> 行定义.</p>

</div>
</div>
<a id="aa637c47ce66e6982f23cf9810472b870" name="aa637c47ce66e6982f23cf9810472b870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa637c47ce66e6982f23cf9810472b870">&#9670;&#160;</a></span>stra_save_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_save_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>保存用户数据接口 </p>
<p>保存策略用户自定义数据</p>
<p>实现ICtaStraCtx接口的方法，用于保存策略用户数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据键 </td></tr>
    <tr><td class="paramname">val</td><td>数据值</td></tr>
  </table>
  </dd>
</dl>
<p>将策略的用户自定义数据保存到内部缓存中 用户数据以键值对的形式存储，可以在策略重启后通过stra_load_user_data函数加载 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>数据键名 </td></tr>
    <tr><td class="paramname">val</td><td>数据值 </td></tr>
  </table>
  </dd>
</dl>

<p>重载 <a class="el" href="classICtaStraCtx.html#af1b4cdb3917f929bef5e0c9d7d40a5b2">ICtaStraCtx</a> .</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02323">2323</a> 行定义.</p>

</div>
</div>
<a id="a9ae822bae83c859d67a729865e44cef8" name="a9ae822bae83c859d67a729865e44cef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae822bae83c859d67a729865e44cef8">&#9670;&#160;</a></span>stra_set_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_set_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>qty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>userTag</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitprice</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopprice</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>设置仓位接口 </p>
<p>实现ICtaStraCtx接口的方法，用于直接设置指定合约的目标仓位 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">qty</td><td>目标仓位数量，正数表示多头，负数表示空头 </td></tr>
    <tr><td class="paramname">userTag</td><td>用户标记，用于标识交易来源，默认为空字符串 </td></tr>
    <tr><td class="paramname">limitprice</td><td>限价，限定价格成交，默认为0.0（市价单） </td></tr>
    <tr><td class="paramname">stopprice</td><td>止损价，止损价格，默认为0.0（不设置止损） </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ae82ee2f95826e38a79268d7bcde0e8a1">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01785">1785</a> 行定义.</p>

</div>
</div>
<a id="a819e1ff81585820db0c64901f377aac3" name="a819e1ff81585820db0c64901f377aac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819e1ff81585820db0c64901f377aac3">&#9670;&#160;</a></span>stra_sub_bar_events()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_sub_bar_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅K线事件接口 </p>
<p>实现ICtaStraCtx接口的方法，用于订阅指定合约的K线事件 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">period</td><td>K线周期，如"m1"/"m5"/"d1"等 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#a4fe27e3cfc0943f0fa3bd0ffd850be5f">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02168">2168</a> 行定义.</p>

</div>
</div>
<a id="a719a5fd852ce1c57e3e7c49319f4b155" name="a719a5fd852ce1c57e3e7c49319f4b155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719a5fd852ce1c57e3e7c49319f4b155">&#9670;&#160;</a></span>stra_sub_ticks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::stra_sub_ticks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>订阅Tick数据接口 </p>
<p>订阅合约的Tick数据</p>
<p>实现ICtaStraCtx接口的方法，用于订阅指定合约的Tick数据 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码</td></tr>
  </table>
  </dd>
</dl>
<p>策略调用此接口订阅指定合约的Tick数据 订阅后的Tick数据会通过on_tick回调函数传递给策略 主动订阅的Tick会在本地记录，在回调时进行检查 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>合约代码 </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classICtaStraCtx.html#ad7e8b26e86657503a8f8d4567f7107d9">ICtaStraCtx</a>.</p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l02156">2156</a> 行定义.</p>

</div>
</div>
<a id="a914a40e13ed8a98fb684771d1ff12fc9" name="a914a40e13ed8a98fb684771d1ff12fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914a40e13ed8a98fb684771d1ff12fc9">&#9670;&#160;</a></span>update_dyn_profit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CtaMocker::update_dyn_profit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>stdCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>更新动态盈亏 </p>
<p>更新浮动盈亏</p>
<p>根据当前价格更新指定合约的浮动盈亏 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准化合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>当前价格</td></tr>
  </table>
  </dd>
</dl>
<p>根据最新的价格更新指定合约的浮动盈亏和总浮动盈亏 同时更新持仓明细中的最高价、最低价、最大盈利和最大亏损 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdCode</td><td>标准合约代码 </td></tr>
    <tr><td class="paramname">price</td><td>当前最新价格 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a> 第 <a class="el" href="CtaMocker_8cpp_source.html#l01156">1156</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a07fe88edf5e4fa18ebf1afd128b17da1" name="a07fe88edf5e4fa18ebf1afd128b17da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07fe88edf5e4fa18ebf1afd128b17da1">&#9670;&#160;</a></span>_chart_code</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CtaMocker::_chart_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>图表合约代码，用于图表展示的合约 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01047">1047</a> 行定义.</p>

</div>
</div>
<a id="a4bddf67064613a992d5dae146f40a3ee" name="a4bddf67064613a992d5dae146f40a3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bddf67064613a992d5dae146f40a3ee">&#9670;&#160;</a></span>_chart_indice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="classCtaMocker.html#ab39569986e35ad1307b12488e9b94781">ChartIndex</a>&gt; CtaMocker::_chart_indice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>图表指标映射，键为指标名称 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01072">1072</a> 行定义.</p>

</div>
</div>
<a id="a384eb95010a16bcbbb79b52afb0da683" name="a384eb95010a16bcbbb79b52afb0da683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384eb95010a16bcbbb79b52afb0da683">&#9670;&#160;</a></span>_chart_period</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CtaMocker::_chart_period</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>图表周期，用于图表展示的K线周期 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01048">1048</a> 行定义.</p>

</div>
</div>
<a id="a8b8f945dc787fc3da2670f3b9c937788" name="a8b8f945dc787fc3da2670f3b9c937788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8f945dc787fc3da2670f3b9c937788">&#9670;&#160;</a></span>_close_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_close_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>平仓日志流，用于记录平仓操作及其盈亏 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00940">940</a> 行定义.</p>

</div>
</div>
<a id="aa8d1e0d80c4acf5870ae772d7694afd2" name="aa8d1e0d80c4acf5870ae772d7694afd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d1e0d80c4acf5870ae772d7694afd2">&#9670;&#160;</a></span>_cond_calc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gafaa630f2eecc6c68bc508cb484fcd3a3">StdCondVariable</a> CtaMocker::_cond_calc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算条件变量，用于等待和通知计算完成 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01023">1023</a> 行定义.</p>

</div>
</div>
<a id="a2e21661fc57d08ddae277f16c37906b6" name="a2e21661fc57d08ddae277f16c37906b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e21661fc57d08ddae277f16c37906b6">&#9670;&#160;</a></span>_condtions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CtaMocker_8h.html#a4f907939e222c805bb69004f7be6e6c6">CondEntrustMap</a> CtaMocker::_condtions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>条件委托映射，用于管理各个合约的条件委托 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00947">947</a> 行定义.</p>

</div>
</div>
<a id="af59ec7e8021dbaa6cce7a92e197172ab" name="af59ec7e8021dbaa6cce7a92e197172ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59ec7e8021dbaa6cce7a92e197172ab">&#9670;&#160;</a></span>_context_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::_context_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略上下文ID，策略实例的唯一标识符 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00787">787</a> 行定义.</p>

</div>
</div>
<a id="a8b01e991c9a3bdceff260ca3fe03cd59" name="a8b01e991c9a3bdceff260ca3fe03cd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b01e991c9a3bdceff260ca3fe03cd59">&#9670;&#160;</a></span>_cur_bartime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::_cur_bartime</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当前K线时间，格式为HHMMSS </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01038">1038</a> 行定义.</p>

</div>
</div>
<a id="ac5466d8f84a0e8bdef8bd91751ef9f7f" name="ac5466d8f84a0e8bdef8bd91751ef9f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5466d8f84a0e8bdef8bd91751ef9f7f">&#9670;&#160;</a></span>_cur_step</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;uint32_t&gt; CtaMocker::_cur_step</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当前步骤，临时变量，用于控制状态 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01026">1026</a> 行定义.</p>

</div>
</div>
<a id="a154caeae6198f776f95f881d9bd1ad3e" name="a154caeae6198f776f95f881d9bd1ad3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154caeae6198f776f95f881d9bd1ad3e">&#9670;&#160;</a></span>_cur_tdate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::_cur_tdate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>当前交易日，格式为YYYYMMDD </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01037">1037</a> 行定义.</p>

</div>
</div>
<a id="af6ed8ba7b589e116f914792a278dc2b5" name="af6ed8ba7b589e116f914792a278dc2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ed8ba7b589e116f914792a278dc2b5">&#9670;&#160;</a></span>_emit_times</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::_emit_times</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00791">791</a> 行定义.</p>

</div>
</div>
<a id="a047b58be23b1b8e8dab9fb0fd5cd2ec3" name="a047b58be23b1b8e8dab9fb0fd5cd2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b58be23b1b8e8dab9fb0fd5cd2ec3">&#9670;&#160;</a></span>_factory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a67a18d658ae4f719289fdf03fbe9630b">StraFactInfo</a> CtaMocker::_factory</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略工厂信息，管理策略工厂的加载和创建 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01017">1017</a> 行定义.</p>

</div>
</div>
<a id="a061cadab7aec2f857ccc5ea3d8ebf284" name="a061cadab7aec2f857ccc5ea3d8ebf284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061cadab7aec2f857ccc5ea3d8ebf284">&#9670;&#160;</a></span>_fund_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a36bbaf8e935f00f08040d8ce239f1611">StraFundInfo</a> CtaMocker::_fund_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略资金信息，记录策略账户的资金状况 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00983">983</a> 行定义.</p>

</div>
</div>
<a id="ae95c90526aaeeaca9675ee8beb93a6af" name="ae95c90526aaeeaca9675ee8beb93a6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95c90526aaeeaca9675ee8beb93a6af">&#9670;&#160;</a></span>_fund_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_fund_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>资金日志流，用于记录资金变化 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00941">941</a> 行定义.</p>

</div>
</div>
<a id="a404a71dafc0eb023592cf0cdbca61361" name="a404a71dafc0eb023592cf0cdbca61361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a404a71dafc0eb023592cf0cdbca61361">&#9670;&#160;</a></span>_has_hook</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_has_hook</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否有钩子，这是人为控制是否启用钩子 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01024">1024</a> 行定义.</p>

</div>
</div>
<a id="a6118fd8fa36a0d72b3009114696699a4" name="a6118fd8fa36a0d72b3009114696699a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6118fd8fa36a0d72b3009114696699a4">&#9670;&#160;</a></span>_hook_valid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_hook_valid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>钩子是否有效，这是根据是否是异步回测模式而确定钩子是否可用 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01025">1025</a> 行定义.</p>

</div>
</div>
<a id="a3d4fbd4ffc4d8693621d58db7263a0fa" name="a3d4fbd4ffc4d8693621d58db7263a0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4fbd4ffc4d8693621d58db7263a0fa">&#9670;&#160;</a></span>_in_backtest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_in_backtest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否在回测中，标记当前是否处于回测过程中 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01028">1028</a> 行定义.</p>

</div>
</div>
<a id="a4fba06703fe16f7db1c3611ed276dfbb" name="a4fba06703fe16f7db1c3611ed276dfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fba06703fe16f7db1c3611ed276dfbb">&#9670;&#160;</a></span>_index_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_index_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>指标日志流，用于记录策略指标数据 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00944">944</a> 行定义.</p>

</div>
</div>
<a id="af50eeace4a5362845c3b6260772d0a62" name="af50eeace4a5362845c3b6260772d0a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50eeace4a5362845c3b6260772d0a62">&#9670;&#160;</a></span>_is_in_schedule</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_is_in_schedule</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>调度标记 </p>
<p>用于标记当前是否处于自动调度中 是否在自动调度中 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00953">953</a> 行定义.</p>

</div>
</div>
<a id="af66f37a56d7c22ad3eb20e7dcb4ec567" name="af66f37a56d7c22ad3eb20e7dcb4ec567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66f37a56d7c22ad3eb20e7dcb4ec567">&#9670;&#160;</a></span>_kline_tags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a0766982fe9521f3ec9afafd83df7b7f8">KlineTags</a> CtaMocker::_kline_tags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00824">824</a> 行定义.</p>

</div>
</div>
<a id="acd0997ceb8e4ee04c8d0210511f27c52" name="acd0997ceb8e4ee04c8d0210511f27c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0997ceb8e4ee04c8d0210511f27c52">&#9670;&#160;</a></span>_last_cond_min</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CtaMocker::_last_cond_min</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>最近条件检查时间，以分钟为单位 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01039">1039</a> 行定义.</p>

</div>
</div>
<a id="ad82b4f5ae4a71d3888aebff7100c9739" name="ad82b4f5ae4a71d3888aebff7100c9739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82b4f5ae4a71d3888aebff7100c9739">&#9670;&#160;</a></span>_main_code</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CtaMocker::_main_code</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>主要合约代码 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00800">800</a> 行定义.</p>

</div>
</div>
<a id="a2be2e0a10ba8d123b4269fca90c3c36e" name="a2be2e0a10ba8d123b4269fca90c3c36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be2e0a10ba8d123b4269fca90c3c36e">&#9670;&#160;</a></span>_main_key</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CtaMocker::_main_key</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>主要合约的唯一键，由合约代码和周期组成 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00798">798</a> 行定义.</p>

</div>
</div>
<a id="aa5d823ff9e5164b94082df481c4665ab" name="aa5d823ff9e5164b94082df481c4665ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d823ff9e5164b94082df481c4665ab">&#9670;&#160;</a></span>_main_period</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string CtaMocker::_main_period</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>主要周期 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00801">801</a> 行定义.</p>

</div>
</div>
<a id="a7a0a513033492e94a0031bd831ca408a" name="a7a0a513033492e94a0031bd831ca408a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0a513033492e94a0031bd831ca408a">&#9670;&#160;</a></span>_mark_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_mark_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>标记日志流，用于记录特定标记点 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00945">945</a> 行定义.</p>

</div>
</div>
<a id="ae3accace2c3491e8fbe8e43c9a169861" name="ae3accace2c3491e8fbe8e43c9a169861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3accace2c3491e8fbe8e43c9a169861">&#9670;&#160;</a></span>_mtx_calc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MutexUtils.html#gaff888cdcc14f5ebb7a1a9c9f7b52846f">StdUniqueMutex</a> CtaMocker::_mtx_calc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算锁，用于同步策略计算 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01022">1022</a> 行定义.</p>

</div>
</div>
<a id="a85e6cefe59a67ad0366ce9f0a85b5296" name="a85e6cefe59a67ad0366ce9f0a85b5296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e6cefe59a67ad0366ce9f0a85b5296">&#9670;&#160;</a></span>_notifier</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventNotifier.html">EventNotifier</a>* CtaMocker::_notifier</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>事件通知器指针，用于发送事件通知 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01020">1020</a> 行定义.</p>

</div>
</div>
<a id="acf3583b1368ac02b33b81fcf6829abe7" name="acf3583b1368ac02b33b81fcf6829abe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3583b1368ac02b33b81fcf6829abe7">&#9670;&#160;</a></span>_persist_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_persist_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持久化标记 </p>
<p>标记是否需要对回测结果进行持久化存储 是否对回测结果持久化 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01035">1035</a> 行定义.</p>

</div>
</div>
<a id="aa67399c60b1479257ec032c7adaf4bc0" name="aa67399c60b1479257ec032c7adaf4bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67399c60b1479257ec032c7adaf4bc0">&#9670;&#160;</a></span>_pos_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_pos_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>持仓日志流，用于记录持仓变化 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00943">943</a> 行定义.</p>

</div>
</div>
<a id="ad7f48deb3ba64b5e6e2ffc4ea79f1ead" name="ad7f48deb3ba64b5e6e2ffc4ea79f1ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f48deb3ba64b5e6e2ffc4ea79f1ead">&#9670;&#160;</a></span>_pos_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a4c333945310f2dea8d646e176a7943f8">PositionMap</a> CtaMocker::_pos_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00903">903</a> 行定义.</p>

</div>
</div>
<a id="a7a664df41d933e8653f193e3a1f5f195" name="a7a664df41d933e8653f193e3a1f5f195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a664df41d933e8653f193e3a1f5f195">&#9670;&#160;</a></span>_price_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#ac578f5d7d25d9854dd58cde8aad11078">PriceMap</a> CtaMocker::_price_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00831">831</a> 行定义.</p>

</div>
</div>
<a id="afd947fedd7280b658c9cc18bd968c3f4" name="afd947fedd7280b658c9cc18bd968c3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd947fedd7280b658c9cc18bd968c3f4">&#9670;&#160;</a></span>_ratio_slippage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_ratio_slippage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否比例滑点，标记滑点是固定点数还是按比例计算 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00794">794</a> 行定义.</p>

</div>
</div>
<a id="a48c583c09c23f47248ae0ddef73b486a" name="a48c583c09c23f47248ae0ddef73b486a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c583c09c23f47248ae0ddef73b486a">&#9670;&#160;</a></span>_replayer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHisDataReplayer.html">HisDataReplayer</a>* CtaMocker::_replayer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>历史数据回放器，用于提供回测所需的历史数据 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00788">788</a> 行定义.</p>

</div>
</div>
<a id="a27e04fd161ad84e22623fb4fa6b1c58c" name="a27e04fd161ad84e22623fb4fa6b1c58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e04fd161ad84e22623fb4fa6b1c58c">&#9670;&#160;</a></span>_schedule_times</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CtaMocker::_schedule_times</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>调度次数，记录策略被调度的次数 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00796">796</a> 行定义.</p>

</div>
</div>
<a id="a296978ec7961baf0e4d31700fa1fdc78" name="a296978ec7961baf0e4d31700fa1fdc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296978ec7961baf0e4d31700fa1fdc78">&#9670;&#160;</a></span>_sig_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_sig_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>信号日志流，用于记录策略产生的信号 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00942">942</a> 行定义.</p>

</div>
</div>
<a id="a464f1a466ed5e94110e8476eedc0913d" name="a464f1a466ed5e94110e8476eedc0913d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464f1a466ed5e94110e8476eedc0913d">&#9670;&#160;</a></span>_sig_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a1893cd4399b7a826330d8410115732a6">SignalMap</a> CtaMocker::_sig_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00937">937</a> 行定义.</p>

</div>
</div>
<a id="a9a4de9106ac4cbf84d61af7a4f8efbb6" name="a9a4de9106ac4cbf84d61af7a4f8efbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4de9106ac4cbf84d61af7a4f8efbb6">&#9670;&#160;</a></span>_slippage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t CtaMocker::_slippage</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>成交滑点，如果是比例滑点，则为万分比 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00793">793</a> 行定义.</p>

</div>
</div>
<a id="a49e597fe25efe6ab6035c17d8a8c0660" name="a49e597fe25efe6ab6035c17d8a8c0660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e597fe25efe6ab6035c17d8a8c0660">&#9670;&#160;</a></span>_strategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaStrategy.html">CtaStrategy</a>* CtaMocker::_strategy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>策略对象指针，指向实际的CTA策略实例 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01019">1019</a> 行定义.</p>

</div>
</div>
<a id="a7beacb93ceab5ccefdd29015e0ad30d9" name="a7beacb93ceab5ccefdd29015e0ad30d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7beacb93ceab5ccefdd29015e0ad30d9">&#9670;&#160;</a></span>_tick_subs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwt__hashset.html">wt_hashset</a>&lt;std::string&gt; CtaMocker::_tick_subs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick订阅列表 </p>
<p>存储已订阅Tick数据的合约代码集合 Tick订阅列表，存储已订阅的合约代码 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01045">1045</a> 行定义.</p>

</div>
</div>
<a id="a3c5701fde49703aba706fa8a07441162" name="a3c5701fde49703aba706fa8a07441162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5701fde49703aba706fa8a07441162">&#9670;&#160;</a></span>_ticks</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a9227a7402c399bd1e8072d2d56dbc751">TickCache</a> CtaMocker::_ticks</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick缓存，存储最新的Tick数据 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01079">1079</a> 行定义.</p>

</div>
</div>
<a id="a000079dd98dbd539a3f7929dc27c8fa1" name="a000079dd98dbd539a3f7929dc27c8fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000079dd98dbd539a3f7929dc27c8fa1">&#9670;&#160;</a></span>_total_calc_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t CtaMocker::_total_calc_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00790">790</a> 行定义.</p>

</div>
</div>
<a id="ac007131bf6cb32eb88056b6ab952803f" name="ac007131bf6cb32eb88056b6ab952803f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac007131bf6cb32eb88056b6ab952803f">&#9670;&#160;</a></span>_total_closeprofit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double CtaMocker::_total_closeprofit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>总平仓盈亏，记录所有平仓交易的盈亏总和 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00904">904</a> 行定义.</p>

</div>
</div>
<a id="a42e4da25a9a9b94ee87f205dcbc0bf73" name="a42e4da25a9a9b94ee87f205dcbc0bf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e4da25a9a9b94ee87f205dcbc0bf73">&#9670;&#160;</a></span>_trade_logs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stringstream CtaMocker::_trade_logs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>交易日志流，用于记录所有交易操作 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00939">939</a> 行定义.</p>

</div>
</div>
<a id="a9d76dbce2c43b3a0c86c24031beafdba" name="a9d76dbce2c43b3a0c86c24031beafdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d76dbce2c43b3a0c86c24031beafdba">&#9670;&#160;</a></span>_ud_modified</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_ud_modified</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>用户数据是否已修改，用于标记是否需要持久化 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00961">961</a> 行定义.</p>

</div>
</div>
<a id="a991bba9de2eb616e9951f22f65ea1d70" name="a991bba9de2eb616e9951f22f65ea1d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991bba9de2eb616e9951f22f65ea1d70">&#9670;&#160;</a></span>_user_datas</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCtaMocker.html#a3d7ef58a183d7574fc9f4ddda1e06b64">StringHashMap</a> CtaMocker::_user_datas</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>用户数据映射，键值对形式存储 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l00960">960</a> 行定义.</p>

</div>
</div>
<a id="a7c812953d3e41b46b1656c81b216db60" name="a7c812953d3e41b46b1656c81b216db60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c812953d3e41b46b1656c81b216db60">&#9670;&#160;</a></span>_wait_calc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CtaMocker::_wait_calc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>是否等待计算，标记是否需要等待策略计算完成 </p>

<p class="definition">在文件 <a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a> 第 <a class="el" href="CtaMocker_8h_source.html#l01029">1029</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/WtBtCore/<a class="el" href="CtaMocker_8h_source.html">CtaMocker.h</a></li>
<li>src/WtBtCore/<a class="el" href="CtaMocker_8cpp_source.html">CtaMocker.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classCtaMocker.html">CtaMocker</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
