<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WonderTrader: StrUtil类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WonderTrader<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">高性能量化交易平台</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classStrUtil.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="classStrUtil-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">StrUtil类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>字符串工具类  
 <a href="classStrUtil.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a0ae7e6b1a976327b4ea1634562e19043" id="r_a0ae7e6b1a976327b4ea1634562e19043"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a0ae7e6b1a976327b4ea1634562e19043">trim</a> (std::string &amp;str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *delims=&quot; \t\r&quot;, bool <a class="el" href="classStrUtil.html#a7eef9414cadd312226abd8adab225654">left</a>=true, bool <a class="el" href="classStrUtil.html#a2b04816905d2e79def3cda0435d8a46c">right</a>=true)</td></tr>
<tr class="memdesc:a0ae7e6b1a976327b4ea1634562e19043"><td class="mdescLeft">&#160;</td><td class="mdescRight">修剪字符串两端的指定字符  <br /></td></tr>
<tr class="separator:a0ae7e6b1a976327b4ea1634562e19043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3e4300984ddfc0777985b4c4f1b7f8" id="r_afa3e4300984ddfc0777985b4c4f1b7f8"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#afa3e4300984ddfc0777985b4c4f1b7f8">trim</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *delims=&quot; \t\r&quot;, bool <a class="el" href="classStrUtil.html#a7eef9414cadd312226abd8adab225654">left</a>=true, bool <a class="el" href="classStrUtil.html#a2b04816905d2e79def3cda0435d8a46c">right</a>=true)</td></tr>
<tr class="memdesc:afa3e4300984ddfc0777985b4c4f1b7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">修剪字符串两端的指定字符  <br /></td></tr>
<tr class="separator:afa3e4300984ddfc0777985b4c4f1b7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6af0027cb7fe0021e97e64c9f83e8b" id="r_a3e6af0027cb7fe0021e97e64c9f83e8b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a3e6af0027cb7fe0021e97e64c9f83e8b">trimAllSpace</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a3e6af0027cb7fe0021e97e64c9f83e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">去除字符串中的所有空格字符  <br /></td></tr>
<tr class="separator:a3e6af0027cb7fe0021e97e64c9f83e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af777c019bd2250d88535e1223720af98" id="r_af777c019bd2250d88535e1223720af98"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#af777c019bd2250d88535e1223720af98">findFirst</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str, char ch)</td></tr>
<tr class="memdesc:af777c019bd2250d88535e1223720af98"><td class="mdescLeft">&#160;</td><td class="mdescRight">查找字符在字符串中的第一次出现位置  <br /></td></tr>
<tr class="separator:af777c019bd2250d88535e1223720af98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2729c13263c7641c25c09a9aafa56088" id="r_a2729c13263c7641c25c09a9aafa56088"><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a2729c13263c7641c25c09a9aafa56088">findLast</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str, char ch)</td></tr>
<tr class="memdesc:a2729c13263c7641c25c09a9aafa56088"><td class="mdescLeft">&#160;</td><td class="mdescRight">查找字符在字符串中的最后一次出现位置  <br /></td></tr>
<tr class="separator:a2729c13263c7641c25c09a9aafa56088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f8887aed021ea6dafe93ce1f2b67a0" id="r_ab7f8887aed021ea6dafe93ce1f2b67a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="StrUtil_8hpp.html#ab8e1ede88e2ff1c3b448334e6cbd3533">StringVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#ab7f8887aed021ea6dafe93ce1f2b67a0">split</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;delims=&quot;\t\n &quot;, unsigned int maxSplits=0)</td></tr>
<tr class="memdesc:ab7f8887aed021ea6dafe93ce1f2b67a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">分割字符串为多个字符串并返回字符串数组  <br /></td></tr>
<tr class="separator:ab7f8887aed021ea6dafe93ce1f2b67a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b4f6f2fdcd36b74a4139148b2ab2f5" id="r_ac4b4f6f2fdcd36b74a4139148b2ab2f5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#ac4b4f6f2fdcd36b74a4139148b2ab2f5">split</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;str, <a class="el" href="StrUtil_8hpp.html#ab8e1ede88e2ff1c3b448334e6cbd3533">StringVector</a> &amp;ret, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;delims=&quot;\t\n &quot;, unsigned int maxSplits=0)</td></tr>
<tr class="memdesc:ac4b4f6f2fdcd36b74a4139148b2ab2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">分割字符串为多个字符串，并将结果存储到指定的数组中  <br /></td></tr>
<tr class="separator:ac4b4f6f2fdcd36b74a4139148b2ab2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72223302a53d43f3e758c9c555e03ccb" id="r_a72223302a53d43f3e758c9c555e03ccb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a72223302a53d43f3e758c9c555e03ccb">toLowerCase</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a72223302a53d43f3e758c9c555e03ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串转换为小写  <br /></td></tr>
<tr class="separator:a72223302a53d43f3e758c9c555e03ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6705c49c050069e507cfb60a88c7858e" id="r_a6705c49c050069e507cfb60a88c7858e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a6705c49c050069e507cfb60a88c7858e">toUpperCase</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a6705c49c050069e507cfb60a88c7858e"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串转换为大写  <br /></td></tr>
<tr class="separator:a6705c49c050069e507cfb60a88c7858e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e89ecb432b1e513690dd980cac20b37" id="r_a2e89ecb432b1e513690dd980cac20b37"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a2e89ecb432b1e513690dd980cac20b37">makeLowerCase</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str)</td></tr>
<tr class="memdesc:a2e89ecb432b1e513690dd980cac20b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串转换为小写并返回新的字符串  <br /></td></tr>
<tr class="separator:a2e89ecb432b1e513690dd980cac20b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6afa7a48cbf44595006b451b83aa0a" id="r_a2c6afa7a48cbf44595006b451b83aa0a"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a2c6afa7a48cbf44595006b451b83aa0a">makeUpperCase</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str)</td></tr>
<tr class="memdesc:a2c6afa7a48cbf44595006b451b83aa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串转换为大写并返回新的字符串  <br /></td></tr>
<tr class="separator:a2c6afa7a48cbf44595006b451b83aa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380dabf72c8be2890af8821963e82a4c" id="r_a380dabf72c8be2890af8821963e82a4c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a380dabf72c8be2890af8821963e82a4c">startsWith</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *pattern, bool ignoreCase=true)</td></tr>
<tr class="memdesc:a380dabf72c8be2890af8821963e82a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查字符串是否以指定的模式开头  <br /></td></tr>
<tr class="separator:a380dabf72c8be2890af8821963e82a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0fba20dc8f318eb6bcffde9d02718b" id="r_a1a0fba20dc8f318eb6bcffde9d02718b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a1a0fba20dc8f318eb6bcffde9d02718b">endsWith</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *pattern, bool ignoreCase=true)</td></tr>
<tr class="memdesc:a1a0fba20dc8f318eb6bcffde9d02718b"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查字符串是否以指定的模式结尾  <br /></td></tr>
<tr class="separator:a1a0fba20dc8f318eb6bcffde9d02718b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d993d2350e32ceedca3811eee1370db" id="r_a6d993d2350e32ceedca3811eee1370db"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a6d993d2350e32ceedca3811eee1370db">standardisePath</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;<a class="el" href="API_2AtpTradeApi_2demo_2simple__demo_2main_8cpp.html#a347fd65fce8f2409e533eb1badd110e0">init</a>, bool bIsDir=true)</td></tr>
<tr class="memdesc:a6d993d2350e32ceedca3811eee1370db"><td class="mdescLeft">&#160;</td><td class="mdescRight">标准化路径格式 - 仅使用正斜杠，目录以斜杠结尾  <br /></td></tr>
<tr class="separator:a6d993d2350e32ceedca3811eee1370db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbebec612f28d6e409287447e89e706" id="r_a2dbebec612f28d6e409287447e89e706"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a2dbebec612f28d6e409287447e89e706">splitFilename</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;qualifiedName, std::string &amp;outBasename, std::string &amp;outPath)</td></tr>
<tr class="memdesc:a2dbebec612f28d6e409287447e89e706"><td class="mdescLeft">&#160;</td><td class="mdescRight">将完整的文件路径分割为基础文件名和路径  <br /></td></tr>
<tr class="separator:a2dbebec612f28d6e409287447e89e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78428170bc1ca57d0e98fb63c4b1b792" id="r_a78428170bc1ca57d0e98fb63c4b1b792"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a78428170bc1ca57d0e98fb63c4b1b792">match</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;pattern, bool caseSensitive=true)</td></tr>
<tr class="memdesc:a78428170bc1ca57d0e98fb63c4b1b792"><td class="mdescLeft">&#160;</td><td class="mdescRight">简单的模式匹配函数，支持通配符  <br /></td></tr>
<tr class="separator:a78428170bc1ca57d0e98fb63c4b1b792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff7736eb0d01c5d3937630395435363" id="r_a5ff7736eb0d01c5d3937630395435363"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a5ff7736eb0d01c5d3937630395435363">BLANK</a> ()</td></tr>
<tr class="memdesc:a5ff7736eb0d01c5d3937630395435363"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回一个空的字符串常量  <br /></td></tr>
<tr class="separator:a5ff7736eb0d01c5d3937630395435363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e29501b4702101a2e7780f5c0c989b" id="r_a26e29501b4702101a2e7780f5c0c989b"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a26e29501b4702101a2e7780f5c0c989b">printf</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *pszFormat,...)</td></tr>
<tr class="memdesc:a26e29501b4702101a2e7780f5c0c989b"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化字符串，类似于 C 语言的 printf 函数  <br /></td></tr>
<tr class="separator:a26e29501b4702101a2e7780f5c0c989b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1426031adbda164400501f0f1cd6a6c0" id="r_a1426031adbda164400501f0f1cd6a6c0"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a1426031adbda164400501f0f1cd6a6c0">printf2</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *pszFormat,...)</td></tr>
<tr class="memdesc:a1426031adbda164400501f0f1cd6a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化字符串的另一个实现，类似于 C 语言的 printf 函数  <br /></td></tr>
<tr class="separator:a1426031adbda164400501f0f1cd6a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e56054659efef330790066da65ab4d2" id="r_a1e56054659efef330790066da65ab4d2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a1e56054659efef330790066da65ab4d2">printf2</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *pszFormat, va_list argptr)</td></tr>
<tr class="memdesc:a1e56054659efef330790066da65ab4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化字符串的底层实现，接受va_list参数  <br /></td></tr>
<tr class="separator:a1e56054659efef330790066da65ab4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0eb9a40552b74095dfe4668d001631" id="r_a6f0eb9a40552b74095dfe4668d001631"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a6f0eb9a40552b74095dfe4668d001631">extend</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *str, uint32_t length)</td></tr>
<tr class="memdesc:a6f0eb9a40552b74095dfe4668d001631"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串通过在两端添加空格扩展到指定长度  <br /></td></tr>
<tr class="separator:a6f0eb9a40552b74095dfe4668d001631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddde59ca1498f4de0c550167572c321" id="r_a1ddde59ca1498f4de0c550167572c321"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a1ddde59ca1498f4de0c550167572c321">printf</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *pszFormat, va_list argptr)</td></tr>
<tr class="memdesc:a1ddde59ca1498f4de0c550167572c321"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化字符串的内部实现，接受va_list参数  <br /></td></tr>
<tr class="separator:a1ddde59ca1498f4de0c550167572c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b04816905d2e79def3cda0435d8a46c" id="r_a2b04816905d2e79def3cda0435d8a46c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a2b04816905d2e79def3cda0435d8a46c">right</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;<a class="el" href="zbuff_8h.html#a49286b6a0dd3728961b8ff1f1730a982">src</a>, size_t nCount)</td></tr>
<tr class="memdesc:a2b04816905d2e79def3cda0435d8a46c"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取字符串右边的N个字符  <br /></td></tr>
<tr class="separator:a2b04816905d2e79def3cda0435d8a46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eef9414cadd312226abd8adab225654" id="r_a7eef9414cadd312226abd8adab225654"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#a7eef9414cadd312226abd8adab225654">left</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;<a class="el" href="zbuff_8h.html#a49286b6a0dd3728961b8ff1f1730a982">src</a>, size_t nCount)</td></tr>
<tr class="memdesc:a7eef9414cadd312226abd8adab225654"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取字符串左边的N个字符  <br /></td></tr>
<tr class="separator:a7eef9414cadd312226abd8adab225654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fe67df7e47eb307833990b8cf3862b" id="r_ae0fe67df7e47eb307833990b8cf3862b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#ae0fe67df7e47eb307833990b8cf3862b">charCount</a> (<a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;<a class="el" href="zbuff_8h.html#a49286b6a0dd3728961b8ff1f1730a982">src</a>, char ch)</td></tr>
<tr class="memdesc:ae0fe67df7e47eb307833990b8cf3862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">计算字符串中指定字符的出现次数  <br /></td></tr>
<tr class="separator:ae0fe67df7e47eb307833990b8cf3862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53553343de2148ca9b5049cedb257b5" id="r_ad53553343de2148ca9b5049cedb257b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStrUtil.html#ad53553343de2148ca9b5049cedb257b5">replace</a> (std::string &amp;str, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *<a class="el" href="zbuff_8h.html#a49286b6a0dd3728961b8ff1f1730a982">src</a>, <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *des)</td></tr>
<tr class="memdesc:ad53553343de2148ca9b5049cedb257b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">替换字符串中的所有指定子字符串  <br /></td></tr>
<tr class="separator:ad53553343de2148ca9b5049cedb257b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>字符串工具类 </p>
<p>提供各种字符串相关的处理函数，包括但不限于：字符串修剪、分割、大小写转换、匹配等功能 </p>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00036">36</a> 行定义.</p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="a5ff7736eb0d01c5d3937630395435363" name="a5ff7736eb0d01c5d3937630395435363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff7736eb0d01c5d3937630395435363">&#9670;&#160;</a></span>BLANK()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string StrUtil::BLANK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>返回一个空的字符串常量 </p>
<dl class="section return"><dt>返回</dt><dd>const std::string 空字符串常量，当需要返回引用而本地变量不存在时非常有用 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00480">480</a> 行定义.</p>

</div>
</div>
<a id="ae0fe67df7e47eb307833990b8cf3862b" name="ae0fe67df7e47eb307833990b8cf3862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fe67df7e47eb307833990b8cf3862b">&#9670;&#160;</a></span>charCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t StrUtil::charCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>计算字符串中指定字符的出现次数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>要搜索的字符串 </td></tr>
    <tr><td class="paramname">ch</td><td>要计数的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>size_t 指定字符在字符串中的出现次数 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00662">662</a> 行定义.</p>

</div>
</div>
<a id="a1a0fba20dc8f318eb6bcffde9d02718b" name="a1a0fba20dc8f318eb6bcffde9d02718b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0fba20dc8f318eb6bcffde9d02718b">&#9670;&#160;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool StrUtil::endsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查字符串是否以指定的模式结尾 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要检查的字符串 </td></tr>
    <tr><td class="paramname">pattern</td><td>要匹配的模式字符串 </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>是否忽略大小写，默认为true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 如果字符串以指定模式结尾则返回true，否则返回false </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00330">330</a> 行定义.</p>

</div>
</div>
<a id="a6f0eb9a40552b74095dfe4668d001631" name="a6f0eb9a40552b74095dfe4668d001631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0eb9a40552b74095dfe4668d001631">&#9670;&#160;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将字符串通过在两端添加空格扩展到指定长度 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要扩展的字符串 </td></tr>
    <tr><td class="paramname">length</td><td>指定的目标长度 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 扩展后的字符串，如果原字符串长度已经超过指定长度，则返回原字符串 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>扩展时会尽量平均地在字符串两端添加空格 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00565">565</a> 行定义.</p>

</div>
</div>
<a id="af777c019bd2250d88535e1223720af98" name="af777c019bd2250d88535e1223720af98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af777c019bd2250d88535e1223720af98">&#9670;&#160;</a></span>findFirst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t StrUtil::findFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>查找字符在字符串中的第一次出现位置 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要搜索的字符串 </td></tr>
    <tr><td class="paramname">ch</td><td>要查找的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::size_t 字符首次出现的位置索引，如果未找到则返回std::string::npos </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00105">105</a> 行定义.</p>

</div>
</div>
<a id="a2729c13263c7641c25c09a9aafa56088" name="a2729c13263c7641c25c09a9aafa56088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2729c13263c7641c25c09a9aafa56088">&#9670;&#160;</a></span>findLast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t StrUtil::findLast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>查找字符在字符串中的最后一次出现位置 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要搜索的字符串 </td></tr>
    <tr><td class="paramname">ch</td><td>要查找的字符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::size_t 字符最后一次出现的位置索引，如果未找到则返回std::string::npos </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00129">129</a> 行定义.</p>

</div>
</div>
<a id="a7eef9414cadd312226abd8adab225654" name="a7eef9414cadd312226abd8adab225654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eef9414cadd312226abd8adab225654">&#9670;&#160;</a></span>left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::left </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取字符串左边的N个字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>输入字符串 </td></tr>
    <tr><td class="paramname">nCount</td><td>要获取的字符数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 提取的字符串，如果要提取的字符数量超过字符串长度，则返回原字符串 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00650">650</a> 行定义.</p>

</div>
</div>
<a id="a2e89ecb432b1e513690dd980cac20b37" name="a2e89ecb432b1e513690dd980cac20b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e89ecb432b1e513690dd980cac20b37">&#9670;&#160;</a></span>makeLowerCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::makeLowerCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将字符串转换为小写并返回新的字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要转换的字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 转换后的字符串副本 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00265">265</a> 行定义.</p>

</div>
</div>
<a id="a2c6afa7a48cbf44595006b451b83aa0a" name="a2c6afa7a48cbf44595006b451b83aa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6afa7a48cbf44595006b451b83aa0a">&#9670;&#160;</a></span>makeUpperCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::makeUpperCase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将字符串转换为大写并返回新的字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要转换的字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 转换后的字符串副本 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00282">282</a> 行定义.</p>

</div>
</div>
<a id="a78428170bc1ca57d0e98fb63c4b1b792" name="a78428170bc1ca57d0e98fb63c4b1b792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78428170bc1ca57d0e98fb63c4b1b792">&#9670;&#160;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool StrUtil::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>caseSensitive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>简单的模式匹配函数，支持通配符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要测试的字符串 </td></tr>
    <tr><td class="paramname">pattern</td><td>要匹配的模式，可以包含简单的'*'通配符 </td></tr>
    <tr><td class="paramname">caseSensitive</td><td>是否区分大小写，默认为true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 如果字符串与模式匹配则返回true，否则返回false </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00407">407</a> 行定义.</p>

</div>
</div>
<a id="a1ddde59ca1498f4de0c550167572c321" name="a1ddde59ca1498f4de0c550167572c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddde59ca1498f4de0c550167572c321">&#9670;&#160;</a></span>printf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>argptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>格式化字符串的内部实现，接受va_list参数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFormat</td><td>格式化字符串，包含格式化控制符 </td></tr>
    <tr><td class="paramname">argptr</td><td>已初始化的可变参数列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 格式化后的字符串 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>这是第一个 printf 函数的内部实现，实现类似 C 语言格式化字符串的功能 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00594">594</a> 行定义.</p>

</div>
</div>
<a id="a26e29501b4702101a2e7780f5c0c989b" name="a26e29501b4702101a2e7780f5c0c989b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e29501b4702101a2e7780f5c0c989b">&#9670;&#160;</a></span>printf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>格式化字符串，类似于 C 语言的 printf 函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFormat</td><td>格式化字符串，包含格式化控制符 </td></tr>
    <tr><td class="paramname">...</td><td>可变参数列表，对应格式化字符串中的控制符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 格式化后的字符串 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>std::string 没有类似 CString 的 Format 函数，因此自行实现 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00494">494</a> 行定义.</p>

</div>
</div>
<a id="a1e56054659efef330790066da65ab4d2" name="a1e56054659efef330790066da65ab4d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e56054659efef330790066da65ab4d2">&#9670;&#160;</a></span>printf2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::printf2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>argptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>格式化字符串的底层实现，接受va_list参数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFormat</td><td>格式化字符串，包含格式化控制符 </td></tr>
    <tr><td class="paramname">argptr</td><td>已初始化的可变参数列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 格式化后的字符串 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>这是C语言风格的可变参数字符串格式化的内部实现 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00528">528</a> 行定义.</p>

</div>
</div>
<a id="a1426031adbda164400501f0f1cd6a6c0" name="a1426031adbda164400501f0f1cd6a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1426031adbda164400501f0f1cd6a6c0">&#9670;&#160;</a></span>printf2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::printf2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>pszFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>格式化字符串的另一个实现，类似于 C 语言的 printf 函数 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">pszFormat</td><td>格式化字符串，包含格式化控制符 </td></tr>
    <tr><td class="paramname">...</td><td>可变参数列表，对应格式化字符串中的控制符 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 格式化后的字符串 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>这是另一种格式化字符串的实现方式，提供多样化的格式化选项 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00511">511</a> 行定义.</p>

</div>
</div>
<a id="ad53553343de2148ca9b5049cedb257b5" name="ad53553343de2148ca9b5049cedb257b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53553343de2148ca9b5049cedb257b5">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::replace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>des</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>替换字符串中的所有指定子字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要处理的字符串引用，替换完成后会直接修改原字符串 </td></tr>
    <tr><td class="paramname">src</td><td>要替换的目标子字符串 </td></tr>
    <tr><td class="paramname">des</td><td>替换后的新字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00679">679</a> 行定义.</p>

</div>
</div>
<a id="a2b04816905d2e79def3cda0435d8a46c" name="a2b04816905d2e79def3cda0435d8a46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b04816905d2e79def3cda0435d8a46c">&#9670;&#160;</a></span>right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取字符串右边的N个字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>输入字符串 </td></tr>
    <tr><td class="paramname">nCount</td><td>要获取的字符数量 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 提取的字符串，如果要提取的字符数量大于字符串长度，则返回空字符串 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00636">636</a> 行定义.</p>

</div>
</div>
<a id="ab7f8887aed021ea6dafe93ce1f2b67a0" name="ab7f8887aed021ea6dafe93ce1f2b67a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f8887aed021ea6dafe93ce1f2b67a0">&#9670;&#160;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="StrUtil_8hpp.html#ab8e1ede88e2ff1c3b448334e6cbd3533">StringVector</a> StrUtil::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;\t\n&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxSplits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>分割字符串为多个字符串并返回字符串数组 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要分割的字符串 </td></tr>
    <tr><td class="paramname">delims</td><td>分割符列表，默认为制表符、换行和空格 </td></tr>
    <tr><td class="paramname">maxSplits</td><td>最大分割数量（0表示不限制）。如果设置为大于0的值，则分割过程将在分割达到这个数量后停止（从左到右） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>StringVector 分割后的字符串数组 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00150">150</a> 行定义.</p>

</div>
</div>
<a id="ac4b4f6f2fdcd36b74a4139148b2ab2f5" name="ac4b4f6f2fdcd36b74a4139148b2ab2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b4f6f2fdcd36b74a4139148b2ab2f5">&#9670;&#160;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="StrUtil_8hpp.html#ab8e1ede88e2ff1c3b448334e6cbd3533">StringVector</a> &amp;&#160;</td>
          <td class="paramname"><em>ret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;\t\n&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxSplits</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>分割字符串为多个字符串，并将结果存储到指定的数组中 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要分割的字符串 </td></tr>
    <tr><td class="paramname">ret</td><td>存储分割结果的字符串数组引用 </td></tr>
    <tr><td class="paramname">delims</td><td>分割符列表，默认为制表符、换行和空格 </td></tr>
    <tr><td class="paramname">maxSplits</td><td>最大分割数量（0表示不限制）。如果设置为大于0的值，则分割过程将在分割达到这个数量后停止（从左到右） </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00195">195</a> 行定义.</p>

</div>
</div>
<a id="a2dbebec612f28d6e409287447e89e706" name="a2dbebec612f28d6e409287447e89e706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbebec612f28d6e409287447e89e706">&#9670;&#160;</a></span>splitFilename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::splitFilename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>qualifiedName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>outBasename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>outPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将完整的文件路径分割为基础文件名和路径 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">qualifiedName</td><td>完整的文件路径 </td></tr>
    <tr><td class="paramname">outBasename</td><td>输出参数，用于存储提取出的文件名 </td></tr>
    <tr><td class="paramname">outPath</td><td>输出参数，用于存储提取出的路径 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>路径会按照standardisePath方法的规则进行标准化，使用正斜杠 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00379">379</a> 行定义.</p>

</div>
</div>
<a id="a6d993d2350e32ceedca3811eee1370db" name="a6d993d2350e32ceedca3811eee1370db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d993d2350e32ceedca3811eee1370db">&#9670;&#160;</a></span>standardisePath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::standardisePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsDir</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>标准化路径格式 - 仅使用正斜杠，目录以斜杠结尾 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>要标准化的原始路径 </td></tr>
    <tr><td class="paramname">bIsDir</td><td>是否为目录路径，默认为true。如果为true，则确保路径以斜杠结尾 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 标准化后的路径 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00360">360</a> 行定义.</p>

</div>
</div>
<a id="a380dabf72c8be2890af8821963e82a4c" name="a380dabf72c8be2890af8821963e82a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380dabf72c8be2890af8821963e82a4c">&#9670;&#160;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool StrUtil::startsWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreCase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>检查字符串是否以指定的模式开头 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要检查的字符串 </td></tr>
    <tr><td class="paramname">pattern</td><td>要匹配的模式字符串 </td></tr>
    <tr><td class="paramname">ignoreCase</td><td>是否忽略大小写，默认为true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>bool 如果字符串以指定模式开头则返回true，否则返回false </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00301">301</a> 行定义.</p>

</div>
</div>
<a id="a72223302a53d43f3e758c9c555e03ccb" name="a72223302a53d43f3e758c9c555e03ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72223302a53d43f3e758c9c555e03ccb">&#9670;&#160;</a></span>toLowerCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::toLowerCase </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将字符串转换为小写 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要转换的字符串引用，转换后直接修改原字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00235">235</a> 行定义.</p>

</div>
</div>
<a id="a6705c49c050069e507cfb60a88c7858e" name="a6705c49c050069e507cfb60a88c7858e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6705c49c050069e507cfb60a88c7858e">&#9670;&#160;</a></span>toUpperCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::toUpperCase </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>将字符串转换为大写 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要转换的字符串引用，转换后直接修改原字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00250">250</a> 行定义.</p>

</div>
</div>
<a id="afa3e4300984ddfc0777985b4c4f1b7f8" name="afa3e4300984ddfc0777985b4c4f1b7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3e4300984ddfc0777985b4c4f1b7f8">&#9670;&#160;</a></span>trim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string StrUtil::trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;&#160;\t\r&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>修剪字符串两端的指定字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要修剪的字符串 </td></tr>
    <tr><td class="paramname">delims</td><td>要移除的字符集合，默认为空白字符（空格、换页、换行、回车、制表符、垂直制表符） </td></tr>
    <tr><td class="paramname">left</td><td>是否修剪左端，默认为true </td></tr>
    <tr><td class="paramname">right</td><td>是否修剪右端，默认为true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>std::string 修剪后的字符串 </dd></dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00067">67</a> 行定义.</p>

</div>
</div>
<a id="a0ae7e6b1a976327b4ea1634562e19043" name="a0ae7e6b1a976327b4ea1634562e19043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae7e6b1a976327b4ea1634562e19043">&#9670;&#160;</a></span>trim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::trim </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdc_8h.html#a2c212835823e3c54a8ab6d95c652660e">const</a> char *&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;&#160;\t\r&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>修剪字符串两端的指定字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要修剪的字符串引用 </td></tr>
    <tr><td class="paramname">delims</td><td>要移除的字符集合，默认为空格、制表符和回车 </td></tr>
    <tr><td class="paramname">left</td><td>是否修剪左端，默认为true </td></tr>
    <tr><td class="paramname">right</td><td>是否修剪右端，默认为true </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00050">50</a> 行定义.</p>

</div>
</div>
<a id="a3e6af0027cb7fe0021e97e64c9f83e8b" name="a3e6af0027cb7fe0021e97e64c9f83e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e6af0027cb7fe0021e97e64c9f83e8b">&#9670;&#160;</a></span>trimAllSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StrUtil::trimAllSpace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>去除字符串中的所有空格字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>要处理的字符串引用，处理后直接修改原字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a> 第 <a class="el" href="StrUtil_8hpp_source.html#l00083">83</a> 行定义.</p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>src/Share/<a class="el" href="StrUtil_8hpp_source.html">StrUtil.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classStrUtil.html">StrUtil</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
